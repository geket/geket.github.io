<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Code Portfolio | æ¡œ</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;0,400;0,600;1,300;1,400&family=Noto+Serif+JP:wght@200;300;400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --petal-pink: #ffb7c5;
            --petal-soft: #ffd1dc;
            --petal-deep: #e891a0;
            --bark-brown: #4a3728;
            --night-indigo: #1a1a2e;
            --twilight: #16213e;
            --moon-glow: #f8f0e3;
            --gold-accent: #d4af37;
            --mist: rgba(255, 183, 197, 0.1);
            --cloud-1: rgba(255, 220, 230, 0.08);
            --cloud-2: rgba(200, 180, 220, 0.06);
            --cloud-3: rgba(255, 200, 210, 0.05);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Cormorant Garamond', serif;
            background: linear-gradient(180deg, 
                var(--night-indigo) 0%, 
                #2d1f3d 30%,
                #3d2a4a 50%,
                #4a3555 70%,
                var(--twilight) 100%);
            color: var(--moon-glow);
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }

        /* ========== ANIMATED CLOUDS ========== */
        .cloud-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
            overflow: hidden;
        }

        .cloud {
            position: absolute;
            border-radius: 50%;
            filter: blur(40px);
            opacity: 0;
            animation: floatCloud linear infinite;
        }

        .cloud-layer-1 .cloud {
            background: radial-gradient(ellipse, var(--cloud-1), transparent 70%);
        }

        .cloud-layer-2 .cloud {
            background: radial-gradient(ellipse, var(--cloud-2), transparent 70%);
        }

        .cloud-layer-3 .cloud {
            background: radial-gradient(ellipse, var(--cloud-3), transparent 70%);
        }

        @keyframes floatCloud {
            0% {
                transform: translateX(-100%) translateY(0);
                opacity: 0;
            }
            5% {
                opacity: 1;
            }
            95% {
                opacity: 1;
            }
            100% {
                transform: translateX(calc(100vw + 100%)) translateY(20px);
                opacity: 0;
            }
        }

        /* Wispy cloud shapes */
        .cloud-wisp {
            position: absolute;
            background: linear-gradient(90deg, transparent, rgba(255, 200, 220, 0.04), transparent);
            height: 2px;
            border-radius: 50%;
            filter: blur(8px);
            animation: wispFloat linear infinite;
        }

        @keyframes wispFloat {
            0% {
                transform: translateX(-100%) scaleX(1);
                opacity: 0;
            }
            10% {
                opacity: 0.6;
            }
            90% {
                opacity: 0.6;
            }
            100% {
                transform: translateX(100vw) scaleX(1.5);
                opacity: 0;
            }
        }

        /* Moon glow */
        .celestial {
            position: fixed;
            top: 80px;
            right: 15%;
            width: 80px;
            height: 80px;
            z-index: 0;
            transition: transform 0.3s ease-out;
            overflow: visible;
        }

        /* ===== MOON WITH PHASES ===== */
        .moon-container {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: visible;
        }

        .moon-body {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: linear-gradient(135deg, 
                #fdfcf9 0%, 
                #f5f0e6 30%, 
                #e8e0d0 70%, 
                #d4caba 100%);
            box-shadow: 
                inset -8px -5px 15px rgba(0, 0, 0, 0.15),
                inset 5px 5px 10px rgba(255, 255, 255, 0.5),
                0 0 40px rgba(255, 250, 230, 0.6),
                0 0 80px rgba(255, 245, 220, 0.3);
            overflow: hidden;
        }

        /* Moon craters */
        .moon-body::before {
            content: '';
            position: absolute;
            width: 15px;
            height: 15px;
            background: radial-gradient(circle, rgba(180, 170, 155, 0.4) 0%, transparent 70%);
            border-radius: 50%;
            top: 20%;
            left: 25%;
        }

        .moon-body::after {
            content: '';
            position: absolute;
            width: 22px;
            height: 22px;
            background: radial-gradient(circle, rgba(180, 170, 155, 0.3) 0%, transparent 70%);
            border-radius: 50%;
            top: 50%;
            left: 55%;
        }

        .moon-crater-small {
            position: absolute;
            width: 10px;
            height: 10px;
            background: radial-gradient(circle, rgba(180, 170, 155, 0.35) 0%, transparent 70%);
            border-radius: 50%;
            top: 65%;
            left: 30%;
        }

        /* Moon phase shadow overlay */
        .moon-phase {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: #1a1a2e;
            opacity: 0.95;
            transition: clip-path 0.5s ease;
        }

        /* Moon glow */
        .moon-glow {
            position: absolute;
            top: -30%;
            left: -30%;
            width: 160%;
            height: 160%;
            background: radial-gradient(circle, 
                rgba(255, 250, 240, 0.15) 0%,
                rgba(255, 230, 210, 0.08) 40%,
                transparent 70%);
            animation: moonGlowPulse 8s ease-in-out infinite;
            pointer-events: none;
        }

        @keyframes moonGlowPulse {
            0%, 100% { opacity: 0.7; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.05); }
        }

        /* ===== SUN ===== */
        .sun-container {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: visible;
        }

        .sun-body {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: radial-gradient(circle at 35% 35%, 
                #fff9e6 0%, 
                #ffeb80 20%, 
                #ffd700 50%, 
                #ffb700 80%, 
                #ff9500 100%);
            box-shadow: 
                inset -5px -5px 20px rgba(255, 150, 0, 0.4),
                inset 5px 5px 15px rgba(255, 255, 200, 0.6),
                0 0 60px rgba(255, 200, 50, 0.8),
                0 0 120px rgba(255, 180, 0, 0.4);
            animation: sunPulse 4s ease-in-out infinite;
            z-index: 2;
        }

        @keyframes sunPulse {
            0%, 100% { 
                transform: scale(1);
                box-shadow: 
                    inset -5px -5px 20px rgba(255, 150, 0, 0.4),
                    inset 5px 5px 15px rgba(255, 255, 200, 0.6),
                    0 0 60px rgba(255, 200, 50, 0.8),
                    0 0 120px rgba(255, 180, 0, 0.4);
            }
            50% { 
                transform: scale(1.02);
                box-shadow: 
                    inset -5px -5px 20px rgba(255, 150, 0, 0.4),
                    inset 5px 5px 15px rgba(255, 255, 200, 0.6),
                    0 0 80px rgba(255, 200, 50, 0.9),
                    0 0 150px rgba(255, 180, 0, 0.5);
            }
        }

        /* Sun rays - Kris Blade Style */
        .sun-rays {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: visible;
            animation: sunRaysSpin 90s linear infinite;
        }

        .kris-blade {
            position: absolute;
            bottom: 50%;
            left: 50%;
            width: 12px;
            height: 40px;
            transform-origin: center bottom;
            margin-left: -6px;
            transform: rotate(var(--ray-rotation, 0deg)) translateY(var(--ray-translate, -40px));
            animation: bladeShimmer 2s ease-in-out infinite;
            overflow: visible;
        }

        .kris-blade svg {
            width: 100%;
            height: 100%;
            overflow: visible;
            filter: drop-shadow(0 0 4px rgba(255, 200, 50, 0.8)) drop-shadow(0 0 8px rgba(255, 150, 0, 0.5));
        }

        /* Stagger blade animations for 12 blades */
        .kris-blade:nth-child(1) { animation-delay: 0s; }
        .kris-blade:nth-child(2) { animation-delay: 0.15s; }
        .kris-blade:nth-child(3) { animation-delay: 0.3s; }
        .kris-blade:nth-child(4) { animation-delay: 0.45s; }
        .kris-blade:nth-child(5) { animation-delay: 0.6s; }
        .kris-blade:nth-child(6) { animation-delay: 0.75s; }
        .kris-blade:nth-child(7) { animation-delay: 0.9s; }
        .kris-blade:nth-child(8) { animation-delay: 1.05s; }
        .kris-blade:nth-child(9) { animation-delay: 1.2s; }
        .kris-blade:nth-child(10) { animation-delay: 1.35s; }
        .kris-blade:nth-child(11) { animation-delay: 1.5s; }
        .kris-blade:nth-child(12) { animation-delay: 1.65s; }

        @keyframes bladeShimmer {
            0%, 100% {
                opacity: 0.85;
                filter: drop-shadow(0 0 4px rgba(255, 200, 50, 0.8));
            }
            50% {
                opacity: 1;
                filter: drop-shadow(0 0 8px rgba(255, 220, 100, 1));
            }
        }

        /* Flame Particles Container with Gooey Filter */
        .flame-particles {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            overflow: visible;
            pointer-events: none;
            filter: url(#flameGooey);
        }

        .flame-particle {
            position: absolute;
            border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
            background: radial-gradient(ellipse at 30% 30%, 
                rgba(255, 255, 220, 1) 0%,
                rgba(255, 220, 100, 0.9) 30%,
                rgba(255, 150, 50, 0.7) 60%,
                rgba(255, 100, 0, 0.4) 100%);
            animation: flameFloat var(--flame-duration, 2s) ease-out infinite;
            animation-delay: var(--flame-delay, 0s);
            opacity: 0;
            box-shadow: inset 0 0 4px rgba(255, 255, 200, 0.8);
        }

        .flame-particle.ember {
            border-radius: 50%;
            background: radial-gradient(circle,
                rgba(255, 255, 240, 1) 0%,
                rgba(255, 200, 80, 0.9) 50%,
                rgba(255, 120, 0, 0.5) 100%);
            animation: emberFloat var(--flame-duration, 1.5s) ease-out infinite;
            box-shadow: 0 0 6px rgba(255, 180, 50, 0.8);
        }

        .flame-particle.spark {
            border-radius: 50%;
            background: #fffaf0;
            box-shadow: 
                0 0 3px rgba(255, 255, 255, 1),
                0 0 6px rgba(255, 200, 50, 0.9);
            animation: sparkFloat var(--flame-duration, 1s) ease-out infinite;
        }

        .flame-particle.wisp {
            border-radius: 50% 50% 50% 50% / 70% 70% 30% 30%;
            background: linear-gradient(to top,
                rgba(255, 180, 50, 0.85) 0%,
                rgba(255, 120, 0, 0.5) 50%,
                transparent 100%);
            animation: wispFloat var(--flame-duration, 2s) ease-out infinite;
        }

        /* New scatter particles - small and erratic */
        .flame-particle.scatter {
            border-radius: 50%;
            background: radial-gradient(circle,
                rgba(255, 255, 200, 1) 0%,
                rgba(255, 180, 80, 0.8) 60%,
                rgba(255, 100, 0, 0.3) 100%);
            animation: scatterFloat var(--flame-duration, 1.2s) cubic-bezier(0.2, 0.8, 0.3, 1) infinite;
            box-shadow: 0 0 3px rgba(255, 200, 100, 0.9);
        }

        /* Mingle particles - orbit and merge */
        .flame-particle.mingle {
            border-radius: 50%;
            background: radial-gradient(circle,
                rgba(255, 240, 180, 1) 0%,
                rgba(255, 200, 100, 0.85) 50%,
                rgba(255, 140, 50, 0.5) 100%);
            animation: mingleFloat var(--flame-duration, 2.5s) ease-in-out infinite;
            box-shadow: inset 0 0 3px rgba(255, 255, 220, 0.9);
        }

        @keyframes flameFloat {
            0% {
                transform: translate(var(--start-x, 0), var(--start-y, 0)) scale(0.5);
                opacity: 0;
            }
            15% { opacity: 1; }
            50% {
                transform: translate(calc(var(--start-x, 0) + var(--end-x, 20px) * 0.5), calc(var(--start-y, 0) + var(--end-y, -60px) * 0.5)) scale(1.15);
                opacity: 0.95;
            }
            100% {
                transform: translate(calc(var(--start-x, 0) + var(--end-x, 20px)), calc(var(--start-y, 0) + var(--end-y, -60px))) scale(0.2);
                opacity: 0;
            }
        }

        @keyframes emberFloat {
            0% {
                transform: translate(var(--start-x, 0), var(--start-y, 0)) scale(0.6);
                opacity: 0;
            }
            15% { opacity: 1; }
            60% {
                transform: translate(calc(var(--start-x, 0) + var(--end-x, 15px) * 0.7), calc(var(--start-y, 0) + var(--end-y, -40px) * 0.7)) scale(1.1);
                opacity: 0.85;
            }
            100% {
                transform: translate(calc(var(--start-x, 0) + var(--end-x, 15px)), calc(var(--start-y, 0) + var(--end-y, -40px))) scale(0);
                opacity: 0;
            }
        }

        @keyframes sparkFloat {
            0% {
                transform: translate(var(--start-x, 0), var(--start-y, 0)) scale(1);
                opacity: 0;
            }
            10% { opacity: 1; }
            100% {
                transform: translate(calc(var(--start-x, 0) + var(--end-x, 25px)), calc(var(--start-y, 0) + var(--end-y, -50px))) scale(0);
                opacity: 0;
            }
        }

        @keyframes wispFloat {
            0% {
                transform: translate(var(--start-x, 0), var(--start-y, 0)) scaleX(0.5) scaleY(0.4);
                opacity: 0;
            }
            15% { opacity: 0.8; }
            100% {
                transform: translate(calc(var(--start-x, 0) + var(--end-x, 20px)), calc(var(--start-y, 0) + var(--end-y, -60px))) scaleX(0.3) scaleY(0.5);
                opacity: 0;
            }
        }

        /* Scatter - erratic zigzag movement */
        @keyframes scatterFloat {
            0% {
                transform: translate(var(--start-x, 0), var(--start-y, 0)) scale(0.3);
                opacity: 0;
            }
            10% { 
                opacity: 1;
                transform: translate(calc(var(--start-x, 0) + var(--scatter-x1, 5px)), calc(var(--start-y, 0) + var(--scatter-y1, -10px))) scale(0.8);
            }
            35% {
                transform: translate(calc(var(--start-x, 0) + var(--scatter-x2, -8px)), calc(var(--start-y, 0) + var(--scatter-y2, -25px))) scale(1);
            }
            60% {
                transform: translate(calc(var(--start-x, 0) + var(--scatter-x3, 10px)), calc(var(--start-y, 0) + var(--scatter-y3, -40px))) scale(0.7);
                opacity: 0.8;
            }
            100% {
                transform: translate(calc(var(--start-x, 0) + var(--end-x, 15px)), calc(var(--start-y, 0) + var(--end-y, -55px))) scale(0.1);
                opacity: 0;
            }
        }

        /* Mingle - wobble toward others then drift */
        @keyframes mingleFloat {
            0% {
                transform: translate(var(--start-x, 0), var(--start-y, 0)) scale(0.4);
                opacity: 0;
            }
            12% { 
                opacity: 1;
            }
            30% {
                transform: translate(calc(var(--start-x, 0) + var(--mingle-x, -5px)), calc(var(--start-y, 0) + var(--mingle-y, -8px))) scale(1.2);
                opacity: 1;
            }
            55% {
                transform: translate(calc(var(--start-x, 0) + var(--mingle-x, -5px) * 0.3), calc(var(--start-y, 0) + var(--end-y, -30px) * 0.6)) scale(1.1);
                opacity: 0.9;
            }
            100% {
                transform: translate(calc(var(--start-x, 0) + var(--end-x, 10px)), calc(var(--start-y, 0) + var(--end-y, -50px))) scale(0.2);
                opacity: 0;
            }
        }

        @keyframes sunRaysSpin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Sun corona */
        .sun-corona {
            position: absolute;
            top: -40%;
            left: -40%;
            width: 180%;
            height: 180%;
            background: radial-gradient(circle, 
                rgba(255, 240, 150, 0.2) 0%,
                rgba(255, 200, 50, 0.1) 40%,
                transparent 70%);
            animation: coronaPulse 6s ease-in-out infinite;
            pointer-events: none;
        }

        @keyframes coronaPulse {
            0%, 100% { opacity: 0.8; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.1); }
        }

        /* ========== SAKURA PETALS ========== */
        .petal-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        /* ========== TREE SILHOUETTES ========== */
        .tree-silhouette {
            position: fixed;
            bottom: 0;
            right: -50px;
            width: 400px;
            height: 90vh;
            opacity: 0.15;
            z-index: 0;
            pointer-events: none;
            color: var(--petal-deep);
        }

        .tree-left {
            left: -100px;
            right: auto;
            transform: scaleX(-1);
        }

        /* ========== MAIN CONTENT ========== */
        .content {
            position: relative;
            z-index: 2;
            max-width: 1100px;
            margin: 0 auto;
            padding: 50px 30px;
            overflow-x: hidden;
        }

        /* Header */
        .hero-image-section {
            margin-bottom: 30px;
        }

        .hero-image-container {
            position: relative;
            width: 100%;
            max-width: 267px;
            margin: 0 auto;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4),
                        0 0 40px rgba(255, 183, 197, 0.1);
        }

        .hero-bg-img {
            width: 100%;
            height: auto;
            display: block;
            filter: brightness(0.9) contrast(1.1);
            animation: imageReconstruct 2s ease-out forwards;
        }

        .hero-kanji-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Noto Serif JP', serif;
            font-size: 12rem;
            font-weight: 200;
            color: var(--petal-pink);
            text-shadow: 
                0 0 80px rgba(255, 183, 197, 0.9),
                0 0 160px rgba(255, 183, 197, 0.6),
                0 0 240px rgba(255, 183, 197, 0.4),
                0 6px 12px rgba(0, 0, 0, 0.6);
            animation: kanjiGlow 4s ease-in-out infinite, kanjiReconstruct 2s ease-out forwards;
            z-index: 2;
            pointer-events: none;
        }

        @keyframes imageReconstruct {
            0% {
                filter: brightness(0.9) contrast(1.1) blur(15px) saturate(0);
                clip-path: inset(0 0 100% 0);
            }
            10% {
                clip-path: inset(0 0 80% 0);
                filter: brightness(1.2) contrast(1.5) blur(10px) saturate(0.3);
            }
            20% {
                clip-path: inset(0 0 60% 0);
                filter: brightness(0.8) contrast(1.3) blur(8px) saturate(0.5);
            }
            30% {
                clip-path: inset(0 0 40% 0);
                filter: brightness(1.1) contrast(1.2) blur(5px) saturate(0.7);
            }
            50% {
                clip-path: inset(0 0 20% 0);
                filter: brightness(0.95) contrast(1.15) blur(3px) saturate(0.85);
            }
            70% {
                clip-path: inset(0 0 5% 0);
                filter: brightness(0.92) contrast(1.12) blur(1px) saturate(0.95);
            }
            100% {
                clip-path: inset(0 0 0 0);
                filter: brightness(0.9) contrast(1.1) blur(0) saturate(1);
            }
        }

        @keyframes kanjiReconstruct {
            0% {
                opacity: 0;
                filter: blur(20px);
                transform: translate(-50%, -50%) scale(0.8);
                text-shadow: 
                    0 0 100px rgba(255, 183, 197, 1),
                    0 0 200px rgba(255, 183, 197, 0.8);
            }
            20% {
                opacity: 0.3;
                filter: blur(15px);
                transform: translate(-50%, -50%) scale(0.9) skewX(5deg);
            }
            40% {
                opacity: 0.5;
                filter: blur(10px);
                transform: translate(-50%, -50%) scale(0.95) skewX(-3deg);
            }
            60% {
                opacity: 0.7;
                filter: blur(5px);
                transform: translate(-50%, -50%) scale(0.98) skewX(1deg);
            }
            80% {
                opacity: 0.9;
                filter: blur(2px);
                transform: translate(-50%, -50%) scale(0.99);
            }
            100% {
                opacity: 1;
                filter: blur(0);
                transform: translate(-50%, -50%) scale(1);
                text-shadow: 
                    0 0 80px rgba(255, 183, 197, 0.9),
                    0 0 160px rgba(255, 183, 197, 0.6),
                    0 0 240px rgba(255, 183, 197, 0.4),
                    0 6px 12px rgba(0, 0, 0, 0.6);
            }
        }

        @media (max-width: 768px) {
            .hero-kanji-overlay {
                font-size: 8rem;
            }
        }

        .header {
            text-align: center;
            margin-bottom: 60px;
            animation: fadeInDown 1.5s ease-out;
        }

        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .logo-kanji {
            font-family: 'Noto Serif JP', serif;
            font-size: 4rem;
            font-weight: 200;
            color: var(--petal-pink);
            text-shadow: 
                0 0 60px rgba(255, 183, 197, 0.5),
                0 0 120px rgba(255, 183, 197, 0.3);
            letter-spacing: 0.3em;
            margin-bottom: 15px;
            animation: kanjiGlow 4s ease-in-out infinite;
        }

        @keyframes kanjiGlow {
            0%, 100% { 
                text-shadow: 
                    0 0 60px rgba(255, 183, 197, 0.5),
                    0 0 120px rgba(255, 183, 197, 0.3);
            }
            50% { 
                text-shadow: 
                    0 0 80px rgba(255, 183, 197, 0.7),
                    0 0 160px rgba(255, 183, 197, 0.4);
            }
        }

        .header h1 {
            font-size: 2.8rem;
            font-weight: 300;
            letter-spacing: 0.4em;
            text-transform: uppercase;
            margin-bottom: 10px;
            background: linear-gradient(135deg, var(--moon-glow), var(--petal-pink));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header .subtitle {
            font-size: 1.1rem;
            font-style: italic;
            color: var(--petal-soft);
            opacity: 0.8;
            letter-spacing: 0.2em;
        }

        .divider {
            width: 150px;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--petal-pink), transparent);
            margin: 30px auto;
            transform: scaleX(0);
            animation: dividerExpand 1.5s ease-out 0.8s forwards, dividerPulse 3s ease-in-out 2.5s infinite;
        }

        @keyframes dividerExpand {
            0% {
                transform: scaleX(0);
            }
            100% {
                transform: scaleX(1);
            }
        }

        @keyframes dividerPulse {
            0%, 100% {
                opacity: 0.6;
                box-shadow: 0 0 0px transparent;
            }
            50% {
                opacity: 1;
                box-shadow: 0 0 8px var(--petal-pink), 0 0 15px rgba(255, 183, 197, 0.3);
            }
        }

        /* Portfolio Grid */
        .portfolio-section {
            margin-bottom: 60px;
        }

        .section-title {
            text-align: center;
            margin-bottom: 40px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .section-title-jp {
            font-family: 'Noto Serif JP', serif;
            font-size: 2.2rem;
            font-weight: 400;
            letter-spacing: 0.15em;
            background: linear-gradient(135deg, 
                #ffb7c5 0%, 
                #ff9eb5 25%, 
                #ffd4dc 50%, 
                #ff9eb5 75%, 
                #ffb7c5 100%);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            filter: drop-shadow(0 0 8px rgba(255, 183, 197, 0.6))
                    drop-shadow(0 0 20px rgba(255, 183, 197, 0.4))
                    drop-shadow(0 0 40px rgba(255, 183, 197, 0.2));
            animation: sakuraShimmer 4s ease-in-out infinite;
            position: relative;
        }

        .section-title-jp::before {
            content: attr(data-text);
            position: absolute;
            top: 0;
            left: 0;
            background: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='60' height='60' viewBox='0 0 60 60'%3E%3Cpath fill='%23ffd4dc' fill-opacity='0.3' d='M30 5c2 8-3 12-3 12s8-2 12 3c-8 2-12-3-12-3s2 8-3 12c-2-8 3-12 3-12s-8 2-12-3c8-2 12 3 12 3s-2-8 3-12z'/%3E%3Cpath fill='%23ffb7c5' fill-opacity='0.2' d='M45 35c1 4-1.5 6-1.5 6s4-1 6 1.5c-4 1-6-1.5-6-1.5s1 4-1.5 6c-1-4 1.5-6 1.5-6s-4 1-6-1.5c4-1 6 1.5 6 1.5s-1-4 1.5-6z'/%3E%3Cpath fill='%23ffc4d0' fill-opacity='0.25' d='M12 42c1 4-1.5 6-1.5 6s4-1 6 1.5c-4 1-6-1.5-6-1.5s1 4-1.5 6c-1-4 1.5-6 1.5-6s-4 1-6-1.5c4-1 6 1.5 6 1.5s-1-4 1.5-6z'/%3E%3C/svg%3E") repeat;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            opacity: 0.7;
            z-index: -1;
        }

        @keyframes sakuraShimmer {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .section-title-en {
            font-family: 'Cormorant Garamond', serif;
            font-size: 1.1rem;
            font-weight: 300;
            color: var(--petal-soft);
            letter-spacing: 0.4em;
            text-transform: uppercase;
            opacity: 0.7;
        }

        .portfolio-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 25px;
        }

        .project-card-link {
            text-decoration: none;
            display: block;
        }

        .project-card {
            background: linear-gradient(145deg, rgba(255, 183, 197, 0.08), rgba(26, 26, 46, 0.6));
            border: 1px solid rgba(255, 183, 197, 0.15);
            border-radius: 16px;
            padding: 25px;
            backdrop-filter: blur(10px);
            transition: all 0.5s cubic-bezier(0.23, 1, 0.32, 1);
            position: relative;
            overflow: hidden;
            height: 100%;
        }

        .project-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, var(--petal-deep), var(--petal-pink), var(--petal-soft));
            opacity: 0;
            transition: opacity 0.4s;
        }

        .project-card:hover {
            transform: translateY(-6px);
            border-color: rgba(255, 183, 197, 0.3);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3),
                        0 0 30px rgba(255, 183, 197, 0.1);
        }

        .project-card:hover::before {
            opacity: 1;
        }

        .project-card h3 {
            font-size: 1.3rem;
            font-weight: 400;
            margin-bottom: 10px;
            color: var(--moon-glow);
        }

        .project-card p {
            font-size: 0.95rem;
            line-height: 1.6;
            color: rgba(248, 240, 227, 0.7);
        }

        .project-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 15px;
        }

        .tag {
            font-size: 0.75rem;
            padding: 4px 12px;
            background: rgba(255, 183, 197, 0.1);
            border: 1px solid rgba(255, 183, 197, 0.2);
            border-radius: 15px;
            color: var(--petal-soft);
            letter-spacing: 0.05em;
        }

        /* GitHub Stats Section */
        .stats-section {
            margin: 80px 0 60px;
        }

        .github-stats-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 25px;
            justify-items: center;
        }

        .github-stats-container.compact {
            gap: 20px;
        }

        /* Combined Stats Card */
        .combined-stat-card {
            width: 100%;
            max-width: 100%;
            grid-column: 1 / -1;
        }

        .combined-stat-content {
            display: flex;
            width: 100%;
            gap: 0;
        }

        .stat-half {
            flex: 1;
            padding: 0 20px;
        }

        .stat-half:first-child {
            padding-left: 0;
        }

        .stat-half:last-child {
            padding-right: 0;
        }

        .stat-divider {
            width: 1px;
            background: linear-gradient(180deg, transparent, rgba(255, 183, 197, 0.3), transparent);
            margin: 0 10px;
        }

        /* Vibrating/Buzzing Effect */
        .stat-value.vibrate {
            position: relative;
            display: inline-block;
            padding: 8px 15px;
            background: rgba(255, 183, 197, 0.1);
            border: 1px solid rgba(255, 183, 197, 0.25);
            border-radius: 10px;
            animation: subtlePulse 2s ease-in-out infinite;
            box-shadow: 0 0 15px rgba(255, 183, 197, 0.15);
        }

        @keyframes subtlePulse {
            0%, 100% {
                box-shadow: 0 0 10px rgba(255, 183, 197, 0.15);
                border-color: rgba(255, 183, 197, 0.25);
            }
            50% {
                box-shadow: 0 0 20px rgba(255, 183, 197, 0.3), 0 0 30px rgba(255, 183, 197, 0.1);
                border-color: rgba(255, 183, 197, 0.4);
            }
        }

        .stat-value.vibrate::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            border-radius: 12px;
            background: linear-gradient(45deg, transparent, rgba(255, 183, 197, 0.1), transparent);
            animation: shimmer 3s ease-in-out infinite;
            z-index: -1;
        }

        @keyframes shimmer {
            0%, 100% { opacity: 0; }
            50% { opacity: 1; }
        }

        .stats-card {
            background: linear-gradient(145deg, rgba(255, 183, 197, 0.06), rgba(26, 26, 46, 0.5));
            border: 1px solid rgba(255, 183, 197, 0.12);
            border-radius: 16px;
            padding: 20px;
            backdrop-filter: blur(10px);
            transition: all 0.4s ease;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            position: relative;
        }

        .stats-card:hover {
            transform: translateY(-4px);
            border-color: rgba(255, 183, 197, 0.25);
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.2),
                        0 0 20px rgba(255, 183, 197, 0.08);
        }

        .stats-card img {
            max-width: 100%;
            height: auto;
        }

        .stats-card.full-width {
            grid-column: 1 / -1;
        }

        .snake-card {
            padding: 15px;
            background: linear-gradient(145deg, rgba(255, 183, 197, 0.04), rgba(26, 26, 46, 0.6));
        }

        .snake-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            /* iOS performance optimization */
            -webkit-transform: translateZ(0);
            transform: translateZ(0);
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
        }

        .snake-card img {
            width: 100%;
            max-width: 700px;
            display: block;
            margin: 0 auto;
            /* iOS SVG rendering optimization */
            -webkit-transform: translate3d(0, 0, 0);
            transform: translate3d(0, 0, 0);
            will-change: transform;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
        }

        /* iOS-specific fixes for SVG animations */
        @supports (-webkit-touch-callout: none) {
            .snake-card img {
                image-rendering: -webkit-optimize-contrast;
            }
        }

        .snake-setup {
            text-align: center;
            padding: 30px;
            color: var(--petal-soft);
        }

        .snake-setup p {
            margin: 8px 0;
            font-size: 1.1rem;
        }

        .snake-setup .small {
            font-size: 0.9rem;
            opacity: 0.6;
        }

        /* Expand Stars Button */
        .expand-stars-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            width: 100%;
            margin-top: 20px;
            padding: 12px 20px;
            background: rgba(212, 175, 55, 0.1);
            border: 1px solid rgba(212, 175, 55, 0.25);
            border-radius: 10px;
            color: var(--gold-accent);
            font-family: 'Cormorant Garamond', serif;
            font-size: 0.95rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .expand-stars-btn:hover {
            background: rgba(212, 175, 55, 0.2);
            border-color: rgba(212, 175, 55, 0.4);
        }

        .expand-stars-btn.expanded .expand-icon {
            transform: rotate(180deg);
        }

        .expand-activity-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            width: 100%;
            margin-top: 15px;
            padding: 10px 20px;
            background: rgba(255, 183, 197, 0.1);
            border: 1px solid rgba(255, 183, 197, 0.25);
            border-radius: 10px;
            color: var(--petal-pink);
            font-family: 'Cormorant Garamond', serif;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .expand-activity-btn:hover {
            background: rgba(255, 183, 197, 0.2);
            border-color: rgba(255, 183, 197, 0.4);
        }

        .expand-activity-btn.expanded .expand-icon {
            transform: rotate(180deg);
        }

        .expand-icon {
            transition: transform 0.3s ease;
        }

        .star-item.hidden {
            display: none;
        }

        .star-item.show {
            display: flex;
            animation: fadeInStar 0.3s ease forwards;
        }

        @keyframes fadeInStar {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .stat-fallback {
            text-align: center;
            padding: 30px 20px;
            color: var(--petal-soft);
        }

        .stat-fallback .stat-icon {
            font-size: 2.5rem;
            display: block;
            margin-bottom: 12px;
        }

        .stat-fallback p {
            font-size: 1.1rem;
            margin-bottom: 12px;
            color: var(--moon-glow);
        }

        .stat-fallback a {
            color: var(--petal-pink);
            text-decoration: none;
            font-size: 0.9rem;
            opacity: 0.8;
            transition: opacity 0.3s;
        }

        .stat-fallback a:hover {
            opacity: 1;
        }

        /* Custom Stats Cards */
        .custom-stat {
            min-width: 260px;
        }

        .custom-stat-content {
            width: 100%;
        }

        .custom-stat-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 18px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(255, 183, 197, 0.15);
        }

        .custom-stat-header .stat-icon {
            font-size: 1.4rem;
        }

        .custom-stat-header h3 {
            font-size: 1.1rem;
            font-weight: 400;
            color: var(--petal-pink);
            margin: 0;
        }

        .custom-stat-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
        }

        .custom-stat-item {
            text-align: center;
        }

        .custom-stat-item .stat-value {
            display: block;
            font-size: 1.6rem;
            font-weight: 300;
            color: var(--moon-glow);
            margin-bottom: 3px;
        }

        .custom-stat-item .stat-label {
            font-size: 0.75rem;
            color: var(--petal-soft);
            opacity: 0.7;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        /* Cross Grid Layout for Stats */
        .stats-cross-grid {
            position: relative;
            display: flex;
            flex-direction: column;
            gap: 0;
        }

        .stats-cross-row {
            display: flex;
            justify-content: space-around;
            padding: 15px 0;
        }

        .cross-stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            flex: 1;
            text-align: center;
        }

        .stat-label-top {
            font-size: 0.7rem;
            color: var(--petal-soft);
            opacity: 0.7;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 8px;
        }

        .stat-label-bottom {
            font-size: 0.7rem;
            color: var(--petal-soft);
            opacity: 0.7;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-top: 8px;
        }

        .cross-divider-horizontal {
            width: 100%;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255, 183, 197, 0.4), transparent);
        }

        .cross-divider-vertical {
            position: absolute;
            left: 50%;
            top: 0;
            bottom: 0;
            width: 1px;
            background: linear-gradient(180deg, transparent, rgba(255, 183, 197, 0.4), transparent);
            transform: translateX(-50%);
        }

        /* Language Bars */
        .language-bars {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .lang-loading {
            color: var(--petal-soft);
            opacity: 0.6;
            font-style: italic;
            font-size: 0.9rem;
        }

        .lang-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
            transition: all 0.3s ease;
        }

        .lang-item.hidden {
            display: none;
        }

        .lang-item.expandable {
            cursor: pointer;
        }

        .lang-item.expandable:hover .lang-name {
            color: var(--petal-pink);
        }

        .lang-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .lang-name {
            display: flex;
            align-items: center;
            gap: 6px;
            color: var(--moon-glow);
            font-size: 0.85rem;
            transition: color 0.2s ease;
        }

        .lang-expand-icon {
            font-size: 0.7rem;
            transition: transform 0.3s ease;
            opacity: 0.6;
        }

        .lang-item.expanded .lang-expand-icon {
            transform: rotate(90deg);
        }

        .lang-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .lang-percent {
            color: var(--petal-soft);
            font-size: 0.75rem;
            opacity: 0.8;
        }

        .lang-bar-bg {
            height: 6px;
            background: rgba(255, 183, 197, 0.1);
            border-radius: 3px;
            overflow: hidden;
        }

        .lang-bar-fill {
            height: 100%;
            border-radius: 3px;
            transition: width 1s ease-out;
        }

        /* Language sub-details */
        .lang-details {
            display: none;
            margin-left: 14px;
            margin-top: 8px;
            padding: 10px;
            background: rgba(139, 90, 139, 0.1);
            border-radius: 8px;
            border-left: 2px solid var(--petal-pink);
        }

        .lang-item.expanded .lang-details {
            display: block;
            animation: slideDown 0.3s ease;
        }

        @keyframes slideDown {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .lang-stats {
            display: flex;
            gap: 15px;
            margin-bottom: 10px;
            font-size: 0.75rem;
        }

        .lang-stat {
            display: flex;
            align-items: center;
            gap: 4px;
            color: var(--moon-glow);
        }

        .lang-stat-value {
            color: var(--petal-pink);
            font-weight: 600;
        }

        .lang-commits {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .lang-commits-title {
            font-size: 0.7rem;
            color: var(--petal-soft);
            opacity: 0.8;
            margin-bottom: 2px;
        }

        .lang-commit-item {
            display: flex;
            align-items: flex-start;
            gap: 8px;
            padding: 6px 8px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 4px;
            font-size: 0.7rem;
            transition: background 0.2s ease;
        }

        .lang-commit-item:hover {
            background: rgba(255, 183, 197, 0.1);
        }

        .commit-icon {
            color: var(--petal-pink);
            font-size: 0.65rem;
            margin-top: 2px;
        }

        .commit-info {
            flex: 1;
            min-width: 0;
        }

        .commit-msg {
            color: var(--moon-glow);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .commit-meta {
            display: flex;
            gap: 8px;
            color: var(--petal-soft);
            opacity: 0.7;
            font-size: 0.65rem;
            margin-top: 2px;
        }

        .commit-repo {
            color: var(--petal-pink);
        }

        /* Expand languages button */
        .lang-expand-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            margin-top: 10px;
            padding: 8px 16px;
            background: rgba(255, 183, 197, 0.1);
            border: 1px solid rgba(255, 183, 197, 0.2);
            border-radius: 20px;
            color: var(--petal-pink);
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .lang-expand-btn:hover {
            background: rgba(255, 183, 197, 0.2);
            transform: translateY(-2px);
        }

        .lang-expand-btn .arrow {
            transition: transform 0.3s ease;
        }

        .lang-expand-btn.expanded .arrow {
            transform: rotate(180deg);
        }

        /* Minecraft Easter Egg Game */
        .minecraft-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 10000;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        .minecraft-overlay.active {
            display: flex;
        }

        .minecraft-container {
            position: relative;
            border: 4px solid #5a3d2b;
            box-shadow: 0 0 40px rgba(255, 183, 197, 0.3);
        }

        .minecraft-canvas {
            display: block;
            image-rendering: pixelated;
            cursor: crosshair;
        }
        
        /* Fullscreen styles */
        .minecraft-game:fullscreen,
        .minecraft-game:-webkit-full-screen {
            width: 100vw !important;
            height: 100vh !important;
            max-width: none !important;
            background: #000;
        }
        
        .minecraft-game:fullscreen .minecraft-canvas,
        .minecraft-game:-webkit-full-screen .minecraft-canvas {
            width: 100vw !important;
            height: 100vh !important;
        }

        .minecraft-ui {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 4px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px;
            border-radius: 4px;
        }

        .hotbar-slot {
            width: 40px;
            height: 40px;
            background: rgba(139, 139, 139, 0.5);
            border: 2px solid #373737;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.1s;
            position: relative;
            overflow: hidden;
        }
        
        .hotbar-slot canvas {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 36px !important;
            height: 36px !important;
        }

        .hotbar-slot.selected {
            border-color: #fff;
            background: rgba(200, 200, 200, 0.6);
        }

        .hotbar-slot:hover {
            background: rgba(180, 180, 180, 0.6);
        }
        
        /* Hotbar item count */
        .hotbar-slot::after {
            content: attr(data-count);
            position: absolute;
            bottom: 2px;
            right: 4px;
            font-size: 12px;
            color: #fff;
            text-shadow: 1px 1px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000;
            font-weight: bold;
            pointer-events: none;
        }
        
        .hotbar-slot[data-count=""]::after,
        .hotbar-slot[data-count="1"]::after {
            display: none;
        }
        
        /* Durability bar */
        .hotbar-slot .durability-bar {
            position: absolute;
            bottom: 0;
            left: 2px;
            right: 2px;
            height: 3px;
            background: #333;
            border-radius: 1px;
        }
        
        .hotbar-slot .durability-bar .durability-fill {
            height: 100%;
            border-radius: 1px;
            transition: width 0.2s;
        }
        
        /* Pickup notification */
        .pickup-notification {
            position: fixed;
            left: 50%;
            bottom: 120px;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            pointer-events: none;
            z-index: 100;
        }
        
        .pickup-item {
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 16px;
            border-radius: 4px;
            color: #fff;
            font-family: monospace;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
            animation: pickup-slide 2s ease-out forwards;
            border: 1px solid rgba(255, 215, 0, 0.5);
        }
        
        .pickup-item .pickup-icon {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        @keyframes pickup-slide {
            0% { opacity: 0; transform: translateY(20px); }
            15% { opacity: 1; transform: translateY(0); }
            85% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-20px); }
        }
        
        /* Debug Console */
        .debug-console {
            position: fixed;
            top: 50px;
            left: 10px;
            width: 400px;
            max-height: 300px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #4a4;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            color: #0f0;
            z-index: 200;
            display: none;
        }
        
        .debug-console.active {
            display: block;
        }
        
        .debug-console-header {
            background: #2a2a2a;
            padding: 5px 10px;
            border-bottom: 1px solid #4a4;
            display: flex;
            justify-content: space-between;
        }
        
        .debug-console-output {
            height: 200px;
            overflow-y: auto;
            padding: 5px 10px;
        }
        
        .debug-console-output div {
            margin: 2px 0;
        }
        
        .debug-console-output .error { color: #f44; }
        .debug-console-output .warn { color: #ff0; }
        .debug-console-output .info { color: #4af; }
        .debug-console-output .success { color: #4f4; }
        
        .debug-console-input {
            display: flex;
            border-top: 1px solid #4a4;
        }
        
        .debug-console-input span {
            padding: 5px;
            color: #4a4;
        }
        
        .debug-console-input input {
            flex: 1;
            background: transparent;
            border: none;
            color: #0f0;
            font-family: monospace;
            font-size: 12px;
            padding: 5px;
            outline: none;
        }
        
        /* Block tooltip */
        .block-tooltip {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, 30px);
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 215, 0, 0.6);
            padding: 8px 12px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 13px;
            color: #fff;
            pointer-events: none;
            z-index: 100;
            text-align: center;
            display: none;
        }
        
        .block-tooltip.active {
            display: block;
        }
        
        .block-tooltip .tooltip-title {
            color: #ffd700;
            font-weight: bold;
        }
        
        .block-tooltip .tooltip-desc {
            color: #aaa;
            font-size: 11px;
            margin-top: 4px;
        }

        .minecraft-instructions {
            color: #fff;
            font-family: monospace;
            font-size: 14px;
            margin-top: 15px;
            text-align: center;
            opacity: 0.8;
        }

        .minecraft-title {
            color: var(--petal-pink);
            font-family: monospace;
            font-size: 24px;
            margin-bottom: 15px;
            text-shadow: 2px 2px 0 #5a3d2b;
        }

        .minecraft-close {
            position: absolute;
            top: -40px;
            right: 0;
            background: rgba(255, 100, 100, 0.8);
            border: none;
            color: white;
            padding: 8px 16px;
            cursor: pointer;
            font-family: monospace;
            font-size: 14px;
            border-radius: 4px;
        }

        .minecraft-close:hover {
            background: rgba(255, 50, 50, 1);
        }

        /* Inventory Screen */
        .inventory-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 50;
            overflow: hidden;
        }
        
        .inventory-screen.active {
            display: flex;
        }
        
        .inventory-container {
            background: linear-gradient(135deg, #3d2817 0%, #2a1a0f 100%);
            border: 4px solid #5a3d2b;
            border-radius: 8px;
            padding: 20px;
            max-width: 500px;
            width: 90%;
            max-height: 80%;
            overflow-y: auto;
            overflow-x: hidden;
            color: #fff;
            font-family: monospace;
            touch-action: pan-y;
            -webkit-user-select: none;
            user-select: none;
            /* Prevent scroll from propagating to page */
            overscroll-behavior: contain;
        }
        
        /* Custom scrollbar for inventory */
        .inventory-container::-webkit-scrollbar {
            width: 10px;
        }
        
        .inventory-container::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
        }
        
        .inventory-container::-webkit-scrollbar-thumb {
            background: #5a3d2b;
            border-radius: 5px;
        }
        
        .inventory-container::-webkit-scrollbar-thumb:hover {
            background: #7a5d4b;
        }
        
        .inventory-container h2 {
            color: var(--petal-pink);
            text-align: center;
            margin-bottom: 15px;
            text-shadow: 2px 2px 0 #000;
        }
        
        .inventory-container h3 {
            color: #ffd700;
            font-size: 14px;
            margin: 15px 0 10px 0;
            border-bottom: 1px solid #5a3d2b;
            padding-bottom: 5px;
        }
        
        .inv-slots {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            gap: 4px;
            margin-bottom: 10px;
        }
        
        .inv-slot {
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #5a3d2b;
            aspect-ratio: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            position: relative;
            border-radius: 4px;
        }
        
        .inv-slot.selected {
            border-color: #ffd700;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }
        
        .inv-slot.empty {
            opacity: 0.5;
        }
        
        .inv-slot .count {
            position: absolute;
            bottom: 2px;
            right: 4px;
            font-size: 10px;
            color: #fff;
            text-shadow: 1px 1px 0 #000;
        }
        
        .inv-slot.has-item {
            cursor: grab;
        }
        
        .inv-slot.has-item:active {
            cursor: grabbing;
        }
        
        .inv-slot.dragging {
            opacity: 0.5;
            border-color: #888;
        }
        
        .inv-slot.drag-over {
            border-color: #4f4;
            background: rgba(80, 255, 80, 0.2);
            box-shadow: 0 0 10px rgba(80, 255, 80, 0.5);
        }
        
        .inv-slot.held {
            border-color: #ff0;
            background: rgba(255, 255, 0, 0.3);
            box-shadow: 0 0 15px rgba(255, 255, 0, 0.7);
            animation: pulse-held 0.5s ease infinite alternate;
        }
        
        @keyframes pulse-held {
            from { transform: scale(1); }
            to { transform: scale(1.05); }
        }
        
        /* Inventory tooltips */
        .inv-slot[data-tooltip] {
            position: relative;
        }
        
        .inv-slot[data-tooltip]:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 100;
            pointer-events: none;
            border: 1px solid #5a3d2b;
            margin-bottom: 5px;
        }
        
        .inv-slot[data-tooltip]:hover::before {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 5px solid transparent;
            border-top-color: rgba(0, 0, 0, 0.9);
            z-index: 100;
            pointer-events: none;
        }
        
        .crafting-section {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 15px;
        }
        
        .recipe-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .recipe {
            background: rgba(100, 80, 60, 0.5);
            border: 2px solid #5a3d2b;
            border-radius: 4px;
            padding: 8px;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 8px;
            font-size: 12px;
        }
        
        .recipe.craftable {
            border-color: #4a4;
            background: rgba(40, 80, 40, 0.5);
        }
        
        .recipe.disabled {
            opacity: 0.5;
        }
        
        .recipe-name {
            font-weight: bold;
            color: #ffd700;
            min-width: 80px;
        }
        
        .recipe-ingredients {
            color: #aaa;
        }
        
        .recipe-result {
            color: #8f8;
        }
        
        .craft-btn {
            background: #4a4;
            border: none;
            color: white;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-family: monospace;
            font-size: 11px;
            margin-left: auto;
        }
        
        .craft-btn:hover {
            background: #5b5;
        }
        
        .inv-hint {
            text-align: center;
            color: #888;
            font-size: 12px;
            margin-top: 15px;
        }

        /* Click to play overlay */
        .click-to-play {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 50;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            font-family: monospace;
            color: #fff;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }

        .click-to-play.active {
            opacity: 1;
            pointer-events: auto;
        }

        .click-to-play-text {
            font-size: 24px;
            margin-bottom: 10px;
            animation: pulse 1.5s ease-in-out infinite;
        }

        .click-to-play-hint {
            font-size: 14px;
            opacity: 0.7;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Pause Menu */
        .pause-menu {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 100;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: monospace;
        }

        .pause-menu.active {
            display: flex;
        }

        .pause-title {
            color: var(--petal-pink);
            font-size: 32px;
            margin-bottom: 30px;
            text-shadow: 2px 2px 0 #5a3d2b;
        }

        .pause-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 280px;
        }

        .pause-btn {
            padding: 12px 20px;
            font-family: monospace;
            font-size: 16px;
            border: 2px solid #555;
            background: rgba(60, 60, 60, 0.9);
            color: #fff;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }

        .pause-btn:hover:not(.disabled) {
            background: rgba(100, 100, 100, 0.9);
            border-color: var(--petal-pink);
        }

        .pause-btn.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            position: relative;
        }

        .pause-btn.disabled::after {
            content: 'âœ•';
            position: absolute;
            right: 10px;
            color: #888;
        }

        .pause-btn.resume {
            background: rgba(100, 180, 100, 0.8);
            border-color: #6a6;
        }

        .pause-btn.resume:hover {
            background: rgba(120, 200, 120, 0.9);
        }

        .pause-btn.quit {
            background: rgba(180, 80, 80, 0.8);
            border-color: #a66;
        }

        .pause-btn.quit:hover {
            background: rgba(200, 100, 100, 0.9);
        }

        .pause-btn.fullscreen {
            background: rgba(80, 120, 180, 0.8);
            border-color: #68a;
        }

        .pause-btn.fullscreen:hover {
            background: rgba(100, 140, 200, 0.9);
        }

        /* Sub-menus */
        .pause-submenu {
            display: none;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 350px;
        }

        .pause-submenu.active {
            display: flex;
        }

        .submenu-title {
            color: var(--petal-pink);
            font-size: 24px;
            margin-bottom: 20px;
        }

        .submenu-content {
            width: 100%;
            background: rgba(40, 40, 40, 0.9);
            border: 2px solid #555;
            padding: 20px;
            border-radius: 4px;
            margin-bottom: 15px;
        }

        .stat-row, .option-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #444;
            color: #ccc;
        }

        .stat-row:last-child, .option-row:last-child {
            border-bottom: none;
        }

        .stat-value {
            color: var(--petal-pink);
            font-weight: bold;
        }

        .option-slider {
            width: 120px;
            accent-color: var(--petal-pink);
        }

        .option-select {
            background: #333;
            color: #fff;
            border: 1px solid #555;
            padding: 4px 8px;
            font-family: monospace;
        }

        .option-toggle {
            width: 50px;
            height: 26px;
            background: #444;
            border-radius: 13px;
            position: relative;
            cursor: pointer;
            transition: background 0.3s;
        }

        .option-toggle.on {
            background: var(--petal-pink);
        }

        .option-toggle::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background: #fff;
            border-radius: 50%;
            top: 3px;
            left: 3px;
            transition: left 0.3s;
        }

        .option-toggle.on::after {
            left: 27px;
        }
        
        .option-slider {
            width: 120px;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(80, 80, 80, 0.9);
            border-radius: 4px;
            outline: none;
            cursor: pointer;
        }
        
        .option-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #4CAF50;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .option-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #4CAF50;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .back-btn {
            padding: 10px 30px;
            background: rgba(80, 80, 80, 0.9);
            border: 2px solid #666;
            color: #fff;
            font-family: monospace;
            cursor: pointer;
        }

        .back-btn:hover {
            background: rgba(100, 100, 100, 0.9);
        }

        .hero-image-container {
            cursor: pointer;
            transition: transform 0.3s ease;
        }

        .hero-image-container:hover {
            transform: scale(1.02);
        }

        /* Clickable Link Badge */
        .stat-link-badge {
            position: absolute;
            top: 12px;
            right: 12px;
            width: 28px;
            height: 28px;
            background: rgba(255, 183, 197, 0.15);
            border: 1px solid rgba(255, 183, 197, 0.3);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--petal-pink);
            text-decoration: none;
            font-size: 0.85rem;
            transition: all 0.3s ease;
            z-index: 5;
        }

        .stat-link-badge:hover {
            background: rgba(255, 183, 197, 0.3);
            border-color: var(--petal-pink);
            transform: translate(2px, -2px);
            box-shadow: 0 4px 12px rgba(255, 183, 197, 0.2);
        }

        .stats-card {
            position: relative;
        }

        /* Activity Section */
        .activity-section {
            margin: 60px 0;
        }

        .activity-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .activity-container.compact {
            gap: 20px;
        }

        .activity-card {
            background: linear-gradient(145deg, rgba(255, 183, 197, 0.06), rgba(26, 26, 46, 0.5));
            border: 1px solid rgba(255, 183, 197, 0.12);
            border-radius: 16px;
            padding: 20px;
            backdrop-filter: blur(10px);
            transition: all 0.4s ease;
            position: relative;
        }

        .activity-card:hover {
            transform: translateY(-4px);
            border-color: rgba(255, 183, 197, 0.25);
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.2),
                        0 0 20px rgba(255, 183, 197, 0.08);
        }

        .activity-card.full-width {
            grid-column: 1 / -1;
        }

        /* Activity Chart */
        .activity-chart-card {
            display: flex;
            flex-direction: column;
        }

        .activity-chart-wrapper {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            flex: 1;
            min-height: 220px;
        }

        #activityChart {
            max-width: 100%;
        }

        /* Activity Feed */
        .activity-feed {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .activity-feed::-webkit-scrollbar {
            width: 5px;
        }

        .activity-feed::-webkit-scrollbar-track {
            background: rgba(255, 183, 197, 0.05);
            border-radius: 3px;
        }

        .activity-feed::-webkit-scrollbar-thumb {
            background: rgba(255, 183, 197, 0.2);
            border-radius: 3px;
        }

        .activity-item {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            padding: 10px;
            background: rgba(255, 183, 197, 0.05);
            border-radius: 8px;
            border-left: 2px solid var(--petal-pink);
            transition: opacity 0.3s, transform 0.3s;
        }

        .activity-item.hidden {
            display: none;
        }

        .activity-item.show {
            animation: fadeIn 0.3s ease forwards;
        }

        .activity-item .activity-icon {
            font-size: 1rem;
            flex-shrink: 0;
        }

        .activity-item .activity-content {
            flex: 1;
        }

        .activity-item .activity-text {
            color: var(--moon-glow);
            font-size: 0.85rem;
            line-height: 1.4;
        }

        .activity-item .activity-text a {
            color: var(--petal-pink);
            text-decoration: none;
        }

        .activity-item .activity-text a:hover {
            text-decoration: underline;
        }

        .activity-item .activity-time {
            color: var(--petal-soft);
            opacity: 0.5;
            font-size: 0.75rem;
            margin-top: 3px;
        }

        /* Gilded Section */
        .gilded-section {
            margin: 60px 0;
            overflow: hidden;
        }

        .gilded-container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
        }

        .gilded-card {
            background: linear-gradient(145deg, rgba(212, 175, 55, 0.06), rgba(26, 26, 46, 0.5));
            border: 1px solid rgba(212, 175, 55, 0.15);
            border-radius: 16px;
            padding: 20px;
            backdrop-filter: blur(10px);
            transition: all 0.4s ease;
            position: relative;
            overflow: hidden;
        }

        .gilded-card:hover {
            transform: translateY(-4px);
            border-color: rgba(212, 175, 55, 0.3);
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.2),
                        0 0 20px rgba(212, 175, 55, 0.08);
        }

        .gilded-card .custom-stat-header h3 {
            color: var(--gold-accent);
        }

        .gilded-card .stat-link-badge {
            background: rgba(212, 175, 55, 0.15);
            border-color: rgba(212, 175, 55, 0.3);
            color: var(--gold-accent);
        }

        .gilded-card .stat-link-badge:hover {
            background: rgba(212, 175, 55, 0.3);
            border-color: var(--gold-accent);
        }

        /* Recent Stars Grid */
        .recent-stars-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
        }

        @media (max-width: 900px) {
            .recent-stars-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 480px) {
            .recent-stars-grid {
                grid-template-columns: 1fr;
            }
            
            .star-item {
                max-width: 100%;
            }
            
            .star-item > div {
                min-width: 0;
                overflow: hidden;
            }
        }

        .star-item {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            padding: 12px;
            background: rgba(212, 175, 55, 0.05);
            border-radius: 10px;
            transition: background 0.3s;
            overflow: hidden;
            min-width: 0;
        }

        .star-item:hover {
            background: rgba(212, 175, 55, 0.1);
        }

        .star-item a {
            color: var(--gold-accent);
            text-decoration: none;
            font-weight: 400;
            font-size: 0.9rem;
            transition: color 0.3s;
            word-break: break-word;
            overflow-wrap: break-word;
        }

        .star-item a:hover {
            color: #f1c40f;
        }

        .star-item .star-desc {
            color: var(--moon-glow);
            opacity: 0.6;
            font-size: 0.8rem;
            margin-top: 3px;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            word-break: break-word;
        }

        .star-icon {
            color: #f1c40f;
            font-size: 0.9rem;
            flex-shrink: 0;
            margin-top: 2px;
        }

        @media (max-width: 900px) {
            .github-stats-container {
                grid-template-columns: 1fr;
            }
            
            .stats-card.full-width,
            .stats-card.full-width-third {
                grid-column: auto;
            }

            .custom-stat-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 12px;
            }

            .custom-stat-item .stat-value {
                font-size: 1.4rem;
            }

            .activity-container {
                grid-template-columns: 1fr;
            }

            .activity-card.full-width {
                grid-column: auto;
            }

            .recent-stars-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .combined-stat-content {
                flex-direction: column;
            }

            .stat-divider {
                width: 100%;
                height: 1px;
                margin: 20px 0;
            }

            .stat-half {
                padding: 0;
            }
            
            .gilded-card {
                padding: 15px;
            }
            
            .star-item a {
                font-size: 0.8rem;
            }
        }

        /* Poetry Section */
        .poetry-section {
            margin: 60px 0;
            position: relative;
        }

        .poetry-container {
            position: relative;
            perspective: 1000px;
            cursor: pointer;
            margin-bottom: 40px;
            width: 100%;
        }

        .poetry-flip-inner {
            position: relative;
            width: 100%;
            transition: transform 0.8s, height 0.8s ease;
            transform-style: preserve-3d;
        }

        .poetry-container.flipped .poetry-flip-inner {
            transform: rotateY(180deg);
        }

        .poetry-flip-front,
        .poetry-flip-back {
            background: linear-gradient(145deg, rgba(255, 183, 197, 0.05), rgba(26, 26, 46, 0.8));
            border: 1px solid rgba(255, 183, 197, 0.1);
            border-radius: 20px;
            padding: 50px;
            width: 100%;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            overflow: hidden;
            min-height: 400px;
        }

        .poetry-flip-front {
            position: relative;
        }

        .poetry-flip-back {
            position: absolute;
            top: 0;
            left: 0;
            transform: rotateY(180deg);
        }

        /* Ensure text content is properly layered */
        .poetry-text {
            position: relative;
            z-index: 2;
        }

        .poetry-container::before,
        .poetry-container::after {
            content: '';
            display: none;
        }

        /* Diagonal sakura petal animation behind poem text */
        .diagonal-petal {
            position: absolute;
            font-size: 1.5rem;
            color: rgba(255, 183, 197, 0.4);
            pointer-events: none;
            animation: diagonalFloat linear infinite;
            z-index: 0;
        }

        @keyframes diagonalFloat {
            0% {
                transform: translate(0, 0) rotate(0deg);
                opacity: 0;
            }
            10% {
                opacity: 0.7;
            }
            90% {
                opacity: 0.7;
            }
            100% {
                transform: translate(-150vw, 150vh) rotate(720deg);
                opacity: 0;
            }
        }

        .poetry-flip-front::before,
        .poetry-flip-front::after,
        .poetry-flip-back::before,
        .poetry-flip-back::after {
            content: 'æ¡œ';
            font-family: 'Noto Serif JP', serif;
            font-size: 12rem;
            position: absolute;
            color: rgba(255, 183, 197, 0.03);
            pointer-events: none;
        }

        .poetry-flip-front::before,
        .poetry-flip-back::before {
            top: -40px;
            left: -20px;
        }

        .poetry-flip-front::after,
        .poetry-flip-back::after {
            bottom: -60px;
            right: -20px;
        }

        .poetry-text {
            font-size: 1.15rem;
            line-height: 2;
            text-align: center;
            color: var(--moon-glow);
            font-style: italic;
            position: relative;
            z-index: 1;
        }

        .poetry-text p {
            margin-bottom: 0.3em;
            opacity: 0;
            animation: fadeInPoem 1s ease-out forwards;
        }

        @keyframes fadeInPoem {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Haiku Section */
        .haiku-container {
            margin-top: 80px;
            margin-bottom: 40px;
            padding: 40px;
            background: linear-gradient(165deg, rgba(255, 183, 197, 0.05), rgba(26, 26, 46, 0.7));
            border: 1px solid rgba(255, 183, 197, 0.1);
            border-radius: 15px;
            position: relative;
            text-align: center;
            overflow: hidden;
        }

        .haiku-text {
            display: inline-block;
            position: relative;
        }

        .haiku-text p {
            font-size: 1.3rem;
            font-weight: 300;
            line-height: 2;
            color: var(--petal-pink);
            letter-spacing: 0.15em;
            margin-bottom: 0.2em;
            text-shadow: 0 0 30px rgba(255, 183, 197, 0.4);
            opacity: 0;
            animation: fadeInHaiku 1.2s ease-out forwards;
        }

        .haiku-text p:nth-child(1) { animation-delay: 0.5s; }
        .haiku-text p:nth-child(2) { animation-delay: 1s; }
        .haiku-text p:nth-child(3) { animation-delay: 1.5s; }

        @keyframes fadeInHaiku {
            from {
                opacity: 0;
                transform: translateY(15px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .haiku-symbol {
            display: block;
            font-family: 'Noto Serif JP', serif;
            font-size: 0.95rem;
            font-weight: 200;
            color: rgba(255, 183, 197, 0.3);
            margin-top: 20px;
            letter-spacing: 0.5em;
            opacity: 0;
            animation: fadeInHaiku 1s ease-out 2s forwards;
        }

        .haiku-container::before,
        .haiku-container::after {
            content: 'âœ¿';
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            font-size: 1.2rem;
            color: rgba(255, 183, 197, 0.2);
            opacity: 0;
            animation: fadeInHaiku 1s ease-out 2.2s forwards;
        }

        .haiku-container::before {
            left: 25%;
        }

        .haiku-container::after {
            right: 25%;
        }

        /* Aesthetic Memories Section */
        .aesthetic-memories-section {
            margin: 80px 0 60px;
        }

        .video-container {
            position: relative;
            width: 100%;
            max-width: 900px;
            margin: 0 auto;
            padding-bottom: 56.25%; /* 16:9 aspect ratio */
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 15px 50px rgba(0, 0, 0, 0.4),
                        0 0 30px rgba(255, 183, 197, 0.1);
        }

        @media (min-width: 1200px) {
            .video-container {
                max-width: 1000px;
            }
        }

        .video-container iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none;
            border-radius: 15px;
        }

        /* Footer */
        .footer {
            text-align: center;
            padding: 50px 40px;
            border-top: 1px solid rgba(255, 183, 197, 0.1);
            margin-top: 60px;
        }

        .footer p {
            font-size: 0.9rem;
            color: rgba(248, 240, 227, 0.5);
            letter-spacing: 0.15em;
        }

        .social-links {
            display: flex;
            justify-content: center;
            gap: 25px;
            margin-top: 20px;
        }

        .social-links a {
            color: var(--petal-soft);
            text-decoration: none;
            font-size: 1rem;
            transition: color 0.3s, transform 0.3s;
            opacity: 0.7;
        }

        .social-links a:hover {
            color: var(--petal-pink);
            transform: translateY(-3px);
            opacity: 1;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .content {
                padding: 30px 15px;
            }

            .section-title-jp {
                font-size: 1.6rem;
                /* Disable flickering on mobile */
                animation: none;
                filter: none;
                -webkit-filter: none;
                background-size: 100% 100%;
            }
            
            .section-title-jp::before {
                display: none;
            }

            .section-title-en {
                font-size: 0.9rem;
                letter-spacing: 0.3em;
            }

            .logo-kanji {
                font-size: 2.5rem;
            }

            .header h1 {
                font-size: 1.6rem;
                letter-spacing: 0.15em;
            }

            .poetry-container {
                padding: 30px 20px;
                margin-bottom: 30px;
            }

            .poetry-flip-front,
            .poetry-flip-back {
                padding: 30px 20px;
                min-height: 350px;
            }

            .poetry-text {
                font-size: 0.95rem;
                line-height: 1.8;
            }

            .haiku-container {
                margin-top: 60px;
                margin-bottom: 30px;
                padding: 30px 20px;
            }

            .haiku-text p {
                font-size: 1.1rem;
            }

            .haiku-container::before,
            .haiku-container::after {
                display: none;
            }

            .step {
                flex-direction: column;
                gap: 10px;
            }

            .stats-preview {
                grid-template-columns: 1fr;
            }

            .tree-silhouette {
                display: none;
            }

            .celestial {
                width: 50px;
                height: 50px;
                top: 30px;
                right: 10%;
            }

            .moon-body::before {
                width: 10px;
                height: 10px;
            }

            .moon-body::after {
                width: 14px;
                height: 14px;
            }

            .moon-crater-small {
                width: 6px;
                height: 6px;
            }

            .sun-ray {
                width: 2px;
            }

            .kris-blade {
                width: 10px;
                height: 32px;
                margin-left: -5px;
            }

            .kris-blade svg {
                shape-rendering: optimizeSpeed;
            }

            .flame-particle {
                transform: scale(0.7);
            }
        }
    </style>
</head>
<body>
    <!-- Celestial Body (Moon/Sun based on time) -->
    <div class="celestial" id="celestialBody"></div>

    <!-- Animated Clouds -->
    <div class="cloud-container">
        <div class="cloud-layer-1" id="cloudLayer1"></div>
        <div class="cloud-layer-2" id="cloudLayer2"></div>
        <div class="cloud-layer-3" id="cloudLayer3"></div>
        <div class="wisp-layer" id="wispLayer"></div>
    </div>

    <!-- Falling Petals -->
    <canvas class="petal-canvas" id="petalCanvas"></canvas>

    <!-- Tree Silhouettes -->
    <svg class="tree-silhouette" viewBox="0 0 200 500" fill="currentColor">
        <path d="M100,500 L100,300 Q80,280 60,260 Q40,240 50,200 Q30,180 40,140 Q20,120 35,80 Q25,50 50,30 Q40,10 70,5 Q90,0 110,10 Q140,5 155,30 Q175,20 170,60 Q190,80 175,110 Q195,140 175,170 Q190,200 170,230 Q185,260 160,280 Q140,300 100,300 L100,500" opacity="0.3"/>
        <ellipse cx="100" cy="100" rx="90" ry="70" opacity="0.2"/>
        <ellipse cx="60" cy="150" rx="50" ry="40" opacity="0.15"/>
        <ellipse cx="140" cy="140" rx="55" ry="45" opacity="0.15"/>
        <ellipse cx="100" cy="60" rx="60" ry="45" opacity="0.18"/>
    </svg>

    <svg class="tree-silhouette tree-left" viewBox="0 0 200 500" fill="currentColor">
        <path d="M100,500 L100,320 Q75,300 55,270 Q35,250 45,210 Q25,190 40,150 Q25,120 45,90 Q35,60 60,40 Q55,20 80,15 Q100,5 120,15 Q145,10 155,40 Q175,35 170,70 Q185,100 170,130 Q190,160 170,190 Q185,220 165,250 Q180,280 155,300 Q130,320 100,320 L100,500" opacity="0.3"/>
        <ellipse cx="100" cy="110" rx="85" ry="65" opacity="0.2"/>
        <ellipse cx="55" cy="160" rx="45" ry="35" opacity="0.15"/>
        <ellipse cx="145" cy="150" rx="50" ry="40" opacity="0.15"/>
    </svg>

    <!-- Main Content -->
    <div class="content">
        <!-- Minecraft Easter Egg Game -->
        <div class="minecraft-overlay" id="minecraftGame">
            <div class="minecraft-title">ðŸŒ¸ SakuraCraft ðŸŒ¸</div>
            <div class="minecraft-container">
                <button class="minecraft-close" id="closeMinecraft">âœ• Close</button>
                <canvas id="gameCanvas" class="minecraft-canvas" width="800" height="500"></canvas>
                
                <!-- Click to Play Overlay (required for pointer lock) -->
                <div class="click-to-play active" id="clickToPlay">
                    <div class="click-to-play-text">ðŸŽ® Click to Play</div>
                    <div class="click-to-play-hint">Mouse will be captured â€¢ Press ESC to pause</div>
                </div>
                
                <!-- Pause Menu -->
                <div class="pause-menu" id="pauseMenu">
                    <!-- Main Menu -->
                    <div class="pause-submenu active" id="menuMain">
                        <div class="pause-title">â¸ Paused</div>
                        <div class="pause-buttons">
                            <button class="pause-btn resume" id="btnResume">Resume</button>
                            <button class="pause-btn fullscreen" id="btnFullscreen">Fullscreen</button>
                            <button class="pause-btn disabled" id="btnAccount">Sign In</button>
                            <button class="pause-btn" id="btnStats">Stats</button>
                            <button class="pause-btn" id="btnOptions">Options</button>
                            <button class="pause-btn quit" id="btnQuit">Quit Game</button>
                        </div>
                    </div>
                    
                    <!-- Stats Menu -->
                    <div class="pause-submenu" id="menuStats">
                        <div class="submenu-title">ðŸ“Š Statistics</div>
                        <div class="submenu-content">
                            <div class="stat-row">
                                <span>Blocks Placed</span>
                                <span class="stat-value" id="statPlaced">0</span>
                            </div>
                            <div class="stat-row">
                                <span>Blocks Broken</span>
                                <span class="stat-value" id="statBroken">0</span>
                            </div>
                            <div class="stat-row">
                                <span>Distance Walked</span>
                                <span class="stat-value" id="statDistance">0m</span>
                            </div>
                            <div class="stat-row">
                                <span>Jumps</span>
                                <span class="stat-value" id="statJumps">0</span>
                            </div>
                            <div class="stat-row">
                                <span>Play Time</span>
                                <span class="stat-value" id="statTime">0:00</span>
                            </div>
                        </div>
                        <button class="back-btn" id="statsBack">â† Back</button>
                    </div>
                    
                    <!-- Options Menu -->
                    <div class="pause-submenu" id="menuOptions">
                        <div class="submenu-title">âš™ï¸ Options</div>
                        <div class="submenu-content">
                            <div class="option-row">
                                <span>Brightness</span>
                                <input type="range" class="option-slider" id="optBrightness" min="50" max="150" value="100">
                            </div>
                            <div class="option-row">
                                <span>Color Filter</span>
                                <select class="option-select" id="optFilter">
                                    <option value="none">Normal</option>
                                    <option value="sepia">Sepia</option>
                                    <option value="grayscale">Black & White</option>
                                    <option value="trippy">Trippy Hyperbolic</option>
                                </select>
                            </div>
                            <div class="option-row">
                                <span>Render Distance</span>
                                <select class="option-select" id="optRenderDist">
                                    <option value="12">Near (Fast)</option>
                                    <option value="18">Medium</option>
                                    <option value="25" selected>Far</option>
                                    <option value="35">Ultra</option>
                                </select>
                            </div>
                            <div class="option-row">
                                <span>Shadows</span>
                                <div class="option-toggle on" id="optShadows" data-on="true"></div>
                            </div>
                            <div class="option-row">
                                <span>Enhanced Lighting</span>
                                <div class="option-toggle on" id="optLighting" data-on="true"></div>
                            </div>
                            <div class="option-row">
                                <span>Anti-Aliasing</span>
                                <div class="option-toggle" id="optAA" data-on="false"></div>
                            </div>
                            <div class="option-row">
                                <span>Show FPS</span>
                                <div class="option-toggle on" id="optShowFps" data-on="true"></div>
                            </div>
                            <div class="option-row">
                                <span>Target FPS: <span id="targetFpsValue">60</span></span>
                                <input type="range" min="15" max="240" value="60" class="option-slider" id="optTargetFps">
                            </div>
                        </div>
                        <button class="back-btn" id="optionsBack">â† Back</button>
                    </div>
                </div>
                
                <!-- Inventory Screen -->
                <div class="inventory-screen" id="inventoryScreen">
                    <!-- Content populated by JavaScript -->
                </div>
                
                <div class="minecraft-ui" id="gameUI">
                    <div class="hotbar-slot selected" data-block="grass"></div>
                    <div class="hotbar-slot" data-block="dirt"></div>
                    <div class="hotbar-slot" data-block="stone"></div>
                    <div class="hotbar-slot" data-block="wood"></div>
                    <div class="hotbar-slot" data-block="brick"></div>
                    <div class="hotbar-slot" data-item="water_bucket"></div>
                    <div class="hotbar-slot" data-item="lava_bucket"></div>
                    <div class="hotbar-slot" data-item="ak47"></div>
                    <div class="hotbar-slot" data-empty="true"></div>
                </div>
                <div class="pickup-notification" id="pickupNotification"></div>
                <!-- Survival HUD -->
                <div id="survivalHUD" style="position:absolute;top:10px;left:10px;color:#fff;font-family:monospace;font-size:14px;text-shadow:1px 1px 2px #000;pointer-events:none;">
                    <div id="scoreDisplay">Score: 0</div>
                    <div id="waveDisplay">Wave: 1</div>
                    <div id="objectiveDisplay"></div>
                </div>
                <!-- Debug Console -->
                <div class="debug-console" id="debugConsole">
                    <div class="debug-console-header">
                        <span>Debug Console (` to toggle)</span>
                        <span id="debugFps">0 FPS</span>
                    </div>
                    <div class="debug-console-output" id="debugOutput"></div>
                    <div class="debug-console-input">
                        <span>&gt;</span>
                        <input type="text" id="debugInput" placeholder="Type command...">
                    </div>
                </div>
                <!-- Block Tooltip -->
                <div class="block-tooltip" id="blockTooltip">
                    <div class="tooltip-title"></div>
                    <div class="tooltip-desc"></div>
                </div>
            </div>
            <div class="minecraft-instructions">
                WASD move | SPACE jump/swim | SHIFT swim down | Q drop | R ritual | SCROLL hotbar | LEFT break | RIGHT use/place | E inventory | ` debug
            </div>
        </div>

        <!-- Hero Section with Image -->
        <div class="hero-image-section">
            <div class="hero-image-container">
                <img src="data:image/jpeg;base64,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" alt="Hero Background" class="hero-bg-img" />
                <div class="hero-kanji-overlay">æ¡œ</div>
            </div>
        </div>

        <!-- Header -->
        <header class="header">
            <h1>Code Portfolio</h1>
            <p class="subtitle">Where code blooms like cherry blossoms</p>
            <div class="divider"></div>
        </header>

        <!-- Portfolio Section -->
        <section class="portfolio-section">
            <h2 class="section-title">
                <span class="section-title-jp" data-text="ä½œå“">ä½œå“</span>
                <span class="section-title-en">Works</span>
            </h2>
            <div class="portfolio-grid">
                <a href="https://github.com/geket" target="_blank" rel="noopener noreferrer" class="project-card-link">
                    <div class="project-card">
                        <h3>ðŸŒ¸ Your Repositories</h3>
                        <p>Your GitHub repos will appear here automatically once deployed to GitHub Pages.</p>
                        <div class="project-tags">
                            <span class="tag">Deploy to activate</span>
                        </div>
                    </div>
                </a>
                <a href="https://github.com/geket" target="_blank" rel="noopener noreferrer" class="project-card-link">
                    <div class="project-card">
                        <h3>ðŸŒ™ Live Data</h3>
                        <p>Stars, forks, and languages will be pulled directly from your GitHub profile.</p>
                        <div class="project-tags">
                            <span class="tag">Auto-updating</span>
                        </div>
                    </div>
                </a>
                <a href="https://github.com/geket" target="_blank" rel="noopener noreferrer" class="project-card-link">
                    <div class="project-card">
                        <h3>âœ¨ Click to Visit</h3>
                        <p>Each card will link directly to its repository on GitHub.</p>
                        <div class="project-tags">
                            <span class="tag">github.com/geket</span>
                        </div>
                    </div>
                </a>
            </div>
        </section>

        <!-- GitHub Stats Section -->
        <section class="stats-section">
            <h2 class="section-title">
                <span class="section-title-jp" data-text="çµ±è¨ˆ">çµ±è¨ˆ</span>
                <span class="section-title-en">Statistics</span>
            </h2>
            <div class="github-stats-container compact">
                <div class="stats-card custom-stat combined-stat-card">
                    <a href="https://github.com/geket" target="_blank" rel="noopener noreferrer" class="stat-link-badge">â†—</a>
                    <div class="combined-stat-content">
                        <div class="stat-half">
                            <div class="custom-stat-header">
                                <span class="stat-icon">ðŸ“Š</span>
                                <h3>GitHub Stats</h3>
                            </div>
                            <div class="stats-cross-grid">
                                <div class="stats-cross-row top-row">
                                    <div class="cross-stat-item">
                                        <span class="stat-label-top">REPOS</span>
                                        <span class="stat-value vibrate" id="stat-repos">12</span>
                                    </div>
                                    <div class="cross-stat-item">
                                        <span class="stat-label-top">FOLLOWERS</span>
                                        <span class="stat-value vibrate" id="stat-followers">14</span>
                                    </div>
                                </div>
                                <div class="cross-divider-horizontal"></div>
                                <div class="stats-cross-row bottom-row">
                                    <div class="cross-stat-item">
                                        <span class="stat-value vibrate" id="stat-following">32</span>
                                        <span class="stat-label-bottom">FOLLOWING</span>
                                    </div>
                                    <div class="cross-stat-item">
                                        <span class="stat-value vibrate" id="stat-stars">6</span>
                                        <span class="stat-label-bottom">TOTAL STARS</span>
                                    </div>
                                </div>
                                <div class="cross-divider-vertical"></div>
                            </div>
                        </div>
                        <div class="stat-divider"></div>
                        <div class="stat-half">
                            <div class="custom-stat-header">
                                <span class="stat-icon">ðŸ’»</span>
                                <h3>Top Languages</h3>
                            </div>
                            <div class="language-bars" id="language-bars">
                                <div class="lang-loading">Loading languages...</div>
                            </div>
                            <button class="lang-expand-btn" id="langExpandBtn" style="display: none;">
                                <span>Show more</span>
                                <span class="arrow">â–¼</span>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Activity Section -->
        <section class="activity-section">
            <h2 class="section-title">
                <span class="section-title-jp" data-text="æ´»å‹•">æ´»å‹•</span>
                <span class="section-title-en">Activity</span>
            </h2>
            <div class="activity-container compact">
                <div class="activity-card activity-chart-card">
                    <div class="custom-stat-header">
                        <span class="stat-icon">ðŸ“ˆ</span>
                        <h3>Activity Overview</h3>
                    </div>
                    <div class="activity-chart-wrapper">
                        <canvas id="activityChart" width="340" height="340"></canvas>
                    </div>
                </div>
                <div class="activity-card recent-activity-card">
                    <a href="https://github.com/geket" target="_blank" rel="noopener noreferrer" class="stat-link-badge">â†—</a>
                    <div class="custom-stat-header">
                        <span class="stat-icon">ðŸ•</span>
                        <h3>Recent Activity</h3>
                    </div>
                    <div class="activity-feed" id="activity-feed">
                        <div class="lang-loading">Loading activity...</div>
                    </div>
                    <button class="expand-activity-btn" id="expandActivityBtn" style="display: none;">
                        <span>Show More</span>
                        <span class="expand-icon">â–¼</span>
                    </button>
                </div>
                <div class="activity-card full-width snake-card">
                    <div class="snake-wrapper">
                        <img src="https://raw.githubusercontent.com/geket/geket/output/github-contribution-grid-snake-dark.svg" alt="GitHub Contribution Snake" onerror="this.parentElement.innerHTML='<div class=\'snake-setup\'><p>ðŸ Snake animation needs setup!</p><p class=\'small\'>See instructions below</p></div>'" />
                    </div>
                </div>
            </div>
        </section>

        <!-- Gilded Section (Recent Stars) -->
        <section class="gilded-section">
            <h2 class="section-title">
                <span class="section-title-jp" data-text="é‡‘ç®”">é‡‘ç®”</span>
                <span class="section-title-en">Gilded</span>
            </h2>
            <div class="gilded-container">
                <div class="gilded-card">
                    <a href="https://github.com/geket?tab=stars" target="_blank" rel="noopener noreferrer" class="stat-link-badge">â†—</a>
                    <div class="custom-stat-header">
                        <span class="stat-icon">â­</span>
                        <h3>Recent Stars</h3>
                    </div>
                    <div class="recent-stars-grid" id="recent-stars">
                        <div class="lang-loading">Loading starred repos...</div>
                    </div>
                    <button class="expand-stars-btn" id="expandStarsBtn" style="display: none;">
                        <span class="expand-text">Show More</span>
                        <span class="expand-icon">â–¼</span>
                    </button>
                </div>
            </div>
        </section>

        <!-- Poetry Section -->
        <section class="poetry-section">
            <div class="poetry-container" onclick="this.classList.toggle('flipped')">
                <div class="poetry-flip-inner">
                    <!-- Front side - original poem -->
                    <div class="poetry-flip-front">
                        <div class="poetry-text">
                            <p>Embracing the goddess energy within yourselves</p>
                            <p>Will bring all of you to a new understanding and valuing of life</p>
                            <p>A vision that inspires you to live and love on planet earth</p>
                            <p>Like a priceless jewel</p>
                            <p>Buried in dark layers of soil and stone</p>
                            <p>Earth radiates her brilliant beauty</p>
                            <p>Into the caverns of space and time</p>
                            <p>Perhaps you are aware of those who watch over your home</p>
                            <p>And experience it as a place to visit and play with reality</p>
                            <p>You are becoming aware of yourself as a gamemaster</p>
                            <p>Imagine Earth restored to her regal beauty</p>
                            <p>Stately trees seem to brush the deep blue sky</p>
                            <p>Clouds billow to form majestic peaks</p>
                            <p>The songs of birds fill the air</p>
                            <p>Creating symphony upon symphony</p>
                            <p>The goddess is calling for an honoring of what she allows to be created</p>
                            <p>Through the core-mystery of the blood</p>
                            <p>Those who own her planet are learning about love</p>
                        </div>
                    </div>
                    
                    <!-- Back side - new poem -->
                    <div class="poetry-flip-back">
                        <div class="poetry-text">
                            <p>And the life that makes us what we are</p>
                            <p>Is the life that burns in every star</p>
                            <p>Will it be, that our legacy</p>
                            <p>Is just a dead machine of a senseless world</p>
                            <p>And we must remember who we are (who we are)</p>
                            <p>If the earth's to breathe and smooth the scar</p>
                            <p>What can you, expect to do?</p>
                            <p>When the life that feeds is felled or furled</p>
                            <p>This is our one chance to restore the equilibrium</p>
                            <p>This is our one chance as we move</p>
                            <p>To the millenium</p>
                            <p><br></p>
                            <p>Remember</p>
                            <p><br></p>
                            <p>In the night sky I see your true name</p>
                            <p>We are stardust, you would say</p>
                            <p>And on the wind and in the flame</p>
                            <p>Is the dust that claims us</p>
                            <p>In the end</p>
                            <p><br></p>
                            <p>In the dream I see where you are now</p>
                            <p>Living in the possibility somehow</p>
                            <p>And all there is is that we dared</p>
                            <p>To uphold the vision that we shared</p>
                            <p><br></p>
                            <p>And the life that makes us what we are</p>
                            <p>Is the life that burns in every star</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Haiku Section (Separate) -->
        <section class="poetry-section">
            <div class="haiku-container">
                <div class="haiku-text">
                    <p>Petals drift and fall</p>
                    <p>Earth dreams beneath the moonlight</p>
                    <p>Love blooms in silence</p>
                </div>
                <span class="haiku-symbol">ä¿³å¥</span>
            </div>
        </section>

        <!-- Aesthetic Memories Section -->
        <section class="aesthetic-memories-section">
            <h2 class="section-title">
                <span class="section-title-jp" data-text="ç¾Žçš„ãªæ€ã„å‡º">ç¾Žçš„ãªæ€ã„å‡º</span>
                <span class="section-title-en">Aesthetic Memories</span>
            </h2>
            <div class="video-container">
                <iframe 
                    src="https://www.youtube.com/embed/10TOhu3uhUU" 
                    title="Aesthetic Memories"
                    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" 
                    allowfullscreen>
                </iframe>
            </div>
        </section>

        <!-- Footer -->
        <footer class="footer">
            <p>Crafted with æ¡œ spirit</p>
            <div class="social-links">
                <a href="https://github.com/geket" target="_blank" rel="noopener noreferrer">GitHub</a>
                <a href="#">LinkedIn</a>
                <a href="#">Twitter</a>
            </div>
        </footer>
    </div>

    <script>
        // ========== CLOUD ANIMATION ==========
        function createCloud(layer, config) {
            const cloud = document.createElement('div');
            cloud.className = 'cloud';
            
            const width = config.minWidth + Math.random() * (config.maxWidth - config.minWidth);
            const height = width * (0.3 + Math.random() * 0.4);
            const top = config.minTop + Math.random() * (config.maxTop - config.minTop);
            const duration = config.minDuration + Math.random() * (config.maxDuration - config.minDuration);
            const delay = Math.random() * config.maxDelay;
            
            cloud.style.width = width + 'px';
            cloud.style.height = height + 'px';
            cloud.style.top = top + '%';
            cloud.style.animationDuration = duration + 's';
            cloud.style.animationDelay = delay + 's';
            
            layer.appendChild(cloud);
            
            // Remove and recreate after animation
            setTimeout(() => {
                cloud.remove();
                createCloud(layer, config);
            }, (duration + delay) * 1000);
        }

        function createWisp(layer) {
            const wisp = document.createElement('div');
            wisp.className = 'cloud-wisp';
            
            const width = 100 + Math.random() * 300;
            const top = 5 + Math.random() * 40;
            const duration = 40 + Math.random() * 60;
            const delay = Math.random() * 30;
            
            wisp.style.width = width + 'px';
            wisp.style.top = top + '%';
            wisp.style.animationDuration = duration + 's';
            wisp.style.animationDelay = delay + 's';
            
            layer.appendChild(wisp);
            
            setTimeout(() => {
                wisp.remove();
                createWisp(layer);
            }, (duration + delay) * 1000);
        }

        function initClouds() {
            const layer1 = document.getElementById('cloudLayer1');
            const layer2 = document.getElementById('cloudLayer2');
            const layer3 = document.getElementById('cloudLayer3');
            const wispLayer = document.getElementById('wispLayer');
            
            // Layer 1: Large, slow clouds (background)
            const config1 = {
                minWidth: 300, maxWidth: 600,
                minTop: 5, maxTop: 30,
                minDuration: 80, maxDuration: 120,
                maxDelay: 20
            };
            
            // Layer 2: Medium clouds
            const config2 = {
                minWidth: 200, maxWidth: 400,
                minTop: 10, maxTop: 40,
                minDuration: 60, maxDuration: 90,
                maxDelay: 15
            };
            
            // Layer 3: Smaller, faster clouds (foreground)
            const config3 = {
                minWidth: 100, maxWidth: 250,
                minTop: 15, maxTop: 50,
                minDuration: 45, maxDuration: 70,
                maxDelay: 10
            };
            
            // Create initial clouds
            for (let i = 0; i < 3; i++) createCloud(layer1, config1);
            for (let i = 0; i < 4; i++) createCloud(layer2, config2);
            for (let i = 0; i < 5; i++) createCloud(layer3, config3);
            
            // Create wisps
            for (let i = 0; i < 8; i++) createWisp(wispLayer);
        }

        // ========== CANVAS SAKURA PETAL PHYSICS ==========
        const petalCanvas = document.getElementById('petalCanvas');
        const ctx = petalCanvas.getContext('2d');
        
        // High-DPI support
        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            petalCanvas.width = window.innerWidth * dpr;
            petalCanvas.height = window.innerHeight * dpr;
            petalCanvas.style.width = window.innerWidth + 'px';
            petalCanvas.style.height = window.innerHeight + 'px';
            ctx.scale(dpr, dpr);
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Mouse tracking
        const mouse = { x: -1000, y: -1000 };
        document.addEventListener('mousemove', (e) => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        });
        document.addEventListener('mouseleave', () => {
            mouse.x = -1000;
            mouse.y = -1000;
        });
        // Touch support
        document.addEventListener('touchmove', (e) => {
            if (e.touches.length > 0) {
                mouse.x = e.touches[0].clientX;
                mouse.y = e.touches[0].clientY;
            }
        });
        document.addEventListener('touchend', () => {
            mouse.x = -1000;
            mouse.y = -1000;
        });
        
        // Petal class with physics
        class Petal {
            constructor(x, y) {
                this.x = x ?? Math.random() * window.innerWidth;
                this.y = y ?? -20;
                this.size = 8 + Math.random() * 12;
                
                // Base velocity (what it returns to)
                this.baseVx = (Math.random() - 0.5) * 0.3;
                this.baseVy = 0.3 + Math.random() * 0.4; // Slower fall
                
                // Current velocity
                this.vx = this.baseVx;
                this.vy = this.baseVy;
                
                // Rotation (3D simulation)
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.04;
                this.baseRotationSpeed = this.rotationSpeed;
                this.tilt = Math.random() * Math.PI * 2;
                this.tiltSpeed = (Math.random() - 0.5) * 0.02;
                
                // Wobble (sine wave horizontal movement)
                this.wobblePhase = Math.random() * Math.PI * 2;
                this.wobbleSpeed = 0.015 + Math.random() * 0.015;
                this.wobbleAmp = 0.2 + Math.random() * 0.3;
                
                // Color variation
                const hue = 340 + Math.random() * 20; // Pink range
                const sat = 70 + Math.random() * 30;
                const light = 75 + Math.random() * 15;
                this.color = `hsla(${hue}, ${sat}%, ${light}%, 0.85)`;
                this.colorInner = `hsla(${hue}, ${sat - 10}%, ${light + 10}%, 0.9)`;
                
                // Opacity for fade in/out
                this.opacity = 0;
                this.fadeIn = true;
            }
            
            update() {
                // Gentle gravity
                this.vy += 0.001;
                this.vy = Math.min(this.vy, 1.2); // Lower terminal velocity
                
                // Wobble
                this.wobblePhase += this.wobbleSpeed;
                this.vx += Math.sin(this.wobblePhase) * this.wobbleAmp * 0.01;
                
                // Gradually return to base velocities (creates the "temporary nudge" effect)
                this.vx += (this.baseVx - this.vx) * 0.02;
                this.vy += (this.baseVy - this.vy) * 0.015;
                this.rotationSpeed += (this.baseRotationSpeed - this.rotationSpeed) * 0.03;
                
                // Mouse interaction - gentle nudge
                const dx = this.x - mouse.x;
                const dy = this.y - mouse.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const interactRadius = 80;
                
                if (dist < interactRadius && dist > 0) {
                    const force = (interactRadius - dist) / interactRadius;
                    const angle = Math.atan2(dy, dx);
                    // Very gentle push - just a nudge
                    this.vx += Math.cos(angle) * force * 0.15;
                    this.vy += Math.sin(angle) * force * 0.1;
                    this.rotationSpeed += force * 0.01;
                }
                
                // Apply velocity
                this.x += this.vx;
                this.y += this.vy;
                
                // Rotation
                this.rotation += this.rotationSpeed;
                this.tilt += this.tiltSpeed;
                
                // Fade in
                if (this.fadeIn) {
                    this.opacity += 0.03;
                    if (this.opacity >= 1) {
                        this.opacity = 1;
                        this.fadeIn = false;
                    }
                }
                
                // Fade out near bottom
                if (this.y > window.innerHeight - 100) {
                    this.opacity -= 0.02;
                }
                
                // Wrap horizontally
                if (this.x < -50) this.x = window.innerWidth + 50;
                if (this.x > window.innerWidth + 50) this.x = -50;
                
                return this.y < window.innerHeight + 50 && this.opacity > 0;
            }
            
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                // 3D tilt effect - scale based on tilt
                const scaleX = 0.5 + Math.abs(Math.cos(this.tilt)) * 0.5;
                const scaleY = 0.5 + Math.abs(Math.sin(this.tilt * 0.7)) * 0.5;
                ctx.scale(scaleX, scaleY);
                
                ctx.globalAlpha = this.opacity;
                
                // Draw petal shape (5-petal sakura)
                const s = this.size;
                
                // Main petal body
                ctx.beginPath();
                ctx.moveTo(0, -s * 0.3);
                ctx.bezierCurveTo(s * 0.5, -s * 0.5, s * 0.6, s * 0.2, 0, s * 0.5);
                ctx.bezierCurveTo(-s * 0.6, s * 0.2, -s * 0.5, -s * 0.5, 0, -s * 0.3);
                
                // Gradient fill
                const gradient = ctx.createRadialGradient(
                    -s * 0.2, -s * 0.2, 0,
                    0, 0, s * 0.7
                );
                gradient.addColorStop(0, this.colorInner);
                gradient.addColorStop(0.5, this.color);
                gradient.addColorStop(1, 'rgba(233, 145, 160, 0.6)');
                
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // Subtle highlight
                ctx.beginPath();
                ctx.ellipse(-s * 0.15, -s * 0.1, s * 0.15, s * 0.1, -0.5, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.fill();
                
                // Second petal (rotated)
                ctx.rotate(Math.PI * 0.5 + Math.sin(this.tilt) * 0.3);
                ctx.globalAlpha = this.opacity * 0.6;
                
                ctx.beginPath();
                ctx.moveTo(0, -s * 0.25);
                ctx.bezierCurveTo(s * 0.4, -s * 0.4, s * 0.5, s * 0.15, 0, s * 0.4);
                ctx.bezierCurveTo(-s * 0.5, s * 0.15, -s * 0.4, -s * 0.4, 0, -s * 0.25);
                ctx.fillStyle = this.color;
                ctx.fill();
                
                ctx.restore();
            }
        }
        
        // Petal management
        const petals = [];
        const maxPetals = 80;
        
        function spawnPetal(x, y) {
            if (petals.length < maxPetals) {
                petals.push(new Petal(x, y));
            }
        }
        
        // Initial burst
        for (let i = 0; i < 50; i++) {
            const petal = new Petal();
            petal.y = Math.random() * window.innerHeight;
            petal.opacity = 0.5 + Math.random() * 0.5;
            petal.fadeIn = false;
            petals.push(petal);
        }
        
        // Continuous spawn
        let spawnTimer = 0;
        let gustTimer = 0;
        
        function animate() {
            ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
            
            // Spawn new petals
            spawnTimer++;
            if (spawnTimer > 15) { // Every ~250ms at 60fps
                spawnPetal();
                spawnTimer = 0;
            }
            
            // Occasional gust
            gustTimer++;
            if (gustTimer > 360) { // Every ~6 seconds
                const gustSize = 8 + Math.floor(Math.random() * 8);
                for (let i = 0; i < gustSize; i++) {
                    setTimeout(() => spawnPetal(), i * 50);
                }
                gustTimer = 0;
            }
            
            // Update and draw petals
            for (let i = petals.length - 1; i >= 0; i--) {
                if (!petals[i].update()) {
                    petals.splice(i, 1);
                } else {
                    petals[i].draw(ctx);
                }
            }
            
            requestAnimationFrame(animate);
        }
        
        animate();

        // ========== DIAGONAL SAKURA PETALS ==========
        function createDiagonalPetals() {
            const poetryContainers = document.querySelectorAll('.poetry-flip-front, .poetry-flip-back');
            
            poetryContainers.forEach(container => {
                // Create multiple diagonal petals
                for (let i = 0; i < 15; i++) {
                    const petal = document.createElement('div');
                    petal.className = 'diagonal-petal';
                    petal.textContent = 'ðŸŒ¸'; // Use cherry blossom emoji instead of kanji
                    
                    // Random starting position (top-right area)
                    const startX = 80 + Math.random() * 40; // 80-120% from left
                    const startY = -20 + Math.random() * 40; // -20% to 20% from top
                    
                    petal.style.left = `${startX}%`;
                    petal.style.top = `${startY}%`;
                    
                    // Random animation duration for variety
                    const duration = 15 + Math.random() * 10; // 15-25 seconds
                    petal.style.animationDuration = `${duration}s`;
                    
                    // Stagger the animation start
                    petal.style.animationDelay = `${Math.random() * 10}s`;
                    
                    // Random size variation
                    const scale = 0.7 + Math.random() * 0.6; // 0.7-1.3
                    petal.style.fontSize = `${scale * 1.5}rem`;
                    
                    container.appendChild(petal);
                }
            });
        }

        // ========== POETRY FLIP CARD HEIGHT MANAGEMENT ==========
        function initPoetryFlipCard() {
            const container = document.querySelector('.poetry-container');
            const flipInner = document.querySelector('.poetry-flip-inner');
            const frontSide = document.querySelector('.poetry-flip-front');
            const backSide = document.querySelector('.poetry-flip-back');
            
            if (!container || !flipInner || !frontSide || !backSide) return;
            
            // Function to set container height based on active side
            function updateContainerHeight() {
                const isFlipped = container.classList.contains('flipped');
                const activeSide = isFlipped ? backSide : frontSide;
                const height = activeSide.offsetHeight;
                
                // Set height with transition
                flipInner.style.height = height + 'px';
            }
            
            // Set initial height
            setTimeout(() => {
                updateContainerHeight();
            }, 100);
            
            // Update height on flip
            container.addEventListener('click', () => {
                setTimeout(() => {
                    updateContainerHeight();
                }, 50);
            });
            
            // Update on window resize
            window.addEventListener('resize', updateContainerHeight);
        }

        // ========== POETRY ANIMATION ==========
        function animatePoetry() {
            const lines = document.querySelectorAll('.poetry-text p');
            lines.forEach((line, index) => {
                line.style.animationDelay = `${index * 0.15}s`;
            });
        }

        // ========== PARALLAX EFFECT ==========
        // ========== CELESTIAL BODY (SUN/MOON) ==========
        function initCelestialBody() {
            const celestial = document.getElementById('celestialBody');
            const hour = new Date().getHours();
            
            // Day: 6 AM to 6 PM, Night: 6 PM to 6 AM
            const isDay = true; // TEMP: force sun for demo
            
            if (isDay) {
                // Create sun structure with enhanced gooey flame filter
                celestial.innerHTML = `
                    <svg width="0" height="0" style="position:absolute">
                        <defs>
                            <!-- Enhanced gooey metaball effect - more blobby merging -->
                            <filter id="flameGooey" x="-50%" y="-50%" width="200%" height="200%">
                                <feGaussianBlur in="SourceGraphic" stdDeviation="3.5" result="blur"/>
                                <feColorMatrix in="blur" type="matrix" 
                                    values="1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 28 -12" result="gooey"/>
                                <feComposite in="SourceGraphic" in2="gooey" operator="atop"/>
                            </filter>
                            <!-- Blade wobble heat shimmer -->
                            <filter id="bladeWobble" x="-20%" y="-20%" width="140%" height="140%">
                                <feTurbulence type="turbulence" baseFrequency="0.04 0.12" numOctaves="2" result="wobble" seed="3">
                                    <animate attributeName="baseFrequency" values="0.04 0.12;0.06 0.16;0.04 0.12" dur="2s" repeatCount="indefinite"/>
                                </feTurbulence>
                                <feDisplacementMap in="SourceGraphic" in2="wobble" scale="2" xChannelSelector="R" yChannelSelector="G"/>
                            </filter>
                        </defs>
                    </svg>
                    <div class="sun-container">
                        <div class="flame-particles" id="flameParticles"></div>
                        <div class="sun-corona"></div>
                        <div class="sun-rays" id="sunRays"></div>
                        <div class="sun-body"></div>
                    </div>
                `;
                
                // Create kris blade rays - smaller with wobble
                const raysContainer = document.getElementById('sunRays');
                const bladeCount = 12;
                
                for (let i = 0; i < bladeCount; i++) {
                    const blade = document.createElement('div');
                    blade.className = 'kris-blade';
                    blade.style.setProperty('--ray-rotation', `${i * (360 / bladeCount)}deg`);
                    blade.style.setProperty('--ray-translate', '-40px');
                    
                    // Kris blade with 7 wave joints
                    const waves = 7;
                    const bladeHeight = 35;
                    const bladeWidth = 10;
                    const amplitude = 1.5;
                    
                    // Build serpentine blade path
                    let pathD = `M ${bladeWidth/2} ${bladeHeight}`;
                    
                    // Left edge with 7 waves
                    const segments = 28;
                    for (let s = 0; s <= segments; s++) {
                        const progress = s / segments;
                        const y = bladeHeight * (1 - progress);
                        const waveOffset = Math.sin(progress * waves * Math.PI) * amplitude * (1 - progress * 0.4);
                        const x = bladeWidth/2 - 1.5 - waveOffset;
                        pathD += ` L ${x.toFixed(2)} ${y.toFixed(2)}`;
                    }
                    
                    // Tip
                    pathD += ` L ${bladeWidth/2} -3`;
                    
                    // Right edge (mirrored)
                    for (let s = segments; s >= 0; s--) {
                        const progress = s / segments;
                        const y = bladeHeight * (1 - progress);
                        const waveOffset = Math.sin(progress * waves * Math.PI) * amplitude * (1 - progress * 0.4);
                        const x = bladeWidth/2 + 1.5 + waveOffset;
                        pathD += ` L ${x.toFixed(2)} ${y.toFixed(2)}`;
                    }
                    
                    pathD += ' Z';
                    
                    // SVG with wobble filter
                    blade.innerHTML = `
                        <svg viewBox="0 0 ${bladeWidth} ${bladeHeight + 6}" preserveAspectRatio="none" style="filter: url(#bladeWobble);">
                            <defs>
                                <linearGradient id="bg${i}" x1="0%" y1="100%" x2="0%" y2="0%">
                                    <stop offset="0%" stop-color="#ffd700"/>
                                    <stop offset="40%" stop-color="#ffb000"/>
                                    <stop offset="70%" stop-color="#ff8c00"/>
                                    <stop offset="100%" stop-color="#ff4500" stop-opacity="0.3"/>
                                </linearGradient>
                            </defs>
                            <path d="${pathD}" fill="url(#bg${i})" transform="translate(0, 3)"/>
                        </svg>
                    `;
                    
                    raysContainer.appendChild(blade);
                }
                
                // Create flame particles with enhanced gooey effect
                const flameContainer = document.getElementById('flameParticles');
                const particleCount = 45;
                let particleIndex = 0;
                
                function createFlameParticle(forceAngle = null, forceType = null) {
                    const particle = document.createElement('div');
                    
                    // Random type: flame, ember, spark, wisp, scatter, or mingle
                    const rand = forceType !== null ? -1 : Math.random();
                    const type = forceType || (
                        rand < 0.25 ? 'flame' :
                        rand < 0.40 ? 'ember' :
                        rand < 0.52 ? 'spark' :
                        rand < 0.65 ? 'wisp' :
                        rand < 0.82 ? 'scatter' : 'mingle'
                    );
                    
                    if (type === 'flame') {
                        // Main flames - larger teardrop shapes
                        particle.className = 'flame-particle';
                        particle.style.width = (8 + Math.random() * 10) + 'px';
                        particle.style.height = (12 + Math.random() * 14) + 'px';
                    } else if (type === 'ember') {
                        // Embers - medium glowing orbs
                        particle.className = 'flame-particle ember';
                        const size = 5 + Math.random() * 7;
                        particle.style.width = size + 'px';
                        particle.style.height = size + 'px';
                    } else if (type === 'spark') {
                        // Sparks - bright tiny dots
                        particle.className = 'flame-particle spark';
                        const size = 2 + Math.random() * 3;
                        particle.style.width = size + 'px';
                        particle.style.height = size + 'px';
                    } else if (type === 'wisp') {
                        // Wisps - elongated ethereal flames
                        particle.className = 'flame-particle wisp';
                        particle.style.width = (6 + Math.random() * 8) + 'px';
                        particle.style.height = (16 + Math.random() * 20) + 'px';
                    } else if (type === 'scatter') {
                        // Scatter - small erratic particles
                        particle.className = 'flame-particle scatter';
                        const size = 3 + Math.random() * 4;
                        particle.style.width = size + 'px';
                        particle.style.height = size + 'px';
                        // Erratic zigzag waypoints
                        particle.style.setProperty('--scatter-x1', (Math.random() * 16 - 8) + 'px');
                        particle.style.setProperty('--scatter-y1', (-5 - Math.random() * 12) + 'px');
                        particle.style.setProperty('--scatter-x2', (Math.random() * 20 - 10) + 'px');
                        particle.style.setProperty('--scatter-y2', (-18 - Math.random() * 15) + 'px');
                        particle.style.setProperty('--scatter-x3', (Math.random() * 18 - 9) + 'px');
                        particle.style.setProperty('--scatter-y3', (-30 - Math.random() * 15) + 'px');
                    } else {
                        // Mingle - particles that gravitate toward others
                        particle.className = 'flame-particle mingle';
                        const size = 5 + Math.random() * 6;
                        particle.style.width = size + 'px';
                        particle.style.height = size + 'px';
                        // Movement toward center/other particles
                        particle.style.setProperty('--mingle-x', (Math.random() * 12 - 6) + 'px');
                        particle.style.setProperty('--mingle-y', (Math.random() * 10 - 5) + 'px');
                    }
                    
                    // Use golden angle for even distribution, or forced angle
                    const goldenAngle = 137.508 * (Math.PI / 180);
                    const baseAngle = forceAngle !== null ? forceAngle : (particleIndex * goldenAngle);
                    const angle = baseAngle + (Math.random() - 0.5) * 0.6;
                    particleIndex++;
                    
                    // Vary distance in layers
                    const layer = Math.floor(Math.random() * 4);
                    const baseDistance = [36, 46, 56, 68][layer];
                    const distance = baseDistance + (Math.random() - 0.5) * 10;
                    
                    const startX = Math.cos(angle) * distance;
                    const startY = Math.sin(angle) * distance;
                    
                    // Drift direction (outward + upward bias)
                    const driftAngle = angle + (Math.random() - 0.5) * 0.7;
                    const driftDistance = 25 + Math.random() * 35;
                    const endX = Math.cos(driftAngle) * (distance + driftDistance);
                    const endY = Math.sin(driftAngle) * (distance + driftDistance) - 20 - Math.random() * 30;
                    
                    particle.style.setProperty('--start-x', startX + 'px');
                    particle.style.setProperty('--start-y', startY + 'px');
                    particle.style.setProperty('--drift-x', (endX - startX) / 2 + 'px');
                    particle.style.setProperty('--drift-y', (endY - startY) / 2 + 'px');
                    particle.style.setProperty('--end-x', (endX - startX) + 'px');
                    particle.style.setProperty('--end-y', (endY - startY) + 'px');
                    particle.style.setProperty('--rotation', (Math.random() * 60 - 30) + 'deg');
                    particle.style.setProperty('--flame-duration', (1.5 + Math.random() * 1.5) + 's');
                    particle.style.setProperty('--flame-delay', (Math.random() * 0.5) + 's');
                    
                    return particle;
                }
                
                // Initial particles - evenly distributed around the sun
                for (let i = 0; i < particleCount; i++) {
                    const angle = (i / particleCount) * Math.PI * 2;
                    flameContainer.appendChild(createFlameParticle(angle));
                }
                // Second wave with offset for fuller coverage
                for (let i = 0; i < 20; i++) {
                    const angle = ((i + 0.5) / 20) * Math.PI * 2;
                    flameContainer.appendChild(createFlameParticle(angle));
                }
                // Third wave - scatter particles for erratic movement
                for (let i = 0; i < 12; i++) {
                    const angle = ((i + 0.25) / 12) * Math.PI * 2;
                    flameContainer.appendChild(createFlameParticle(angle, 'scatter'));
                }
                // Fourth wave - mingle particles that gravitate
                for (let i = 0; i < 10; i++) {
                    const angle = ((i + 0.75) / 10) * Math.PI * 2;
                    flameContainer.appendChild(createFlameParticle(angle, 'mingle'));
                }
                
                // Continuously regenerate particles with variety
                setInterval(() => {
                    const toAdd = Math.floor(Math.random() * 4) + 3;
                    for (let i = 0; i < toAdd; i++) {
                        if (flameContainer.children.length < particleCount + 45) {
                            // Occasionally force scatter or mingle types
                            const forceType = Math.random() < 0.3 ? (Math.random() < 0.5 ? 'scatter' : 'mingle') : null;
                            flameContainer.appendChild(createFlameParticle(null, forceType));
                        }
                    }
                    // Remove old particles
                    while (flameContainer.children.length > particleCount + 50) {
                        flameContainer.removeChild(flameContainer.firstChild);
                    }
                }, 250);
            } else {
                // Calculate moon phase (synodic month = 29.53 days)
                const moonPhase = getMoonPhase();
                const phaseClipPath = getMoonPhaseClipPath(moonPhase);
                
                // Create moon structure with phase
                celestial.innerHTML = `
                    <div class="moon-container">
                        <div class="moon-glow"></div>
                        <div class="moon-body">
                            <div class="moon-crater-small"></div>
                        </div>
                        <div class="moon-phase" style="clip-path: ${phaseClipPath}"></div>
                    </div>
                `;
            }
        }
        
        // Calculate current moon phase (0 = new moon, 0.5 = full moon, 1 = new moon)
        function getMoonPhase() {
            const now = new Date();
            // Known new moon: January 11, 2024 11:57 UTC
            const knownNewMoon = new Date('2024-01-11T11:57:00Z');
            const synodicMonth = 29.53058867; // days
            
            const daysSinceNewMoon = (now - knownNewMoon) / (1000 * 60 * 60 * 24);
            const phase = (daysSinceNewMoon % synodicMonth) / synodicMonth;
            
            return phase;
        }
        
        // Generate clip-path for moon phase
        // Phase: 0 = new moon (dark), 0.25 = first quarter, 0.5 = full moon, 0.75 = last quarter
        function getMoonPhaseClipPath(phase) {
            // For the shadow overlay:
            // - New moon (0): full shadow covering entire moon
            // - Waxing (0-0.5): shadow recedes from right to left
            // - Full moon (0.5): no shadow
            // - Waning (0.5-1): shadow grows from right to left
            
            if (phase < 0.01 || phase > 0.99) {
                // New moon - full shadow
                return 'ellipse(50% 50% at 50% 50%)';
            }
            
            if (phase > 0.49 && phase < 0.51) {
                // Full moon - no shadow
                return 'ellipse(0% 0% at 50% 50%)';
            }
            
            // Calculate the terminator position
            // Using ellipse clip-path to simulate spherical shadow
            
            if (phase < 0.5) {
                // Waxing: shadow on left, shrinking
                // At phase 0: shadow covers 100% from left
                // At phase 0.25: shadow covers 50% from left (first quarter)
                // At phase 0.5: shadow covers 0%
                const shadowWidth = 50 - (phase * 100);
                const curveAmount = Math.abs(phase - 0.25) * 100;
                
                if (phase < 0.25) {
                    // Waxing crescent - elliptical shadow on left
                    const ellipseWidth = 50 + (0.25 - phase) * 100;
                    return `ellipse(${ellipseWidth}% 50% at ${100 - phase * 200}% 50%)`;
                } else {
                    // Waxing gibbous - shadow retreating from left
                    const coverPoint = 50 - (phase - 0.25) * 200;
                    return `inset(0 ${100 - coverPoint}% 0 0)`;
                }
            } else {
                // Waning: shadow on right, growing
                // At phase 0.5: shadow covers 0%
                // At phase 0.75: shadow covers 50% from right (last quarter)
                // At phase 1: shadow covers 100%
                const adjustedPhase = phase - 0.5;
                
                if (phase < 0.75) {
                    // Waning gibbous - shadow growing from right
                    const coverPoint = adjustedPhase * 200;
                    return `inset(0 0 0 ${100 - coverPoint}%)`;
                } else {
                    // Waning crescent - elliptical shadow on right
                    const ellipseWidth = 50 + (phase - 0.75) * 100;
                    return `ellipse(${ellipseWidth}% 50% at ${(phase - 0.5) * 200}% 50%)`;
                }
            }
        }

        function initParallax() {
            document.addEventListener('mousemove', (e) => {
                const mouseX = e.clientX / window.innerWidth - 0.5;
                const mouseY = e.clientY / window.innerHeight - 0.5;
                
                const celestial = document.getElementById('celestialBody');
                if (celestial) {
                    celestial.style.transform = `translate(${mouseX * -30}px, ${mouseY * -30}px)`;
                }
            });
        }

        // ========== GITHUB API ==========
        const username = 'geket';

        // Language colors (GitHub's colors)
        const langColors = {
            JavaScript: '#f1e05a',
            TypeScript: '#3178c6',
            Python: '#3572A5',
            Java: '#b07219',
            'C++': '#f34b7d',
            C: '#555555',
            'C#': '#178600',
            Ruby: '#701516',
            Go: '#00ADD8',
            Rust: '#dea584',
            PHP: '#4F5D95',
            Swift: '#F05138',
            Kotlin: '#A97BFF',
            Dart: '#00B4AB',
            HTML: '#e34c26',
            CSS: '#563d7c',
            SCSS: '#c6538c',
            Vue: '#41b883',
            Shell: '#89e051',
            Lua: '#000080',
            R: '#198CE7',
            Jupyter: '#DA5B0B',
            Default: '#ffb7c5'
        };

        // Fetch repositories and calculate stats
        fetch(`https://api.github.com/users/${username}/repos?per_page=100&sort=updated`)
            .then(res => res.json())
            .then(repos => {
                if (repos && repos.length > 0 && !repos.message) {
                    // Update portfolio grid
                    const grid = document.querySelector('.portfolio-grid');
                    const topRepos = repos.slice(0, 6);
                    grid.innerHTML = topRepos.map(repo => `
                        <a href="${repo.html_url}" target="_blank" rel="noopener noreferrer" class="project-card-link">
                            <div class="project-card">
                                <h3>${repo.name}</h3>
                                <p>${repo.description || 'A beautiful creation awaiting description...'}</p>
                                <div class="project-tags">
                                    ${repo.language ? `<span class="tag">${repo.language}</span>` : ''}
                                    <span class="tag">â­ ${repo.stargazers_count}</span>
                                    ${repo.forks_count > 0 ? `<span class="tag">ðŸ´ ${repo.forks_count}</span>` : ''}
                                </div>
                            </div>
                        </a>
                    `).join('');

                    // Calculate total stars
                    const totalStars = repos.reduce((sum, repo) => sum + repo.stargazers_count, 0);
                    document.getElementById('stat-stars').textContent = totalStars;

                    // Calculate language stats
                    const langCount = {};
                    const langRepos = {}; // Track repos per language
                    repos.forEach(repo => {
                        if (repo.language) {
                            langCount[repo.language] = (langCount[repo.language] || 0) + 1;
                            if (!langRepos[repo.language]) langRepos[repo.language] = [];
                            langRepos[repo.language].push(repo);
                        }
                    });

                    // Sort and get top 8 languages
                    const sortedLangs = Object.entries(langCount)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 8);

                    const totalLangRepos = sortedLangs.reduce((sum, [, count]) => sum + count, 0);

                    // Store language data globally for expand functionality
                    window.langData = { sortedLangs, langRepos, totalLangRepos, langColors };

                    // Render language bars (show 5 initially)
                    const langBarsContainer = document.getElementById('language-bars');
                    const langExpandBtn = document.getElementById('langExpandBtn');
                    
                    langBarsContainer.innerHTML = sortedLangs.map(([lang, count], index) => {
                        const percent = Math.round((count / totalLangRepos) * 100);
                        const color = langColors[lang] || langColors.Default;
                        const hiddenClass = index >= 5 ? 'hidden' : '';
                        return `
                            <div class="lang-item expandable ${hiddenClass}" data-lang="${lang}" data-index="${index}">
                                <div class="lang-info">
                                    <span class="lang-name">
                                        <span class="lang-dot" style="background: ${color}"></span>
                                        ${lang}
                                        <span class="lang-expand-icon">â–¶</span>
                                    </span>
                                    <span class="lang-percent">${percent}% (${count} repos)</span>
                                </div>
                                <div class="lang-bar-bg">
                                    <div class="lang-bar-fill" style="width: ${percent}%; background: ${color}"></div>
                                </div>
                                <div class="lang-details" id="lang-details-${index}">
                                    <div class="lang-stats">
                                        <div class="lang-stat">
                                            <span>ðŸ“</span>
                                            <span class="lang-stat-value">${count}</span>
                                            <span>repositories</span>
                                        </div>
                                        <div class="lang-stat">
                                            <span>ðŸ“</span>
                                            <span class="lang-stat-value" id="lang-commits-${index}">...</span>
                                            <span>total commits</span>
                                        </div>
                                    </div>
                                    <div class="lang-commits">
                                        <div class="lang-commits-title">Latest commits:</div>
                                        <div id="lang-commit-list-${index}">
                                            <div class="lang-commit-item">Loading commits...</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        `;
                    }).join('');

                    // Show expand button if more than 5 languages
                    if (sortedLangs.length > 5) {
                        langExpandBtn.style.display = 'flex';
                    }

                    // Language expand button handler
                    langExpandBtn.addEventListener('click', function() {
                        const isExpanded = this.classList.toggle('expanded');
                        const hiddenLangs = langBarsContainer.querySelectorAll('.lang-item[data-index]');
                        hiddenLangs.forEach(item => {
                            const idx = parseInt(item.dataset.index);
                            if (idx >= 5) {
                                item.classList.toggle('hidden', !isExpanded);
                            }
                        });
                        this.querySelector('span:first-child').textContent = isExpanded ? 'Show less' : 'Show more';
                    });

                    // Language item click handler for sub-expand
                    langBarsContainer.addEventListener('click', async function(e) {
                        const langItem = e.target.closest('.lang-item');
                        if (!langItem) return;
                        
                        const lang = langItem.dataset.lang;
                        const index = langItem.dataset.index;
                        const wasExpanded = langItem.classList.contains('expanded');
                        
                        // Close all other expanded items
                        langBarsContainer.querySelectorAll('.lang-item.expanded').forEach(item => {
                            if (item !== langItem) item.classList.remove('expanded');
                        });
                        
                        langItem.classList.toggle('expanded');
                        
                        // Fetch commits if newly expanded
                        if (!wasExpanded && langItem.classList.contains('expanded')) {
                            const repos = window.langData.langRepos[lang] || [];
                            let totalCommits = 0;
                            let allCommits = [];
                            
                            // Fetch commits from top 3 repos of this language
                            const topRepos = repos.slice(0, 3);
                            for (const repo of topRepos) {
                                try {
                                    const commitsRes = await fetch(`https://api.github.com/repos/${username}/${repo.name}/commits?per_page=5`);
                                    const commits = await commitsRes.json();
                                    if (Array.isArray(commits)) {
                                        totalCommits += commits.length;
                                        allCommits.push(...commits.map(c => ({
                                            msg: c.commit?.message?.split('\n')[0] || 'No message',
                                            repo: repo.name,
                                            date: c.commit?.author?.date || '',
                                            sha: c.sha?.substring(0, 7) || ''
                                        })));
                                    }
                                } catch (err) {
                                    console.log('Could not fetch commits for', repo.name);
                                }
                            }
                            
                            // Estimate total commits (5 per repo average)
                            const estimatedTotal = repos.length * 15;
                            document.getElementById(`lang-commits-${index}`).textContent = `~${estimatedTotal}`;
                            
                            // Show latest 3 commits
                            const commitList = document.getElementById(`lang-commit-list-${index}`);
                            if (allCommits.length > 0) {
                                const latestCommits = allCommits.slice(0, 3);
                                commitList.innerHTML = latestCommits.map(c => {
                                    const date = c.date ? new Date(c.date).toLocaleDateString() : '';
                                    return `
                                        <div class="lang-commit-item">
                                            <span class="commit-icon">â—</span>
                                            <div class="commit-info">
                                                <div class="commit-msg">${c.msg.substring(0, 50)}${c.msg.length > 50 ? '...' : ''}</div>
                                                <div class="commit-meta">
                                                    <span class="commit-repo">${c.repo}</span>
                                                    <span>${c.sha}</span>
                                                    <span>${date}</span>
                                                </div>
                                            </div>
                                        </div>
                                    `;
                                }).join('');
                            } else {
                                commitList.innerHTML = '<div class="lang-commit-item">No commits found</div>';
                            }
                        }
                    });
                }
            })
            .catch(err => {
                console.log('Note: GitHub API requires deployment to work. Deploy to geket.github.io to see live data.');
            });

        // Fetch user stats
        fetch(`https://api.github.com/users/${username}`)
            .then(res => res.json())
            .then(user => {
                if (user && !user.message) {
                    document.getElementById('repoCount').textContent = user.public_repos;
                    document.getElementById('followerCount').textContent = user.followers;
                    document.getElementById('contributionCount').textContent = user.following;
                    
                    // Also update the custom stats
                    document.getElementById('stat-repos').textContent = user.public_repos;
                    document.getElementById('stat-followers').textContent = user.followers;
                    document.getElementById('stat-following').textContent = user.following;
                }
            })
            .catch(err => {
                // Stats will show placeholder values
            });

        // Fetch starred repos (responsive: mobile=16, desktop=21)
        const isMobile = window.innerWidth <= 768;
        const starsPerPage = isMobile ? 16 : 21;
        const initialVisible = isMobile ? 6 : 9;
        
        fetch(`https://api.github.com/users/${username}/starred?per_page=${starsPerPage}&sort=created`)
            .then(res => res.json())
            .then(starred => {
                if (starred && starred.length > 0 && !starred.message) {
                    const starsContainer = document.getElementById('recent-stars');
                    const expandBtn = document.getElementById('expandStarsBtn');
                    
                    starsContainer.innerHTML = starred.map((repo, index) => `
                        <div class="star-item ${index >= initialVisible ? 'hidden' : ''}">
                            <span class="star-icon">â­</span>
                            <div>
                                <a href="${repo.html_url}" target="_blank" rel="noopener noreferrer">${repo.full_name}</a>
                                <p class="star-desc">${repo.description || 'No description'}</p>
                            </div>
                        </div>
                    `).join('');

                    // Show expand button if more than initial visible stars
                    if (starred.length > initialVisible) {
                        expandBtn.style.display = 'flex';
                        
                        expandBtn.addEventListener('click', () => {
                            const hiddenItems = starsContainer.querySelectorAll('.star-item.hidden');
                            const visibleItems = starsContainer.querySelectorAll('.star-item:not(.hidden)');
                            
                            if (hiddenItems.length > 0) {
                                // Expand
                                hiddenItems.forEach((item, i) => {
                                    setTimeout(() => {
                                        item.classList.remove('hidden');
                                        item.classList.add('show');
                                    }, i * 50);
                                });
                                expandBtn.querySelector('.expand-text').textContent = 'Show Less';
                                expandBtn.classList.add('expanded');
                            } else {
                                // Collapse
                                const allItems = starsContainer.querySelectorAll('.star-item');
                                allItems.forEach((item, index) => {
                                    if (index >= initialVisible) {
                                        item.classList.add('hidden');
                                        item.classList.remove('show');
                                    }
                                });
                                expandBtn.querySelector('.expand-text').textContent = 'Show More';
                                expandBtn.classList.remove('expanded');
                            }
                        });
                    }
                }
            })
            .catch(err => {
                document.getElementById('recent-stars').innerHTML = '<p style="opacity:0.6; font-size:0.85rem;">Stars will load when deployed</p>';
            });

        // Fetch activity feed
        fetch(`https://api.github.com/users/${username}/events/public?per_page=15`)
            .then(res => res.json())
            .then(events => {
                if (events && events.length > 0 && !events.message) {
                    const activityContainer = document.getElementById('activity-feed');
                    const expandBtn = document.getElementById('expandActivityBtn');
                    
                    const activityIcons = {
                        'PushEvent': 'ðŸ“¤',
                        'PullRequestEvent': 'ðŸ”€',
                        'IssuesEvent': 'ðŸ›',
                        'CreateEvent': 'âœ¨',
                        'DeleteEvent': 'ðŸ—‘ï¸',
                        'WatchEvent': 'â­',
                        'ForkEvent': 'ðŸ´',
                        'IssueCommentEvent': 'ðŸ’¬',
                        'PullRequestReviewEvent': 'ðŸ‘€',
                        'PullRequestReviewCommentEvent': 'ðŸ’­',
                        'ReleaseEvent': 'ðŸš€'
                    };

                    const formatEvent = (event) => {
                        const repoName = event.repo.name;
                        const repoUrl = `https://github.com/${repoName}`;
                        
                        switch(event.type) {
                            case 'PushEvent':
                                const commits = event.payload.commits?.length || event.payload.size || 1;
                                return `Pushed ${commits} commit${commits !== 1 ? 's' : ''} to <a href="${repoUrl}" target="_blank">${repoName}</a>`;
                            case 'PullRequestEvent':
                                return `${event.payload.action.charAt(0).toUpperCase() + event.payload.action.slice(1)} PR in <a href="${repoUrl}" target="_blank">${repoName}</a>`;
                            case 'IssuesEvent':
                                return `${event.payload.action.charAt(0).toUpperCase() + event.payload.action.slice(1)} issue in <a href="${repoUrl}" target="_blank">${repoName}</a>`;
                            case 'CreateEvent':
                                return `Created ${event.payload.ref_type} in <a href="${repoUrl}" target="_blank">${repoName}</a>`;
                            case 'WatchEvent':
                                return `Starred <a href="${repoUrl}" target="_blank">${repoName}</a>`;
                            case 'ForkEvent':
                                return `Forked <a href="${repoUrl}" target="_blank">${repoName}</a>`;
                            case 'IssueCommentEvent':
                                return `Commented on issue in <a href="${repoUrl}" target="_blank">${repoName}</a>`;
                            case 'PullRequestReviewEvent':
                                return `Reviewed PR in <a href="${repoUrl}" target="_blank">${repoName}</a>`;
                            case 'PullRequestReviewCommentEvent':
                                return `Commented on PR in <a href="${repoUrl}" target="_blank">${repoName}</a>`;
                            case 'ReleaseEvent':
                                return `Released ${event.payload.release?.tag_name || 'version'} in <a href="${repoUrl}" target="_blank">${repoName}</a>`;
                            default:
                                return `Activity in <a href="${repoUrl}" target="_blank">${repoName}</a>`;
                        }
                    };

                    const timeAgo = (date) => {
                        const seconds = Math.floor((new Date() - new Date(date)) / 1000);
                        if (seconds < 60) return 'just now';
                        const minutes = Math.floor(seconds / 60);
                        if (minutes < 60) return `${minutes}m ago`;
                        const hours = Math.floor(minutes / 60);
                        if (hours < 24) return `${hours}h ago`;
                        const days = Math.floor(hours / 24);
                        if (days < 30) return `${days}d ago`;
                        return new Date(date).toLocaleDateString();
                    };

                    activityContainer.innerHTML = events.map((event, index) => `
                        <div class="activity-item ${index >= 4 ? 'hidden' : ''}">
                            <span class="activity-icon">${activityIcons[event.type] || 'ðŸ“Œ'}</span>
                            <div class="activity-content">
                                <p class="activity-text">${formatEvent(event)}</p>
                                <p class="activity-time">${timeAgo(event.created_at)}</p>
                            </div>
                        </div>
                    `).join('');

                    // Show expand button if more than 4 activities
                    if (events.length > 4) {
                        expandBtn.style.display = 'flex';
                        
                        expandBtn.addEventListener('click', () => {
                            const hiddenItems = activityContainer.querySelectorAll('.activity-item.hidden');
                            const visibleItems = activityContainer.querySelectorAll('.activity-item:not(.hidden)');
                            
                            if (hiddenItems.length > 0) {
                                // Expand
                                hiddenItems.forEach((item, i) => {
                                    setTimeout(() => {
                                        item.classList.remove('hidden');
                                        item.classList.add('show');
                                    }, i * 50);
                                });
                                expandBtn.querySelector('span:first-child').textContent = 'Show Less';
                                expandBtn.classList.add('expanded');
                            } else {
                                // Collapse
                                const allItems = activityContainer.querySelectorAll('.activity-item');
                                allItems.forEach((item, index) => {
                                    if (index >= 4) {
                                        item.classList.add('hidden');
                                        item.classList.remove('show');
                                    }
                                });
                                expandBtn.querySelector('span:first-child').textContent = 'Show More';
                                expandBtn.classList.remove('expanded');
                            }
                        });
                    }

                    // Calculate activity breakdown for pentagon chart
                    const activityCounts = {
                        commits: 0,
                        codeReview: 0,
                        issues: 0,
                        pullRequests: 0,
                        privateContrib: 6 // Default estimate for private contributions
                    };

                    events.forEach(event => {
                        switch(event.type) {
                            case 'PushEvent':
                                activityCounts.commits += event.payload.commits?.length || event.payload.size || 1;
                                break;
                            case 'PullRequestReviewEvent':
                            case 'PullRequestReviewCommentEvent':
                                activityCounts.codeReview++;
                                break;
                            case 'IssuesEvent':
                            case 'IssueCommentEvent':
                                activityCounts.issues++;
                                break;
                            case 'PullRequestEvent':
                                activityCounts.pullRequests++;
                                break;
                        }
                    });

                    drawActivityChart(activityCounts);
                }
            })
            .catch(err => {
                document.getElementById('activity-feed').innerHTML = '<p style="opacity:0.6; font-size:0.85rem;">Activity will load when deployed</p>';
                drawActivityChart({ commits: 15, codeReview: 5, issues: 1, pullRequests: 2, privateContrib: 6 });
            });

        // Draw Activity Chart (Pentagon style like GitHub)
        function drawActivityChart(data) {
            const canvas = document.getElementById('activityChart');
            if (!canvas) return;
            
            // High DPI support
            const dpr = window.devicePixelRatio || 1;
            const displayWidth = 340;
            const displayHeight = 340;
            
            // Set actual size in memory (scaled for retina)
            canvas.width = displayWidth * dpr;
            canvas.height = displayHeight * dpr;
            
            // Set display size (CSS)
            canvas.style.width = displayWidth + 'px';
            canvas.style.height = displayHeight + 'px';
            
            const ctx = canvas.getContext('2d');
            
            // Scale all drawing operations
            ctx.scale(dpr, dpr);
            
            const centerX = displayWidth / 2;
            const centerY = displayHeight / 2;
            const maxRadius = Math.min(centerX, centerY) - 70; // More padding for labels

            // Clear canvas
            ctx.clearRect(0, 0, displayWidth, displayHeight);

            // Calculate total and percentages (5 axes for pentagon)
            const total = data.commits + data.codeReview + data.issues + data.pullRequests + data.privateContrib;
            const values = [
                total > 0 ? data.commits / total : 0.2,
                total > 0 ? data.codeReview / total : 0.2,
                total > 0 ? data.issues / total : 0.2,
                total > 0 ? data.pullRequests / total : 0.2,
                total > 0 ? data.privateContrib / total : 0.2
            ];

            // Points for pentagon shape (5 points, starting from top)
            const numPoints = 5;
            const angles = [];
            for (let i = 0; i < numPoints; i++) {
                angles.push(-Math.PI / 2 + (2 * Math.PI * i) / numPoints);
            }
            
            // Draw grid lines (pentagon shapes at different radii)
            ctx.strokeStyle = 'rgba(255, 183, 197, 0.1)';
            ctx.lineWidth = 1;
            
            for (let r = 0.25; r <= 1; r += 0.25) {
                ctx.beginPath();
                for (let i = 0; i < numPoints; i++) {
                    const x = centerX + Math.cos(angles[i]) * maxRadius * r;
                    const y = centerY + Math.sin(angles[i]) * maxRadius * r;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();
            }

            // Draw axis lines from center to each vertex
            ctx.strokeStyle = 'rgba(255, 183, 197, 0.15)';
            for (let i = 0; i < numPoints; i++) {
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(
                    centerX + Math.cos(angles[i]) * maxRadius,
                    centerY + Math.sin(angles[i]) * maxRadius
                );
                ctx.stroke();
            }

            // Draw data shape
            ctx.beginPath();
            const minScale = 0.12;
            for (let i = 0; i < numPoints; i++) {
                const scale = minScale + values[i] * (1 - minScale);
                const x = centerX + Math.cos(angles[i]) * maxRadius * Math.min(scale * 2, 1);
                const y = centerY + Math.sin(angles[i]) * maxRadius * Math.min(scale * 2, 1);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();

            // Fill with gradient
            const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, maxRadius);
            gradient.addColorStop(0, 'rgba(100, 200, 150, 0.5)');
            gradient.addColorStop(1, 'rgba(100, 200, 150, 0.15)');
            ctx.fillStyle = gradient;
            ctx.fill();

            // Stroke outline
            ctx.strokeStyle = 'rgba(100, 200, 150, 0.9)';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw data points
            ctx.fillStyle = 'rgba(100, 200, 150, 1)';
            for (let i = 0; i < numPoints; i++) {
                const scale = minScale + values[i] * (1 - minScale);
                const x = centerX + Math.cos(angles[i]) * maxRadius * Math.min(scale * 2, 1);
                const y = centerY + Math.sin(angles[i]) * maxRadius * Math.min(scale * 2, 1);
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw labels and percentage with proper alignment
            ctx.font = '11px "Cormorant Garamond", serif';
            
            // Label configurations with adjusted positions for better visibility
            // Using arrays for multi-line labels
            const labelConfigs = [
                { label: ['Commits'], align: 'center', dx: 0, dy: -10 },           // Top
                { label: ['Code', 'Review'], align: 'left', dx: 10, dy: -5 },      // Top right (stacked)
                { label: ['Issues'], align: 'left', dx: 8, dy: 8 },                // Bottom right
                { label: ['Pull', 'Requests'], align: 'right', dx: -8, dy: 0 },    // Bottom left (stacked)
                { label: ['Private'], align: 'right', dx: -10, dy: 0 }             // Top left
            ];

            for (let i = 0; i < numPoints; i++) {
                const labelRadius = maxRadius + 25;
                const baseX = centerX + Math.cos(angles[i]) * labelRadius;
                const baseY = centerY + Math.sin(angles[i]) * labelRadius;
                const x = baseX + labelConfigs[i].dx;
                const y = baseY + labelConfigs[i].dy;
                
                // Set text alignment
                ctx.textAlign = labelConfigs[i].align;
                
                // Draw label (multi-line support)
                ctx.fillStyle = 'rgba(255, 183, 197, 0.9)';
                const lines = labelConfigs[i].label;
                lines.forEach((line, lineIdx) => {
                    ctx.fillText(line, x, y + (lineIdx * 11));
                });
                
                // Draw percentage below the last line
                ctx.fillStyle = '#f8f0e3';
                ctx.fillText(`${Math.round(values[i] * 100)}%`, x, y + (lines.length * 11) + 2);
            }
        }

        // ========== MINECRAFT EASTER EGG GAME ==========
        const minecraftGame = {
            canvas: null,
            ctx: null,
            isActive: false,
            isPaused: false,
            camera: { x: 0, y: 50, z: 0, rotX: 0, rotY: 0 },
            velocity: { x: 0, y: 0, z: 0 },
            world: {},
            keys: {},
            isJumping: false,
            gravity: -0.035,  // Stronger gravity for snappier jumps
            lastPos: { x: 0, z: 0 },
            pointerLocked: false,
            
            // Fluid state
            inWater: false,
            inLava: false,
            swimming: false,
            headSubmergedWater: false,
            headSubmergedLava: false,
            
            // Player dimensions - camera at waist/hip level
            playerEyeHeight: 1.2,  // How high camera is above feet
            playerHeight: 1.8,     // Total player height
            
            // Birds and mobs
            birds: [],
            pestBirds: [],
            blueBirds: [],
            fish: [],
            cats: [],
            creepers: [],
            
            // Items and inventory
            selectedSlot: 0,  // 0-8 for hotbar slots
            selectedBlock: 'grass',
            selectedItem: null,  // For non-block items like ak47
            
            // Inventory system
            inventory: {
                // Hotbar slots (9 slots)
                hotbar: [
                    { type: 'block', id: 'grass', count: 64 },
                    { type: 'block', id: 'dirt', count: 64 },
                    { type: 'block', id: 'stone', count: 64 },
                    { type: 'block', id: 'wood', count: 64 },
                    { type: 'block', id: 'brick', count: 64 },
                    { type: 'bucket', id: 'water_bucket', count: 5 },
                    { type: 'bucket', id: 'lava_bucket', count: 5 },
                    { type: 'weapon', id: 'ak47', count: 1, durability: 100, maxDurability: 100 },
                    null  // Empty slot
                ],
                // Main inventory (27 slots - 3 rows of 9)
                main: [
                    { type: 'block', id: 'leaves', count: 64 },
                    { type: 'block', id: 'sand', count: 64 },
                    null, null, null, null, null, null, null,
                    null, null, null, null, null, null, null, null, null,
                    null, null, null, null, null, null, null, null, null
                ],
                // Crafting result
                craftingResult: null
            },
            
            // Crafting recipes
            recipes: [
                { ingredients: [{ id: 'wood', count: 4 }], result: { type: 'block', id: 'wood', count: 16 }, name: 'Planks' },
                { ingredients: [{ id: 'stone', count: 8 }], result: { type: 'block', id: 'brick', count: 4 }, name: 'Bricks' },
                { ingredients: [{ id: 'sand', count: 4 }], result: { type: 'block', id: 'stone', count: 2 }, name: 'Sandstone' },
                { ingredients: [{ id: 'wood', count: 8 }], result: { type: 'block', id: 'chest', count: 1 }, name: 'Chest' }
            ],
            
            // Fluid blocks that need updating
            fluidUpdates: [],
            fluidLevels: {},  // Stores fluid level 1-8 at each position
            fluidUpdateTimer: 0,
            
            // Bird anger system
            birdPruneTimer: 0,
            
            // Weapon properties
            shootCooldown: 0,
            muzzleFlash: 0,
            particles: [],  // Bullet particles
            
            // UI state
            inventoryOpen: false,
            draggedItem: null,
            dragSource: null,
            
            // Stats
            stats: {
                blocksPlaced: 0,
                blocksBroken: 0,
                distance: 0,
                jumps: 0,
                startTime: 0
            },
            
            // Graphics settings
            settings: {
                brightness: 100,
                filter: 'none',
                renderDistance: 20,
                shadows: true,
                lighting: true,
                antialiasing: false,
                showFps: true,
                targetFps: 60
            },
            
            // FPS tracking
            fpsCounter: {
                frames: 0,
                lastTime: 0,
                fps: 0
            },
            
            // Simple 2D noise function (value noise with interpolation)
            noise2D: (function() {
                // Permutation table
                const perm = [];
                for (let i = 0; i < 512; i++) {
                    perm[i] = Math.floor(Math.random() * 256);
                }
                
                function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
                function lerp(a, b, t) { return a + t * (b - a); }
                function grad(hash, x, y) {
                    const h = hash & 3;
                    const u = h < 2 ? x : y;
                    const v = h < 2 ? y : x;
                    return ((h & 1) ? -u : u) + ((h & 2) ? -v : v);
                }
                
                return function(x, y) {
                    const X = Math.floor(x) & 255;
                    const Y = Math.floor(y) & 255;
                    x -= Math.floor(x);
                    y -= Math.floor(y);
                    const u = fade(x);
                    const v = fade(y);
                    const A = perm[X] + Y;
                    const B = perm[X + 1] + Y;
                    return lerp(
                        lerp(grad(perm[A], x, y), grad(perm[B], x - 1, y), u),
                        lerp(grad(perm[A + 1], x, y - 1), grad(perm[B + 1], x - 1, y - 1), u),
                        v
                    );
                };
            })(),
            
            // Fractal Brownian Motion for more natural terrain
            fbm(x, y, octaves = 4) {
                let value = 0;
                let amplitude = 1;
                let frequency = 1;
                let maxValue = 0;
                
                for (let i = 0; i < octaves; i++) {
                    value += this.noise2D(x * frequency, y * frequency) * amplitude;
                    maxValue += amplitude;
                    amplitude *= 0.5;
                    frequency *= 2;
                }
                
                return value / maxValue;
            },
            
            blockColors: {
                grass: { top: '#7cba5f', side: '#8b6b4a', bottom: '#6b4423' },
                dirt: { top: '#8b6b4a', side: '#8b6b4a', bottom: '#8b6b4a' },
                stone: { top: '#888888', side: '#777777', bottom: '#666666' },
                wood: { top: '#a0825a', side: '#6b4423', bottom: '#6b4423' },
                leaves: { top: 'rgba(50, 180, 50, 0.85)', side: 'rgba(40, 160, 40, 0.85)', bottom: 'rgba(30, 140, 30, 0.85)', transparent: true }, // Beautiful transparent leaves
                appleLeaves: { top: 'rgba(50, 180, 50, 0.85)', side: 'rgba(40, 160, 40, 0.85)', bottom: 'rgba(30, 140, 30, 0.85)', transparent: true }, // Beautiful transparent apple leaves
                water: { top: 'rgba(74, 144, 217, 0.7)', side: 'rgba(58, 128, 201, 0.7)', bottom: 'rgba(42, 112, 185, 0.7)', transparent: true, animated: true },
                sand: { top: '#e6d9a0', side: '#d9cc93', bottom: '#ccbf86' },
                brick: { top: '#b35050', side: '#a04040', bottom: '#903030' },
                lava: { top: '#ff6600', side: '#ff4400', bottom: '#cc3300', animated: true },
                obsidian: { top: '#1a0a2e', side: '#140820', bottom: '#0a0410' },
                cherryWood: { top: '#c4a07a', side: '#8b5a5a', bottom: '#8b5a5a' },
                cherryLeaves: { top: 'rgba(255, 183, 197, 0.85)', side: 'rgba(255, 192, 203, 0.85)', bottom: 'rgba(255, 144, 165, 0.85)', transparent: true },
                chest: { top: '#8b6914', side: '#a0780a', bottom: '#705010' },
                ritualChest: { top: '#4a0080', side: '#6a00b0', bottom: '#300060' },
                buildingChest: { top: '#c0c0c0', side: '#a0a0a0', bottom: '#808080' },
                // Ritual Temple blocks
                ritualStone: { top: '#4a4a6a', side: '#3a3a5a', bottom: '#2a2a4a' },
                petalSocket: { top: '#ffb7c5', side: '#8b5a5a', bottom: '#5a3a3a' },
                ropeSocket: { top: '#8b7355', side: '#6b5a45', bottom: '#4b3a25' },
                charmSocket: { top: '#ffd700', side: '#daa520', bottom: '#b8860b' },
                plaqueSocket: { top: '#deb887', side: '#c4a07a', bottom: '#8b7355' },
                incenseSocket: { top: '#9370db', side: '#7b68ee', bottom: '#6a5acd' },
                // Filled socket blocks (glowing versions)
                petalSocketFilled: { top: '#ff69b4', side: '#ff1493', bottom: '#c71585' },
                ropeSocketFilled: { top: '#daa520', side: '#b8860b', bottom: '#8b6914' },
                charmSocketFilled: { top: '#fff700', side: '#ffd700', bottom: '#ffb700' },
                plaqueSocketFilled: { top: '#f4a460', side: '#d2691e', bottom: '#a0522d' },
                incenseSocketFilled: { top: '#da70d6', side: '#ba55d3', bottom: '#9932cc' },
                // Church blocks
                whiteBrick: { top: '#f0f0f0', side: '#e0e0e0', bottom: '#d0d0d0' },
                redBrick: { top: '#b35050', side: '#a04040', bottom: '#903030' },
                glowstone: { top: '#ffdd88', side: '#eebb66', bottom: '#ddaa44' }
            },
            
            // Item definitions with properties
            itemTypes: {
                // Building materials
                grass: { stackable: true, maxStack: 64 },
                dirt: { stackable: true, maxStack: 64 },
                stone: { stackable: true, maxStack: 64 },
                wood: { stackable: true, maxStack: 64 },
                leaves: { stackable: true, maxStack: 64 },
                appleLeaves: { stackable: true, maxStack: 64 },
                sand: { stackable: true, maxStack: 64 },
                brick: { stackable: true, maxStack: 64 },
                cherryWood: { stackable: true, maxStack: 64 },
                cherryLeaves: { stackable: true, maxStack: 64 },
                chest: { stackable: true, maxStack: 16 },
                obsidian: { stackable: true, maxStack: 64 },
                whiteBrick: { stackable: true, maxStack: 64 },
                redBrick: { stackable: true, maxStack: 64 },
                glowstone: { stackable: true, maxStack: 64 },
                ritualStone: { stackable: true, maxStack: 64 },
                // Consumables/Throwables
                apple: { stackable: true, maxStack: 64, throwable: true, description: 'Throw at birds to knock them away' },
                // Buckets
                water_bucket: { stackable: true, maxStack: 16 },
                lava_bucket: { stackable: true, maxStack: 16 },
                // Tools with durability
                ak47: { stackable: false, maxStack: 1, durability: 100, maxDurability: 100, description: 'Shoots bullets at birds' },
                seeds: { stackable: true, maxStack: 64, description: 'Calms angry birds temporarily' },
                berdger: { stackable: false, maxStack: 1, invincible: true, description: 'The legendary bird repellent - infinite uses!' },
                // Ritual items (Omamori charm components)
                sakuraPetal: { stackable: true, maxStack: 16, description: 'Sacred cherry blossom petal', ritual: true },
                shimenawa: { stackable: true, maxStack: 1, description: 'Sacred rope', ritual: true },
                omamori: { stackable: true, maxStack: 1, description: 'Protective charm base', ritual: true },
                ema: { stackable: true, maxStack: 1, description: 'Wooden wish plaque', ritual: true },
                incense: { stackable: true, maxStack: 1, description: 'Purifying incense', ritual: true }
            },
            
            // Fluids that player can pass through
            fluidBlocks: ['water', 'lava'],
            
            // Ritual system - Omamori Blessing (Japanese protective charm ritual)
            ritualItems: ['sakuraPetal', 'shimenawa', 'omamori', 'ema', 'incense'],
            ritualComplete: false,
            ritualBlessingActive: false,
            ritualBlessingTimer: 0,
            ritualFlight: false,
            ritualFlightTimer: 0,
            ritualBarrierActive: false,
            
            init() {
                // Lightweight init - just get canvas reference
                // World generation is deferred to start() to avoid lagging main site
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.initialized = false;  // Track if world has been generated
                this.gameLoopId = null;    // Track animation frame for cleanup
                this.lastFrameTime = 0;    // For FPS limiting
            },
            
            // Full initialization - called only when game starts
            fullInit() {
                if (this.initialized) return;  // Don't regenerate if already done
                
                this.generateWorld();
                this.setupControls();
                this.setupMenus();
                this.setupDebugConsole();
                this.initialized = true;
                
                // Force initial hotbar render with multiple attempts for reliability
                this.updateHotbarDisplay();
                setTimeout(() => this.updateHotbarDisplay(), 50);
                setTimeout(() => this.updateHotbarDisplay(), 150);
                setTimeout(() => this.updateHotbarDisplay(), 300);
            },
            
            generateWorld() {
                this.world = {};
                this.fluidLevels = {};  // Clear fluid levels
                this.droppedItems = []; // Items on ground
                this.cherryTrees = [];  // Cherry blossom tree locations
                this.petalParticles = []; // Cherry blossom petals
                
                const worldSize = 50; // -50 to 50 = 101x101 blocks
                const waterLevel = 6;
                const baseHeight = 8;
                
                // Store world bounds for forcefield - ON the last block, not past it
                this.worldBounds = {
                    minX: -worldSize,
                    maxX: worldSize + 1,
                    minZ: -worldSize,
                    maxZ: worldSize + 1,
                    minY: 0,
                    maxY: 50
                };
                
                // Wind system for petals and birds
                this.wind = {
                    x: 0,
                    z: 0,
                    targetX: 0,
                    targetZ: 0,
                    gustTimer: 0,
                    strength: 0.02
                };
                
                // Building placements storage
                this.buildings = [];
                
                // Fluid simulation queue
                this.fluidQueue = [];
                
                // Pre-calculate height map for faster generation
                const heightMap = {};
                const biomeMap = {};
                
                // First pass: calculate heights
                for (let x = -worldSize; x <= worldSize; x++) {
                    for (let z = -worldSize; z <= worldSize; z++) {
                        const n1 = this.fbm(x * 0.03, z * 0.03, 2) * 10;
                        const n2 = this.fbm(x * 0.05 + 100, z * 0.05 + 100, 2) * 5;
                        
                        const distFromCenter = Math.sqrt(x * x + z * z) / worldSize;
                        const edgeFalloff = Math.max(0, 1 - distFromCenter * 0.5);
                        
                        let height = Math.floor(baseHeight + (n1 + n2) * edgeFalloff);
                        height = Math.max(1, Math.min(22, height));
                        
                        const key = `${x},${z}`;
                        heightMap[key] = height;
                        biomeMap[key] = this.noise2D(x * 0.03 + 500, z * 0.03 + 500);
                    }
                }
                
                // Second pass: generate blocks using cached heights
                for (let x = -worldSize; x <= worldSize; x++) {
                    for (let z = -worldSize; z <= worldSize; z++) {
                        const key = `${x},${z}`;
                        const height = heightMap[key];
                        const biomeNoise = biomeMap[key];
                        
                        const isBeach = height <= waterLevel + 1 && height >= waterLevel - 1;
                        const isDesert = biomeNoise > 0.3 && height > waterLevel + 2;
                        
                        // Generate column - only surface blocks for speed
                        // Just 3 layers of stone at bottom
                        for (let y = Math.max(0, height - 3); y < height - 1; y++) {
                            this.setBlock(x, y, z, 'stone');
                        }
                        
                        // Surface layers based on biome
                        if (isBeach || (height <= waterLevel)) {
                            this.setBlock(x, height - 1, z, 'sand');
                            this.setBlock(x, height, z, 'sand');
                        } else if (isDesert) {
                            this.setBlock(x, height - 1, z, 'sand');
                            this.setBlock(x, height, z, 'sand');
                        } else {
                            this.setBlock(x, height - 1, z, 'dirt');
                            this.setBlock(x, height, z, 'grass');
                        }
                        
                        // Water - source blocks at full level
                        if (height < waterLevel) {
                            for (let y = height + 1; y <= waterLevel; y++) {
                                this.setBlock(x, y, z, 'water');
                                this.setFluidLevel(x, y, z, 8);  // Full level for natural water
                            }
                        }
                    }
                }
                
                // Trees - separate pass, sparser
                for (let x = -worldSize; x <= worldSize; x += 2) { // Skip every other for speed
                    for (let z = -worldSize; z <= worldSize; z += 2) {
                        const key = `${x},${z}`;
                        const height = heightMap[key];
                        const biomeNoise = biomeMap[key];
                        const isBeach = height <= waterLevel + 1;
                        const isDesert = biomeNoise > 0.3;
                        
                        if (height > waterLevel + 1 && !isDesert && !isBeach) {
                            const treeNoise = this.noise2D(x * 0.4 + 300, z * 0.4 + 300);
                            if (treeNoise > 0.5 && Math.random() < 0.12) {
                                // 25% chance for cherry blossom tree
                                if (Math.random() < 0.25) {
                                    this.generateCherryTree(x, height + 1, z);
                                } else {
                                    this.generateTree(x, height + 1, z);
                                }
                            }
                        }
                    }
                }
                
                // Spawn ritual item chests (rare, ~5 in world)
                const ritualChestCount = 5;
                for (let i = 0; i < ritualChestCount; i++) {
                    const rx = Math.floor(Math.random() * worldSize * 2) - worldSize;
                    const rz = Math.floor(Math.random() * worldSize * 2) - worldSize;
                    const rKey = `${rx},${rz}`;
                    const rHeight = heightMap[rKey] || baseHeight;
                    if (rHeight > waterLevel) {
                        this.setBlock(rx, rHeight + 1, rz, 'ritualChest');
                        // Store chest contents
                        const ritualItem = this.ritualItems[i % this.ritualItems.length];
                        this.chestContents = this.chestContents || {};
                        this.chestContents[`${rx},${rHeight + 1},${rz}`] = [
                            { type: ritualItem, count: 1 }
                        ];
                    }
                }
                
                // Spawn seeds around the world (uncommon ground items)
                for (let i = 0; i < 30; i++) {
                    const sx = Math.floor(Math.random() * worldSize * 2) - worldSize;
                    const sz = Math.floor(Math.random() * worldSize * 2) - worldSize;
                    const sKey = `${sx},${sz}`;
                    const sHeight = heightMap[sKey] || baseHeight;
                    if (sHeight > waterLevel) {
                        this.droppedItems.push({
                            x: sx + 0.5,
                            y: sHeight + 1.2,
                            z: sz + 0.5,
                            type: 'seeds',
                            count: 1 + Math.floor(Math.random() * 3),
                            bobPhase: Math.random() * Math.PI * 2
                        });
                    }
                }
                
                // Spawn apples under apple trees
                if (this.appleTrees) {
                    for (const tree of this.appleTrees) {
                        // 50% chance of apples under each tree
                        if (Math.random() < 0.5) {
                            const appleCount = 1 + Math.floor(Math.random() * 3);
                            for (let i = 0; i < appleCount; i++) {
                                this.droppedItems.push({
                                    x: tree.x + (Math.random() - 0.5) * 4,
                                    y: tree.y - 3,
                                    z: tree.z + (Math.random() - 0.5) * 4,
                                    type: 'apple',
                                    count: 1,
                                    bobPhase: Math.random() * Math.PI * 2
                                });
                            }
                        }
                    }
                }
                
                // Generate buildings
                this.generateBuildings(worldSize);
                
                // Generate ONE Ritual Temple in a random far location
                let templeX, templeZ;
                do {
                    templeX = Math.floor(Math.random() * (worldSize - 20)) + 15;
                    templeZ = Math.floor(Math.random() * (worldSize - 20)) + 15;
                    if (Math.random() < 0.5) templeX = -templeX;
                    if (Math.random() < 0.5) templeZ = -templeZ;
                } while (Math.abs(templeX) < 20 || Math.abs(templeZ) < 20);
                
                const templeKey = `${templeX},${templeZ}`;
                const templeHeight = heightMap[templeKey] || baseHeight;
                this.generateRitualTemple(templeX, templeHeight + 1, templeZ);
                
                // Initialize birds
                this.initBirds();
                this.initPestBirds();
            },
            
            generateBuildings(worldSize) {
                // Building types
                const buildingTypes = ['church', 'house1', 'house2', 'house3', 'grocery', 'wcdonalds'];
                
                // Quadrant-based generation: 2-6 buildings per 25x25 area
                const quadrantSize = 25;
                let wcdonaldsPlaced = false;
                
                for (let qx = -Math.floor(worldSize / quadrantSize); qx <= Math.floor(worldSize / quadrantSize); qx++) {
                    for (let qz = -Math.floor(worldSize / quadrantSize); qz <= Math.floor(worldSize / quadrantSize); qz++) {
                        // Skip center quadrant (spawn area)
                        if (qx === 0 && qz === 0) continue;
                        
                        const minX = qx * quadrantSize;
                        const minZ = qz * quadrantSize;
                        
                        // 2-6 buildings per quadrant
                        const numBuildings = 2 + Math.floor(Math.random() * 5);
                        
                        for (let i = 0; i < numBuildings; i++) {
                            const bx = minX + 3 + Math.floor(Math.random() * (quadrantSize - 6));
                            const bz = minZ + 3 + Math.floor(Math.random() * (quadrantSize - 6));
                            
                            // Force WcDonald's if not placed yet and this is a good spot
                            if (!wcdonaldsPlaced && Math.random() < 0.3) {
                                if (this.tryPlaceBuilding(bx, bz, ['wcdonalds'])) {
                                    wcdonaldsPlaced = true;
                                    continue;
                                }
                            }
                            
                            this.tryPlaceBuilding(bx, bz, buildingTypes);
                        }
                    }
                }
                
                // Guarantee at least one WcDonald's if not placed
                if (!wcdonaldsPlaced) {
                    for (let attempts = 0; attempts < 50; attempts++) {
                        const bx = 25 + Math.floor(Math.random() * 20);
                        const bz = 25 + Math.floor(Math.random() * 20);
                        if (this.tryPlaceBuilding(bx, bz, ['wcdonalds'])) {
                            break;
                        }
                    }
                }
            },
            
            tryPlaceBuilding(x, z, buildingTypes) {
                const groundY = this.getHighestBlock(x, z);
                if (!groundY || groundY < 7) return false;
                
                const block = this.getBlock(x, groundY, z);
                if (block === 'water' || block === 'sand') return false;
                
                // Quick flatness check
                const h1 = this.getHighestBlock(x + 3, z) || groundY;
                const h2 = this.getHighestBlock(x - 3, z) || groundY;
                const h3 = this.getHighestBlock(x, z + 3) || groundY;
                const h4 = this.getHighestBlock(x, z - 3) || groundY;
                if (Math.max(Math.abs(h1 - groundY), Math.abs(h2 - groundY), Math.abs(h3 - groundY), Math.abs(h4 - groundY)) > 2) return false;
                
                // Check overlap
                for (const b of this.buildings) {
                    if (Math.sqrt((x - b.x) ** 2 + (z - b.z) ** 2) < 15) return false;
                }
                
                const type = buildingTypes[Math.floor(Math.random() * buildingTypes.length)];
                const baseY = groundY + 1;
                
                this.buildings.push({ x, z, type, y: baseY });
                
                switch (type) {
                    case 'church': this.generateChurch(x, baseY, z); break;
                    case 'house1': this.generateHouse1(x, baseY, z); break;
                    case 'house2': this.generateHouse2(x, baseY, z); break;
                    case 'house3': this.generateHouse3(x, baseY, z); break;
                    case 'grocery': this.generateGrocery(x, baseY, z); break;
                    case 'wcdonalds': this.generateWcDonalds(x, baseY, z); break;
                }
                return true;
            },
            
            // Ruined Church - tall with steeple and intact cross
            generateChurch(x, y, z) {
                const w = 7, d = 12, h = 8;
                const ruinFactor = 0.3; // 30% of blocks are missing
                
                // Floor
                for (let dx = 0; dx < w; dx++) {
                    for (let dz = 0; dz < d; dz++) {
                        this.setBlock(x + dx, y - 1, z + dz, 'stone');
                    }
                }
                
                // Walls with random holes
                for (let dx = 0; dx < w; dx++) {
                    for (let dz = 0; dz < d; dz++) {
                        for (let dy = 0; dy < h; dy++) {
                            const isWall = dx === 0 || dx === w - 1 || dz === 0 || dz === d - 1;
                            if (isWall && Math.random() > ruinFactor) {
                                // Door opening
                                if (dz === d - 1 && dx >= 2 && dx <= 4 && dy < 3) continue;
                                // Window openings
                                if ((dx === 0 || dx === w - 1) && dy >= 2 && dy <= 4 && (dz === 3 || dz === 8)) continue;
                                this.setBlock(x + dx, y + dy, z + dz, 'stone');
                            }
                        }
                    }
                }
                
                // Steeple (partially collapsed but supporting structure for cross)
                const steepleX = x + 3, steepleZ = z + 2;
                for (let dy = h; dy < h + 5; dy++) {
                    // Main pillar always intact to support cross
                    this.setBlock(steepleX, y + dy, steepleZ, 'stone');
                    if (dy < h + 3) {
                        // Side supports may be ruined
                        if (Math.random() > ruinFactor) {
                            this.setBlock(steepleX + 1, y + dy, steepleZ, 'stone');
                        }
                        if (Math.random() > ruinFactor) {
                            this.setBlock(steepleX - 1, y + dy, steepleZ, 'stone');
                        }
                    }
                }
                
                // CROSS - Always intact! (This identifies it as a church)
                const crossY = y + h + 5;
                // Vertical part of cross
                this.setBlock(steepleX, crossY, steepleZ, 'stone');
                this.setBlock(steepleX, crossY + 1, steepleZ, 'stone');
                this.setBlock(steepleX, crossY + 2, steepleZ, 'stone');
                // Horizontal part of cross
                this.setBlock(steepleX - 1, crossY + 1, steepleZ, 'stone');
                this.setBlock(steepleX + 1, crossY + 1, steepleZ, 'stone');
            },
            
            // Small cottage house
            generateHouse1(x, y, z) {
                const w = 5, d = 6, h = 4;
                const ruinFactor = 0.25;
                
                // Floor
                for (let dx = 0; dx < w; dx++) {
                    for (let dz = 0; dz < d; dz++) {
                        this.setBlock(x + dx, y - 1, z + dz, 'wood');
                    }
                }
                
                // Walls (wood)
                for (let dx = 0; dx < w; dx++) {
                    for (let dz = 0; dz < d; dz++) {
                        for (let dy = 0; dy < h; dy++) {
                            const isWall = dx === 0 || dx === w - 1 || dz === 0 || dz === d - 1;
                            if (isWall && Math.random() > ruinFactor) {
                                // Door
                                if (dz === d - 1 && dx === 2 && dy < 2) continue;
                                // Window
                                if (dx === 0 && dy === 1 && dz === 2) continue;
                                this.setBlock(x + dx, y + dy, z + dz, 'wood');
                            }
                        }
                    }
                }
                
                // Roof (leaves - like thatch)
                for (let dx = -1; dx <= w; dx++) {
                    for (let dz = 0; dz < d; dz++) {
                        if (Math.random() > ruinFactor) {
                            this.setBlock(x + dx, y + h, z + dz, 'leaves');
                        }
                    }
                }
            },
            
            // Two-story house
            generateHouse2(x, y, z) {
                const w = 6, d = 7, h = 6;
                const ruinFactor = 0.3;
                
                // Foundation
                for (let dx = 0; dx < w; dx++) {
                    for (let dz = 0; dz < d; dz++) {
                        this.setBlock(x + dx, y - 1, z + dz, 'stone');
                    }
                }
                
                // Brick walls
                for (let dx = 0; dx < w; dx++) {
                    for (let dz = 0; dz < d; dz++) {
                        for (let dy = 0; dy < h; dy++) {
                            const isWall = dx === 0 || dx === w - 1 || dz === 0 || dz === d - 1;
                            if (isWall && Math.random() > ruinFactor) {
                                // Door
                                if (dz === d - 1 && dx >= 2 && dx <= 3 && dy < 2) continue;
                                // Windows
                                if ((dx === 0 || dx === w - 1) && (dy === 1 || dy === 4) && (dz === 2 || dz === 4)) continue;
                                this.setBlock(x + dx, y + dy, z + dz, 'brick');
                            }
                        }
                    }
                }
                
                // Floor between stories
                for (let dx = 1; dx < w - 1; dx++) {
                    for (let dz = 1; dz < d - 1; dz++) {
                        if (Math.random() > ruinFactor * 2) {
                            this.setBlock(x + dx, y + 3, z + dz, 'wood');
                        }
                    }
                }
            },
            
            // L-shaped house
            generateHouse3(x, y, z) {
                const ruinFactor = 0.35;
                
                // Main section
                for (let dx = 0; dx < 5; dx++) {
                    for (let dz = 0; dz < 8; dz++) {
                        this.setBlock(x + dx, y - 1, z + dz, 'stone');
                        for (let dy = 0; dy < 4; dy++) {
                            const isWall = dx === 0 || dx === 4 || dz === 0 || dz === 7;
                            if (isWall && Math.random() > ruinFactor) {
                                if (dz === 7 && dx === 2 && dy < 2) continue; // Door
                                this.setBlock(x + dx, y + dy, z + dz, 'brick');
                            }
                        }
                    }
                }
                
                // L extension
                for (let dx = 5; dx < 9; dx++) {
                    for (let dz = 0; dz < 5; dz++) {
                        this.setBlock(x + dx, y - 1, z + dz, 'stone');
                        for (let dy = 0; dy < 4; dy++) {
                            const isWall = dx === 8 || dz === 0 || dz === 4 || (dx === 5 && dz > 4);
                            if (isWall && Math.random() > ruinFactor) {
                                this.setBlock(x + dx, y + dy, z + dz, 'brick');
                            }
                        }
                    }
                }
            },
            
            // Abandoned grocery store
            generateGrocery(x, y, z) {
                const w = 10, d = 8, h = 4;
                const ruinFactor = 0.25;
                
                // Concrete floor
                for (let dx = 0; dx < w; dx++) {
                    for (let dz = 0; dz < d; dz++) {
                        this.setBlock(x + dx, y - 1, z + dz, 'stone');
                    }
                }
                
                // Walls
                for (let dx = 0; dx < w; dx++) {
                    for (let dz = 0; dz < d; dz++) {
                        for (let dy = 0; dy < h; dy++) {
                            const isWall = dx === 0 || dx === w - 1 || dz === 0 || dz === d - 1;
                            if (isWall && Math.random() > ruinFactor) {
                                // Wide entrance
                                if (dz === d - 1 && dx >= 3 && dx <= 6 && dy < 3) continue;
                                // Windows (front)
                                if (dz === d - 1 && (dx === 1 || dx === 8) && dy >= 1 && dy <= 2) continue;
                                this.setBlock(x + dx, y + dy, z + dz, 'stone');
                            }
                        }
                    }
                }
                
                // Shelving units (partial)
                for (let row = 0; row < 2; row++) {
                    for (let dz = 2; dz < 6; dz++) {
                        if (Math.random() > 0.4) {
                            this.setBlock(x + 3 + row * 3, y, z + dz, 'wood');
                            if (Math.random() > 0.5) {
                                this.setBlock(x + 3 + row * 3, y + 1, z + dz, 'wood');
                            }
                        }
                    }
                }
                
                // "GROCERY" sign (just some blocks on roof)
                for (let dx = 2; dx < 8; dx++) {
                    if (Math.random() > 0.3) {
                        this.setBlock(x + dx, y + h, z + d - 1, 'stone');
                    }
                }
            },
            
            // WcDonald's - the knockoff! (W instead of M, same colors)
            generateWcDonalds(x, y, z) {
                const w = 9, d = 9, h = 4;
                const ruinFactor = 0.2;
                
                // FIRST: Clear interior space (remove any terrain blocks inside building)
                for (let dx = 1; dx < w - 1; dx++) {
                    for (let dz = 1; dz < d - 1; dz++) {
                        for (let dy = 0; dy < h + 2; dy++) {
                            const existingBlock = this.getBlock(x + dx, y + dy, z + dz);
                            // Remove any solid non-air blocks inside
                            if (existingBlock && existingBlock !== 'water' && existingBlock !== 'lava') {
                                this.setBlock(x + dx, y + dy, z + dz, null);
                            }
                        }
                    }
                }
                
                // Red foundation/floor
                for (let dx = 0; dx < w; dx++) {
                    for (let dz = 0; dz < d; dz++) {
                        this.setBlock(x + dx, y - 1, z + dz, 'brick'); // Red brick as red
                    }
                }
                
                // Walls (mix of brick and stone for that fast food look)
                for (let dx = 0; dx < w; dx++) {
                    for (let dz = 0; dz < d; dz++) {
                        for (let dy = 0; dy < h; dy++) {
                            const isWall = dx === 0 || dx === w - 1 || dz === 0 || dz === d - 1;
                            if (isWall && Math.random() > ruinFactor) {
                                // Double door entrance
                                if (dz === d - 1 && dx >= 3 && dx <= 5 && dy < 3) continue;
                                // Drive-thru window
                                if (dx === w - 1 && dz >= 2 && dz <= 4 && dy === 1) continue;
                                // Use brick for bottom, stone for top
                                this.setBlock(x + dx, y + dy, z + dz, dy < 2 ? 'brick' : 'stone');
                            }
                        }
                    }
                }
                
                // The famous "W" arches (golden... well, sand-colored)
                // W shape using sand blocks (yellow-ish) - ALWAYS SOLID, no ruin
                const wX = x + 4;
                const wZ = z + d;
                const wY = y + h;
                
                // Build the W shape - guaranteed to always appear
                // Left vertical leg
                this.setBlock(wX - 2, wY, wZ, 'sand');
                this.setBlock(wX - 2, wY + 1, wZ, 'sand');
                this.setBlock(wX - 2, wY + 2, wZ, 'sand');
                this.setBlock(wX - 2, wY + 3, wZ, 'sand');
                
                // Left diagonal down to center
                this.setBlock(wX - 1, wY, wZ, 'sand');
                this.setBlock(wX - 1, wY + 1, wZ, 'sand');
                
                // Center bottom (the V dip)
                this.setBlock(wX, wY, wZ, 'sand');
                
                // Right diagonal up from center  
                this.setBlock(wX + 1, wY, wZ, 'sand');
                this.setBlock(wX + 1, wY + 1, wZ, 'sand');
                
                // Right vertical leg
                this.setBlock(wX + 2, wY, wZ, 'sand');
                this.setBlock(wX + 2, wY + 1, wZ, 'sand');
                this.setBlock(wX + 2, wY + 2, wZ, 'sand');
                this.setBlock(wX + 2, wY + 3, wZ, 'sand');
                
                // Counter inside
                for (let dx = 2; dx < 7; dx++) {
                    if (Math.random() > 0.3) {
                        this.setBlock(x + dx, y, z + 2, 'brick');
                    }
                }
                
                // Some tables (wood blocks)
                if (Math.random() > 0.4) this.setBlock(x + 2, y, z + 5, 'wood');
                if (Math.random() > 0.4) this.setBlock(x + 6, y, z + 5, 'wood');
                if (Math.random() > 0.4) this.setBlock(x + 4, y, z + 6, 'wood');
                
                // Special WcDonalds chest behind counter - may contain the legendary Berdger!
                this.setBlock(x + 4, y, z + 1, 'buildingChest');
                this.chestContents = this.chestContents || {};
                const chestKey = `${x + 4},${y},${z + 1}`;
                // 30% chance for berdger, otherwise seeds
                if (Math.random() < 0.3) {
                    this.chestContents[chestKey] = [{ type: 'berdger', count: 1 }];
                } else {
                    this.chestContents[chestKey] = [{ type: 'seeds', count: 3 + Math.floor(Math.random() * 5) }];
                }
            },
            
            getHighestBlock(x, z) {
                for (let y = 30; y >= 0; y--) {
                    if (this.getBlock(x, y, z)) return y;
                }
                return null;
            },
            
            initBirds() {
                this.birds = [];
                const numBirds = 12; // Good number for small world
                
                for (let i = 0; i < numBirds; i++) {
                    this.birds.push({
                        x: (Math.random() - 0.5) * 80,
                        y: 15 + Math.random() * 10,
                        z: (Math.random() - 0.5) * 80,
                        // Movement pattern
                        baseY: 15 + Math.random() * 10,
                        angle: Math.random() * Math.PI * 2,
                        radius: 5 + Math.random() * 15,
                        speed: 0.01 + Math.random() * 0.02,
                        wobble: Math.random() * Math.PI * 2,
                        wobbleSpeed: 0.05 + Math.random() * 0.05,
                        // Visual
                        wingPhase: Math.random() * Math.PI * 2,
                        size: 0.3 + Math.random() * 0.2
                    });
                }
            },
            
            // Initialize pest birds (small annoying birds that follow player)
            initPestBirds() {
                this.pestBirds = [];
                const numPests = 3;
                
                for (let i = 0; i < numPests; i++) {
                    this.pestBirds.push({
                        x: 0, y: 12, z: 0,
                        // Velocity for knockback
                        vx: 0, vy: 0, vz: 0,
                        // Target offset from player
                        targetOffsetX: 0,
                        targetOffsetY: 0,
                        targetOffsetZ: 0,
                        // Behavior state
                        state: 'circling', // 'circling', 'swooping', 'retreating', 'hovering', 'knockback'
                        stateTimer: Math.random() * 100,
                        // Movement
                        angle: (i / numPests) * Math.PI * 2, // Spread them out
                        circleRadius: 2 + Math.random(),
                        baseCircleRadius: 2 + Math.random(),
                        circleSpeed: 0.08 + Math.random() * 0.04,
                        swoopProgress: 0,
                        // Visual
                        wingPhase: Math.random() * Math.PI * 2,
                        size: 0.15 + Math.random() * 0.05, // Smaller than regular birds
                        chirpTimer: Math.random() * 60,
                        knockbackSpin: 0,
                        // Anger system - gets angrier when shot
                        anger: 0,           // 0-5 anger level
                        timesShot: 0,       // How many times this bird has been shot
                        spawnThreshold: 4 + Math.floor(Math.random() * 4)  // 4-7 shots to spawn reinforcements
                    });
                }
            },
            
            updatePestBirds() {
                const playerX = this.camera.x;
                const playerY = this.camera.y;
                const playerZ = this.camera.z;
                
                // Check for seed calming effect
                if (!this.seedCalmTimer) this.seedCalmTimer = 0;
                if (this.seedCalmTimer > 0) {
                    this.seedCalmTimer--;
                }
                const birdsCalmed = this.seedCalmTimer > 0;
                
                // Prune excess birds every ~30 seconds (1800 frames at 60fps)
                if (!this.birdPruneTimer) this.birdPruneTimer = 0;
                this.birdPruneTimer++;
                if (this.birdPruneTimer >= 1800) {
                    this.birdPruneTimer = 0;
                    if (this.pestBirds.length > 15) {
                        // Keep the 15 angriest birds
                        this.pestBirds.sort((a, b) => b.anger - a.anger);
                        this.pestBirds = this.pestBirds.slice(0, 15);
                    }
                }
                
                for (const pest of this.pestBirds) {
                    // Handle rage mode timer
                    if (pest.rageMode && pest.rageTimer) {
                        pest.rageTimer--;
                        if (pest.rageTimer <= 0) {
                            pest.rageMode = false;
                            pest.speed = 0.06; // Reset to normal speed
                        }
                    }
                    
                    // Rage mode makes birds more aggressive
                    
                    // Wind affects all bird movement
                    if (this.wind && pest.state !== 'knockback') {
                        pest.x += this.wind.x * 0.5;
                        pest.z += this.wind.z * 0.5;
                    }
                    
                    // If calmed by seeds, birds retreat and become passive
                    if (birdsCalmed && pest.state !== 'knockback') {
                        pest.state = 'retreating';
                        pest.stateTimer = Math.max(pest.stateTimer, 60);
                        pest.anger = Math.max(0, pest.anger - 0.01); // Slowly calm down
                    }
                    
                    pest.stateTimer--;
                    
                    // Anger affects wing flap speed
                    const angerWingBonus = pest.anger * 0.1;
                    pest.wingPhase += (pest.state === 'knockback' ? 0.8 : 0.5) + angerWingBonus;
                    pest.chirpTimer--;
                    
                    // Calculate anger-based multipliers
                    const angerSpeedMult = 1 + pest.anger * 0.3;      // Up to 2.5x faster at max anger
                    const angerRadiusMult = 1 - pest.anger * 0.1;    // Gets closer when angry (down to 0.5x)
                    const angerSwoopChance = 0.3 + pest.anger * 0.15; // Up to 0.9 swoop chance at max anger
                    
                    // Handle knockback state with physics including wall ricochet
                    if (pest.state === 'knockback') {
                        // Store previous position for collision detection
                        const prevX = pest.x, prevY = pest.y, prevZ = pest.z;
                        
                        // Apply velocity
                        pest.x += pest.vx;
                        pest.y += pest.vy;
                        pest.z += pest.vz;
                        
                        // WALL COLLISION AND RICOCHET
                        const birdBlock = this.getBlock(Math.floor(pest.x), Math.floor(pest.y), Math.floor(pest.z));
                        if (birdBlock && birdBlock !== 'water' && birdBlock !== 'lava') {
                            // Hit a block - check which face and ricochet
                            const isLeaves = birdBlock.includes('Leaves') || birdBlock.includes('leaves');
                            
                            if (isLeaves) {
                                // Leaves catch birds and slow them significantly
                                pest.vx *= 0.4;
                                pest.vy *= 0.4;
                                pest.vz *= 0.4;
                                pest.stateTimer = Math.min(pest.stateTimer, 90); // Stuck briefly
                                pest.caughtInLeaves = true;
                            } else {
                                // Solid block - ricochet with energy loss
                                const blockX = Math.floor(pest.x);
                                const blockY = Math.floor(pest.y);
                                const blockZ = Math.floor(pest.z);
                                
                                // Determine which face was hit and bounce
                                if (!this.getBlock(blockX, Math.floor(prevY), Math.floor(prevZ))) {
                                    pest.vx *= -0.7; // X wall hit
                                    pest.x = prevX;
                                } else if (!this.getBlock(Math.floor(prevX), blockY, Math.floor(prevZ))) {
                                    pest.vy *= -0.7; // Y wall/floor/ceiling hit
                                    pest.y = prevY;
                                } else if (!this.getBlock(Math.floor(prevX), Math.floor(prevY), blockZ)) {
                                    pest.vz *= -0.7; // Z wall hit
                                    pest.z = prevZ;
                                } else {
                                    // Corner - reverse all
                                    pest.vx *= -0.5;
                                    pest.vy *= -0.5;
                                    pest.vz *= -0.5;
                                    pest.x = prevX; pest.y = prevY; pest.z = prevZ;
                                }
                                
                                // Add ricochet particle
                                this.particles.push({
                                    x: pest.x, y: pest.y, z: pest.z,
                                    vx: (Math.random() - 0.5) * 0.1,
                                    vy: Math.random() * 0.1,
                                    vz: (Math.random() - 0.5) * 0.1,
                                    life: 20, type: 'spark', size: 2
                                });
                            }
                        }
                        
                        // If caught in leaves, slowly release
                        if (pest.caughtInLeaves) {
                            pest.vx *= 0.9;
                            pest.vy *= 0.9;
                            pest.vz *= 0.9;
                            pest.vy += 0.01; // Slowly float up out of tree
                            if (Math.abs(pest.vx) < 0.01 && Math.abs(pest.vz) < 0.01) {
                                pest.caughtInLeaves = false;
                            }
                        } else {
                            // Normal drag and gravity
                            pest.vx *= 0.95;
                            pest.vy *= 0.95;
                            pest.vy -= 0.01; // Gravity
                            pest.vz *= 0.95;
                        }
                        
                        // Spin animation
                        pest.knockbackSpin += 0.3;
                        
                        // Recover when velocity is low enough - angrier birds recover faster
                        const speed = Math.sqrt(pest.vx * pest.vx + pest.vy * pest.vy + pest.vz * pest.vz);
                        const recoveryThreshold = 0.05 + pest.anger * 0.02;
                        if (speed < recoveryThreshold || pest.stateTimer <= 0) {
                            // Getting shot makes the bird ANGRIER!
                            pest.anger = Math.min(5, pest.anger + 1);
                            pest.timesShot++;
                            
                            // Spawn reinforcements when threshold reached
                            if (pest.timesShot === pest.spawnThreshold && this.pestBirds.length < 15) {
                                const numToSpawn = 2 + Math.floor(Math.random() * 2); // 2-3 new birds
                                for (let i = 0; i < numToSpawn; i++) {
                                    const newAngle = Math.random() * Math.PI * 2;
                                    const newRadius = 3 + Math.random() * 2;
                                    this.pestBirds.push({
                                        x: this.camera.x + Math.cos(newAngle) * newRadius,
                                        y: this.camera.y + 1 + Math.random(),
                                        z: this.camera.z + Math.sin(newAngle) * newRadius,
                                        vx: 0, vy: 0, vz: 0,
                                        targetOffsetX: 0, targetOffsetY: 0, targetOffsetZ: 0,
                                        state: 'circling',
                                        stateTimer: 20 + Math.random() * 30,
                                        angle: newAngle,
                                        circleRadius: newRadius,
                                        baseCircleRadius: newRadius,
                                        circleSpeed: 0.06 + Math.random() * 0.04,
                                        swoopProgress: 0,
                                        wingPhase: Math.random() * Math.PI * 2,
                                        size: 0.2 + Math.random() * 0.05,
                                        chirpTimer: Math.random() * 60,
                                        knockbackSpin: 0,
                                        anger: 2 + Math.floor(Math.random() * 2), // Spawned already angry (2-3)
                                        timesShot: 0,
                                        spawnThreshold: 4 + Math.floor(Math.random() * 4)
                                    });
                                }
                            }
                            
                            pest.state = 'retreating';
                            pest.stateTimer = Math.max(30, 120 - pest.anger * 20); // Shorter retreat when angry
                            pest.circleRadius = (pest.baseCircleRadius + 4) * angerRadiusMult;
                            pest.vx = pest.vy = pest.vz = 0;
                            pest.knockbackSpin = 0;
                            pest.caughtInLeaves = false;
                        }
                        continue; // Skip normal movement
                    }
                    
                    // State machine for pest behavior
                    switch (pest.state) {
                        case 'circling':
                            // Circle around player's head - faster and closer when angry
                            pest.angle += pest.circleSpeed * angerSpeedMult;
                            pest.targetOffsetX = Math.cos(pest.angle) * pest.circleRadius * angerRadiusMult;
                            pest.targetOffsetZ = Math.sin(pest.angle) * pest.circleRadius * angerRadiusMult;
                            pest.targetOffsetY = 0.5 + Math.sin(pest.angle * 2) * 0.3;
                            
                            // Gradually return to base radius
                            pest.circleRadius += (pest.baseCircleRadius - pest.circleRadius) * 0.01;
                            
                            // Randomly decide to swoop - more likely when angry
                            if (pest.stateTimer <= 0) {
                                if (Math.random() < angerSwoopChance) {
                                    pest.state = 'swooping';
                                    pest.swoopProgress = 0;
                                    pest.stateTimer = 60;
                                } else if (Math.random() < 0.2) {
                                    pest.state = 'hovering';
                                    pest.stateTimer = Math.max(20, 40 - pest.anger * 5) + Math.random() * 40;
                                } else {
                                    pest.stateTimer = Math.max(15, 30 - pest.anger * 5) + Math.random() * 60;
                                }
                            }
                            break;
                            
                        case 'swooping':
                            // Dive at the player's face! Faster when angry
                            pest.swoopProgress += 0.05 * angerSpeedMult;
                            const swoopT = pest.swoopProgress;
                            
                            if (swoopT < 0.5) {
                                // Diving in
                                pest.targetOffsetX = Math.cos(pest.angle) * pest.circleRadius * (1 - swoopT * 2);
                                pest.targetOffsetZ = Math.sin(pest.angle) * pest.circleRadius * (1 - swoopT * 2);
                                pest.targetOffsetY = 0.5 - swoopT;
                            } else {
                                // Pulling away
                                const pullT = (swoopT - 0.5) * 2;
                                pest.targetOffsetX = Math.cos(pest.angle) * pest.circleRadius * pullT;
                                pest.targetOffsetZ = Math.sin(pest.angle) * pest.circleRadius * pullT;
                                pest.targetOffsetY = -0.5 + pullT;
                            }
                            
                            if (pest.swoopProgress >= 1) {
                                pest.state = 'retreating';
                                pest.stateTimer = 30;
                            }
                            break;
                            
                        case 'retreating':
                            // Back off temporarily
                            pest.angle += pest.circleSpeed * 0.5;
                            const retreatDist = pest.circleRadius + 2;
                            pest.targetOffsetX = Math.cos(pest.angle) * retreatDist;
                            pest.targetOffsetZ = Math.sin(pest.angle) * retreatDist;
                            pest.targetOffsetY = 1 + Math.sin(pest.angle * 3) * 0.2;
                            
                            // Gradually return to base radius
                            pest.circleRadius += (pest.baseCircleRadius - pest.circleRadius) * 0.02;
                            
                            if (pest.stateTimer <= 0) {
                                pest.state = 'circling';
                                pest.stateTimer = 60 + Math.random() * 60;
                            }
                            break;
                            
                        case 'hovering':
                            // Hover annoyingly in front of player's face
                            const hoverAngle = Math.sin(Date.now() * 0.01) * 0.3;
                            pest.targetOffsetX = Math.sin(this.camera.rotY + hoverAngle) * -1.5;
                            pest.targetOffsetZ = Math.cos(this.camera.rotY + hoverAngle) * -1.5;
                            pest.targetOffsetY = 0.2 + Math.sin(Date.now() * 0.02) * 0.1;
                            
                            if (pest.stateTimer <= 0) {
                                pest.state = 'circling';
                                pest.stateTimer = 80 + Math.random() * 40;
                            }
                            break;
                    }
                    
                    // Smoothly move toward target position with max speed cap
                    const targetX = playerX + pest.targetOffsetX;
                    const targetY = playerY + pest.targetOffsetY;
                    const targetZ = playerZ + pest.targetOffsetZ;
                    
                    const smoothing = pest.state === 'swooping' ? 0.15 : 0.08;
                    let dx = (targetX - pest.x) * smoothing;
                    let dy = (targetY - pest.y) * smoothing;
                    let dz = (targetZ - pest.z) * smoothing;
                    
                    // Cap maximum speed so player can outrun angry birds
                    // Player moves at ~0.1 per frame when running, birds max at 0.08
                    // Rage mode allows birds to match player speed temporarily
                    const baseMaxSpeed = 0.08;
                    const maxBirdSpeed = pest.rageMode ? 0.12 : baseMaxSpeed; // Rage birds can be faster!
                    const moveSpeed = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    if (moveSpeed > maxBirdSpeed) {
                        const scale = maxBirdSpeed / moveSpeed;
                        dx *= scale;
                        dy *= scale;
                        dz *= scale;
                    }
                    
                    pest.x += dx;
                    pest.y += dy;
                    pest.z += dz;
                }
            },
            
            updateBirds() {
                for (const bird of this.birds) {
                    // Handle swarm mode timer
                    if (bird.swarmMode && bird.swarmTimer) {
                        bird.swarmTimer--;
                        if (bird.swarmTimer <= 0) {
                            bird.swarmMode = false;
                        }
                    }
                    
                    // Swarm mode: birds converge on player
                    if (bird.swarmMode) {
                        // Move towards player
                        const dx = this.camera.x - bird.x;
                        const dy = this.camera.y - bird.y;
                        const dz = this.camera.z - bird.z;
                        const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                        
                        if (dist > 3) {
                            bird.x += (dx / dist) * 0.15;
                            bird.y += (dy / dist) * 0.1;
                            bird.z += (dz / dist) * 0.15;
                        } else {
                            // Circle close to player
                            bird.angle += 0.1;
                            bird.x = this.camera.x + Math.cos(bird.angle) * 3;
                            bird.z = this.camera.z + Math.sin(bird.angle) * 3;
                            bird.y = this.camera.y + Math.sin(bird.wobble) * 0.5;
                        }
                        
                        bird.wobble += bird.wobbleSpeed * 2;
                        bird.wingPhase += 0.5; // Faster flapping
                    } else {
                        // Normal flight pattern
                        // Circular flight pattern with wobble
                        bird.angle += bird.speed;
                        bird.wobble += bird.wobbleSpeed;
                        
                        // Center point slowly drifts
                        const centerX = Math.sin(bird.angle * 0.1) * 20;
                        const centerZ = Math.cos(bird.angle * 0.1) * 20;
                        
                        // Base position
                        let bx = centerX + Math.cos(bird.angle) * bird.radius;
                        let bz = centerZ + Math.sin(bird.angle) * bird.radius;
                        
                        // Wind affects bird position
                        if (this.wind) {
                            bx += this.wind.x * 15;
                            bz += this.wind.z * 15;
                        }
                        
                        bird.x = bx;
                        bird.z = bz;
                        bird.y = bird.baseY + Math.sin(bird.wobble) * 2;
                        
                        // Wing flapping
                        bird.wingPhase += 0.3;
                    }
                }
                
                // Also update pest birds
                this.updatePestBirds();
                
                // Update other mobs
                this.updateBlueBirds();
                this.updateFish();
                this.updateCats();
                this.updateCreepers();
                
                // Friendly birds can drop items
                this.updateFriendlyBirdDrops();
                
                // Update bird event timer
                this.updateBirdEventTimer();
            },
            
            // Blue birds - aggressive birds that knockback player
            updateBlueBirds() {
                if (!this.blueBirds) this.blueBirds = [];
                
                for (let i = this.blueBirds.length - 1; i >= 0; i--) {
                    const bird = this.blueBirds[i];
                    
                    bird.wingPhase += 0.6;
                    if (bird.attackCooldown > 0) bird.attackCooldown--;
                    
                    // Chase player aggressively
                    const dx = this.camera.x - bird.x;
                    const dy = this.camera.y - bird.y;
                    const dz = this.camera.z - bird.z;
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    
                    if (dist > 1.5) {
                        // Move towards player
                        bird.vx += (dx / dist) * 0.02;
                        bird.vy += (dy / dist) * 0.015;
                        bird.vz += (dz / dist) * 0.02;
                    }
                    
                    // Apply velocity with drag
                    bird.x += bird.vx;
                    bird.y += bird.vy;
                    bird.z += bird.vz;
                    bird.vx *= 0.9;
                    bird.vy *= 0.9;
                    bird.vz *= 0.9;
                    
                    // Attack player - knockback
                    if (dist < 2 && bird.attackCooldown <= 0) {
                        // Knockback player slightly
                        this.velocity.x += (this.camera.x - bird.x) * 0.1;
                        this.velocity.y += 0.15;
                        this.velocity.z += (this.camera.z - bird.z) * 0.1;
                        bird.attackCooldown = 60; // 1 second cooldown
                    }
                    
                    // Despawn if too far
                    if (dist > 60) {
                        this.blueBirds.splice(i, 1);
                    }
                }
            },
            
            // Fish in water
            updateFish() {
                if (!this.fish) this.fish = [];
                
                for (let i = this.fish.length - 1; i >= 0; i--) {
                    const fish = this.fish[i];
                    fish.swimPhase += 0.15;
                    
                    // Swim in water
                    const block = this.getBlock(Math.floor(fish.x), Math.floor(fish.y), Math.floor(fish.z));
                    if (block !== 'water') {
                        // Not in water - try to find water
                        fish.vy -= 0.01; // Fall
                    } else {
                        // In water - swim around
                        fish.vx += (Math.random() - 0.5) * 0.01;
                        fish.vz += (Math.random() - 0.5) * 0.01;
                        fish.vy += (Math.random() - 0.5) * 0.005;
                    }
                    
                    fish.x += fish.vx;
                    fish.y += fish.vy;
                    fish.z += fish.vz;
                    fish.vx *= 0.95;
                    fish.vy *= 0.95;
                    fish.vz *= 0.95;
                    
                    // Limit speed
                    const speed = Math.sqrt(fish.vx * fish.vx + fish.vz * fish.vz);
                    if (speed > 0.08) {
                        fish.vx = (fish.vx / speed) * 0.08;
                        fish.vz = (fish.vz / speed) * 0.08;
                    }
                }
            },
            
            // Cats follow player
            updateCats() {
                if (!this.cats) this.cats = [];
                
                for (const cat of this.cats) {
                    cat.walkPhase += 0.1;
                    cat.meowTimer--;
                    
                    const dx = this.camera.x - cat.x;
                    const dz = this.camera.z - cat.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    
                    // Follow player if too far
                    if (dist > cat.followDistance + 2) {
                        cat.state = 'following';
                        cat.vx += (dx / dist) * 0.01;
                        cat.vz += (dz / dist) * 0.01;
                    } else if (dist < cat.followDistance) {
                        cat.state = 'idle';
                    }
                    
                    // Apply movement with ground detection
                    cat.x += cat.vx;
                    cat.z += cat.vz;
                    cat.vx *= 0.85;
                    cat.vz *= 0.85;
                    
                    // Gravity and ground collision
                    cat.vy -= 0.02;
                    cat.y += cat.vy;
                    
                    const groundY = Math.floor(cat.y);
                    if (this.getBlock(Math.floor(cat.x), groundY, Math.floor(cat.z))) {
                        cat.y = groundY + 1;
                        cat.vy = 0;
                    }
                    
                    // Random meow
                    if (cat.meowTimer <= 0) {
                        cat.meowTimer = 200 + Math.random() * 400;
                        // Add meow particle/effect if desired
                    }
                }
            },
            
            // Creepers stalk and explode
            updateCreepers() {
                if (!this.creepers) this.creepers = [];
                
                for (let i = this.creepers.length - 1; i >= 0; i--) {
                    const creeper = this.creepers[i];
                    creeper.walkPhase += 0.08;
                    
                    const dx = this.camera.x - creeper.x;
                    const dz = this.camera.z - creeper.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    
                    if (creeper.state === 'stalking') {
                        // Walk towards player slowly
                        if (dist > 2) {
                            creeper.vx += (dx / dist) * 0.003;
                            creeper.vz += (dz / dist) * 0.003;
                        } else {
                            // Close enough - start fuse!
                            creeper.state = 'fusing';
                            creeper.fuseTimer = 0;
                        }
                    } else if (creeper.state === 'fusing') {
                        creeper.fuseTimer++;
                        
                        // Flash warning
                        creeper.flashing = Math.floor(creeper.fuseTimer / 5) % 2 === 0;
                        
                        if (creeper.fuseTimer >= creeper.fuseMax) {
                            // EXPLODE!
                            this.creeperExplode(creeper);
                            this.creepers.splice(i, 1);
                            continue;
                        }
                        
                        // Player can escape
                        if (dist > 4) {
                            creeper.state = 'stalking';
                            creeper.fuseTimer = 0;
                        }
                    }
                    
                    // Apply movement
                    creeper.x += creeper.vx;
                    creeper.z += creeper.vz;
                    creeper.vx *= 0.9;
                    creeper.vz *= 0.9;
                    
                    // Gravity
                    creeper.vy -= 0.02;
                    creeper.y += creeper.vy;
                    
                    const groundY = Math.floor(creeper.y);
                    if (this.getBlock(Math.floor(creeper.x), groundY, Math.floor(creeper.z))) {
                        creeper.y = groundY + 1;
                        creeper.vy = 0;
                    }
                }
            },
            
            // Creeper explosion
            creeperExplode(creeper) {
                // Launch player
                const dx = this.camera.x - creeper.x;
                const dz = this.camera.z - creeper.z;
                const dist = Math.sqrt(dx * dx + dz * dz);
                if (dist < 6) {
                    const force = (6 - dist) / 6 * 1.5;
                    this.velocity.x += (dx / dist) * force;
                    this.velocity.y += 0.8;
                    this.velocity.z += (dz / dist) * force;
                }
                
                // Explosion particles
                for (let i = 0; i < 30; i++) {
                    this.particles.push({
                        x: creeper.x, y: creeper.y + 0.5, z: creeper.z,
                        vx: (Math.random() - 0.5) * 0.3,
                        vy: Math.random() * 0.3,
                        vz: (Math.random() - 0.5) * 0.3,
                        life: 30 + Math.random() * 20,
                        type: 'explosion',
                        size: 3 + Math.random() * 3
                    });
                }
                
                // Spawn blue bird horde!
                for (let i = 0; i < 5; i++) {
                    this.spawnBlueBird();
                }
                
                // Alert
                if (this.birdEvent) {
                    this.showBirdAlert('ðŸ’¥ CREEPER EXPLODED! Blue birds incoming! ðŸ’¥');
                }
            },
            
            // Friendly birds drop items
            updateFriendlyBirdDrops() {
                if (!this.birdDropTimer) this.birdDropTimer = 0;
                this.birdDropTimer++;
                
                // Every ~10 seconds, chance for friendly bird to drop item
                if (this.birdDropTimer >= 600) {
                    this.birdDropTimer = 0;
                    
                    for (const bird of this.birds) {
                        // 30% chance per bird
                        if (Math.random() < 0.3) {
                            // Determine drop
                            const roll = Math.random();
                            let dropType = 'seeds';
                            let dropCount = 1 + Math.floor(Math.random() * 3);
                            
                            if (roll < 0.05) {
                                // 5% rare item
                                dropType = ['berdger', 'omamori', 'shimenawa'][Math.floor(Math.random() * 3)];
                                dropCount = 1;
                            } else if (roll < 0.2) {
                                // 15% apple
                                dropType = 'apple';
                                dropCount = 1 + Math.floor(Math.random() * 2);
                            }
                            
                            // Drop item near player
                            this.dropItem(
                                bird.x + (Math.random() - 0.5) * 2,
                                bird.y - 2,
                                bird.z + (Math.random() - 0.5) * 2,
                                dropType, dropCount
                            );
                            
                            // Only one drop per cycle
                            break;
                        }
                    }
                }
            },
            
            // Bird event timer system
            updateBirdEventTimer() {
                if (!this.birdEvent) return;
                
                const now = Date.now();
                const delta = now - this.birdEvent.lastUpdate;
                this.birdEvent.lastUpdate = now;
                this.birdEvent.timer -= delta;
                
                // Fade out alerts
                if (this.birdEvent.alertFade > 0) {
                    this.birdEvent.alertFade -= delta;
                    if (this.birdEvent.alertFade <= 0) {
                        this.birdEvent.alertMessage = null;
                    }
                }
                
                const timeLeft = this.birdEvent.timer;
                const nextEvent = this.birdEvent.events[this.birdEvent.currentEvent];
                
                // Show alerts at specific times
                if (timeLeft <= 5 * 60 * 1000 && timeLeft > 4 * 60 * 1000 && !this.birdEvent.alertShown.five) {
                    this.showBirdAlert(`âš ï¸ In 5 minutes, ${nextEvent.description} âš ï¸`);
                    this.birdEvent.alertShown.five = true;
                }
                if (timeLeft <= 3 * 60 * 1000 && timeLeft > 2 * 60 * 1000 && !this.birdEvent.alertShown.three) {
                    this.showBirdAlert(`âš ï¸ In 3 minutes, ${nextEvent.description} âš ï¸`);
                    this.birdEvent.alertShown.three = true;
                }
                if (timeLeft <= 1 * 60 * 1000 && timeLeft > 50 * 1000 && !this.birdEvent.alertShown.one) {
                    this.showBirdAlert(`âš ï¸ In 1 minute, ${nextEvent.description} âš ï¸`);
                    this.birdEvent.alertShown.one = true;
                }
                if (timeLeft <= 30 * 1000 && timeLeft > 20 * 1000 && !this.birdEvent.alertShown.thirty) {
                    this.showBirdAlert(`âš ï¸ In 30 seconds, ${nextEvent.description.toUpperCase()} âš ï¸`);
                    this.birdEvent.alertShown.thirty = true;
                }
                if (timeLeft <= 10 * 1000 && timeLeft > 5 * 1000 && !this.birdEvent.alertShown.ten) {
                    this.showBirdAlert(`ðŸ”¥ In 10 seconds, ${nextEvent.description.toUpperCase()} ðŸ”¥`);
                    this.birdEvent.alertShown.ten = true;
                }
                
                // Trigger event when timer reaches 0
                if (timeLeft <= 0) {
                    this.triggerBirdEvent();
                }
            },
            
            showBirdAlert(message) {
                this.birdEvent.alertMessage = message;
                this.birdEvent.alertFade = 4000; // 4 seconds
            },
            
            triggerBirdEvent() {
                const event = this.birdEvent.events[this.birdEvent.currentEvent];
                this.showBirdAlert(`ðŸ¦ BIRD EVENT: ${event.name}! ðŸ¦`);
                event.action();
                
                // Reset timer and move to next event
                this.birdEvent.timer = 5 * 60 * 1000; // Reset to 5 minutes
                this.birdEvent.currentEvent = (this.birdEvent.currentEvent + 1) % this.birdEvent.events.length;
                this.birdEvent.alertShown = { five: false, three: false, one: false, thirty: false, ten: false };
            },
            
            // Bird Event 1: Swarm - all birds converge on player
            triggerBirdSwarm() {
                // Make all decorative birds become aggressive for 30 seconds
                for (const bird of this.birds) {
                    bird.swarmMode = true;
                    bird.swarmTimer = 30 * 60; // 30 seconds at 60fps
                }
                // Also spawn extra pest birds
                for (let i = 0; i < 5; i++) {
                    this.spawnPestBird();
                }
            },
            
            // Bird Event 2: Rage - pest birds become faster and more aggressive
            triggerBirdRage() {
                // Boost all pest birds
                if (this.pestBirds) {
                    for (const bird of this.pestBirds) {
                        bird.rageMode = true;
                        bird.rageTimer = 45 * 60; // 45 seconds
                        bird.speed = (bird.speed || 0.06) * 1.5;
                    }
                }
                // Spawn some extra angry birds
                for (let i = 0; i < 3; i++) {
                    const bird = this.spawnPestBird();
                    if (bird) {
                        bird.rageMode = true;
                        bird.rageTimer = 45 * 60;
                    }
                }
            },
            
            // Bird Event 3: Multiply - spawn many birds everywhere
            triggerBirdMultiply() {
                // Spawn lots of pest birds at random locations around the player
                for (let i = 0; i < 10; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = 10 + Math.random() * 20;
                    const bird = this.spawnPestBird();
                    if (bird) {
                        bird.x = this.camera.x + Math.cos(angle) * dist;
                        bird.z = this.camera.z + Math.sin(angle) * dist;
                        bird.y = this.camera.y + 5 + Math.random() * 10;
                    }
                }
            },
            
            // Bird Event 4: Creeper Invasion - spawn stalking creepers
            triggerCreeperInvasion() {
                this.showBirdAlert('ðŸ’¥ CREEPERS ARE STALKING YOU! ðŸ’¥');
                // Spawn 2-4 creepers around the player
                const numCreepers = 2 + Math.floor(Math.random() * 3);
                for (let i = 0; i < numCreepers; i++) {
                    this.spawnCreeper();
                }
            },
            
            spawnPestBird() {
                if (!this.pestBirds) this.pestBirds = [];
                const bird = {
                    x: this.camera.x + (Math.random() - 0.5) * 30,
                    y: this.camera.y + 10 + Math.random() * 10,
                    z: this.camera.z + (Math.random() - 0.5) * 30,
                    vx: 0, vy: 0, vz: 0,
                    state: 'hunting',
                    wingPhase: Math.random() * Math.PI * 2,
                    speed: 0.06,
                    angryTimer: 60 * 60 * 5 // 5 minutes
                };
                this.pestBirds.push(bird);
                return bird;
            },
            
            // Spawn blue bird (more aggressive, can knockback player)
            spawnBlueBird() {
                if (!this.blueBirds) this.blueBirds = [];
                const bird = {
                    x: this.camera.x + (Math.random() - 0.5) * 20,
                    y: this.camera.y + 5 + Math.random() * 8,
                    z: this.camera.z + (Math.random() - 0.5) * 20,
                    vx: 0, vy: 0, vz: 0,
                    state: 'aggressive',
                    wingPhase: Math.random() * Math.PI * 2,
                    speed: 0.1, // Faster than normal birds
                    attackCooldown: 0
                };
                this.blueBirds.push(bird);
                return bird;
            },
            
            // Spawn fish in water
            spawnFish() {
                if (!this.fish) this.fish = [];
                // Find water to spawn in
                let waterPos = null;
                for (let attempts = 0; attempts < 50; attempts++) {
                    const x = Math.floor(this.camera.x + (Math.random() - 0.5) * 40);
                    const z = Math.floor(this.camera.z + (Math.random() - 0.5) * 40);
                    for (let y = 20; y >= 0; y--) {
                        if (this.getBlock(x, y, z) === 'water') {
                            waterPos = { x: x + 0.5, y: y + 0.5, z: z + 0.5 };
                            break;
                        }
                    }
                    if (waterPos) break;
                }
                
                if (!waterPos) {
                    // Spawn near player in any case
                    waterPos = { 
                        x: this.camera.x + (Math.random() - 0.5) * 10, 
                        y: 7, 
                        z: this.camera.z + (Math.random() - 0.5) * 10 
                    };
                }
                
                const fish = {
                    x: waterPos.x, y: waterPos.y, z: waterPos.z,
                    vx: (Math.random() - 0.5) * 0.05,
                    vy: 0,
                    vz: (Math.random() - 0.5) * 0.05,
                    swimPhase: Math.random() * Math.PI * 2,
                    color: Math.random() > 0.5 ? '#ff6347' : '#ffd700', // Orange or gold
                    size: 0.3 + Math.random() * 0.2
                };
                this.fish.push(fish);
                return fish;
            },
            
            // Spawn cat that follows player
            spawnCat() {
                if (!this.cats) this.cats = [];
                const cat = {
                    x: this.camera.x + (Math.random() - 0.5) * 10,
                    y: this.camera.y - 1,
                    z: this.camera.z + (Math.random() - 0.5) * 10,
                    vx: 0, vy: 0, vz: 0,
                    state: 'idle',
                    walkPhase: 0,
                    color: ['#ffa500', '#808080', '#000000', '#ffffff'][Math.floor(Math.random() * 4)], // Orange, gray, black, white
                    meowTimer: Math.random() * 300 + 200,
                    followDistance: 3 + Math.random() * 2
                };
                this.cats.push(cat);
                return cat;
            },
            
            // Spawn creeper (explodes, spawns blue birds)
            spawnCreeper() {
                if (!this.creepers) this.creepers = [];
                const creeper = {
                    x: this.camera.x + (Math.random() > 0.5 ? 15 : -15) + (Math.random() - 0.5) * 10,
                    y: this.camera.y,
                    z: this.camera.z + (Math.random() > 0.5 ? 15 : -15) + (Math.random() - 0.5) * 10,
                    vx: 0, vy: 0, vz: 0,
                    state: 'stalking',
                    fuseTimer: 0,
                    fuseMax: 90, // 1.5 seconds fuse
                    walkPhase: 0,
                    health: 3
                };
                this.creepers.push(creeper);
                return creeper;
            },
            
            // Update survival HUD
            updateSurvivalHUD() {
                if (!this.survivalStats) return;
                
                const scoreEl = document.getElementById('scoreDisplay');
                const waveEl = document.getElementById('waveDisplay');
                const objEl = document.getElementById('objectiveDisplay');
                
                if (scoreEl) scoreEl.textContent = `Score: ${this.survivalStats.score}`;
                if (waveEl) waveEl.textContent = `Wave: ${this.survivalStats.wave}`;
                if (objEl && this.survivalStats.currentObjective) {
                    objEl.textContent = `Objective: ${this.survivalStats.currentObjective.text}`;
                }
            },
            
            // Generate Ritual Temple - only one per world
            generateRitualTemple(x, y, z) {
                const w = 11;
                const h = 8;
                const d = 11;
                
                // Mark temple location
                this.ritualTempleLocation = { x, y, z };
                
                // Clear space
                for (let dx = 0; dx < w; dx++) {
                    for (let dz = 0; dz < d; dz++) {
                        for (let dy = 0; dy < h + 2; dy++) {
                            this.setBlock(x + dx, y + dy, z + dz, null);
                        }
                    }
                }
                
                // Floor
                for (let dx = 0; dx < w; dx++) {
                    for (let dz = 0; dz < d; dz++) {
                        this.setBlock(x + dx, y, z + dz, 'ritualStone');
                    }
                }
                
                // Walls
                for (let dy = 1; dy < h; dy++) {
                    for (let dx = 0; dx < w; dx++) {
                        this.setBlock(x + dx, y + dy, z, 'ritualStone');
                        this.setBlock(x + dx, y + dy, z + d - 1, 'ritualStone');
                    }
                    for (let dz = 0; dz < d; dz++) {
                        this.setBlock(x, y + dy, z + dz, 'ritualStone');
                        this.setBlock(x + w - 1, y + dy, z + dz, 'ritualStone');
                    }
                }
                
                // Entrance
                this.setBlock(x + w/2|0, y + 1, z, null);
                this.setBlock(x + w/2|0, y + 2, z, null);
                this.setBlock(x + w/2|0, y + 3, z, null);
                
                // Ritual socket blocks in center (5 sockets for 5 ritual items)
                const cx = x + w/2|0;
                const cz = z + d/2|0;
                
                this.setBlock(cx, y + 1, cz, 'charmSocket');      // Center - Omamori
                this.setBlock(cx - 2, y + 1, cz, 'petalSocket');  // Left - Sakura Petal
                this.setBlock(cx + 2, y + 1, cz, 'ropeSocket');   // Right - Shimenawa
                this.setBlock(cx, y + 1, cz - 2, 'plaqueSocket'); // Back - Ema
                this.setBlock(cx, y + 1, cz + 2, 'incenseSocket'); // Front - Incense
                
                // Glowing pillars
                for (let dy = 1; dy <= 4; dy++) {
                    this.setBlock(x + 2, y + dy, z + 2, 'glowstone');
                    this.setBlock(x + w - 3, y + dy, z + 2, 'glowstone');
                    this.setBlock(x + 2, y + dy, z + d - 3, 'glowstone');
                    this.setBlock(x + w - 3, y + dy, z + d - 3, 'glowstone');
                }
            },
            
            // Generate apple tree with green leaves and chance to drop apples
            generateTree(x, y, z) {
                for (let h = 0; h < 4; h++) {
                    this.setBlock(x, y + h, z, 'wood');
                }
                for (let dx = -2; dx <= 2; dx++) {
                    for (let dz = -2; dz <= 2; dz++) {
                        for (let dy = 3; dy <= 5; dy++) {
                            if (Math.abs(dx) + Math.abs(dz) + Math.abs(dy - 4) < 4) {
                                if (!(dx === 0 && dz === 0 && dy < 4)) {
                                    this.setBlock(x + dx, y + dy, z + dz, 'appleLeaves');
                                }
                            }
                        }
                    }
                }
                // Store apple tree for occasional apple drops
                if (!this.appleTrees) this.appleTrees = [];
                this.appleTrees.push({ x, y: y + 4, z });
            },
            
            // Generate cherry blossom tree (larger, more dramatic)
            generateCherryTree(x, y, z) {
                // Taller trunk with pink-tinted wood
                for (let h = 0; h < 6; h++) {
                    this.setBlock(x, y + h, z, 'cherryWood');
                }
                
                // Wider, more dramatic canopy
                for (let dx = -3; dx <= 3; dx++) {
                    for (let dz = -3; dz <= 3; dz++) {
                        for (let dy = 4; dy <= 8; dy++) {
                            const dist = Math.abs(dx) + Math.abs(dz) + Math.abs(dy - 6);
                            if (dist < 5 && Math.random() > 0.15) {
                                if (!(dx === 0 && dz === 0 && dy < 5)) {
                                    this.setBlock(x + dx, y + dy, z + dz, 'cherryLeaves');
                                }
                            }
                        }
                    }
                }
                
                // Store tree location for petal spawning
                this.cherryTrees.push({ x, y: y + 6, z });
            },
            
            setBlock(x, y, z, type) {
                const key = `${x},${y},${z}`;
                if (type === null) {
                    delete this.world[key];
                } else {
                    this.world[key] = type;
                }
            },
            
            getBlock(x, y, z) {
                return this.world[`${x},${y},${z}`] || null;
            },
            
            setupControls() {
                // Keyboard controls
                document.addEventListener('keydown', (e) => {
                    if (!this.isActive) return;
                    
                    if (e.key === 'Escape') {
                        e.preventDefault();
                        
                        // If inventory is open, close it instead of pausing
                        if (this.inventoryOpen) {
                            this.toggleInventory();
                            return;
                        }
                        
                        if (this.isPaused) {
                            this.resume();
                        } else {
                            this.pause();
                        }
                        return;
                    }
                    
                    if (this.isPaused) return;
                    
                    this.keys[e.key.toLowerCase()] = true;
                    
                    // Hotbar selection (1-9)
                    const slotKeys = ['1', '2', '3', '4', '5', '6', '7', '8', '9'];
                    const slotIdx = slotKeys.indexOf(e.key);
                    if (slotIdx !== -1) {
                        this.selectedSlot = slotIdx;
                        const slot = this.inventory.hotbar[slotIdx];
                        if (slot) {
                            if (slot.type === 'block') {
                                this.selectedBlock = slot.id;
                                this.selectedItem = null;
                            } else if (slot.type === 'weapon') {
                                this.selectedItem = slot.id;
                                this.selectedBlock = null;
                            }
                        }
                        this.updateHotbar();
                    }
                    
                    // Toggle inventory with E
                    if (e.key.toLowerCase() === 'e') {
                        this.toggleInventory();
                    }
                    
                    // Drop item with Q
                    if (e.key.toLowerCase() === 'q') {
                        this.dropHeldItem();
                    }
                    
                    // Check ritual with R
                    if (e.key.toLowerCase() === 'r') {
                        if (this.checkRitual()) {
                            console.log('Omamori Ritual Complete! Birds are blessed and calmed.');
                        }
                    }
                    
                    // Toggle debug console with backtick
                    if (e.key === '`' || e.key === '~') {
                        e.preventDefault();
                        this.toggleDebugConsole();
                        return;
                    }
                    
                    // Jump is handled in update() for continuous jumping while holding space
                    
                    e.preventDefault();
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                });
                
                // ===== POINTER LOCK CONTROLS (Industry Standard for Browser FPS) =====
                // Pointer Lock is the ONLY way to truly capture mouse across monitors
                
                this.pointerLocked = false;
                
                // Pointer lock state change handler
                document.addEventListener('pointerlockchange', () => {
                    this.pointerLocked = document.pointerLockElement === this.canvas;
                    
                    if (this.pointerLocked) {
                        // Successfully locked - hide overlay
                        document.getElementById('clickToPlay').classList.remove('active');
                    } else {
                        // Lock released (user pressed ESC or we exited)
                        // If game is active and not paused and inventory is NOT open
                        // and we didn't just close the inventory, pause
                        if (this.isActive && !this.isPaused && !this.inventoryOpen && !this.justClosedInventory) {
                            this.pause();
                        }
                    }
                });
                
                // Pointer lock error handler
                document.addEventListener('pointerlockerror', () => {
                    console.log('Pointer lock failed');
                    // Show the click overlay so user can try again
                    if (this.isActive && !this.isPaused) {
                        document.getElementById('clickToPlay').classList.add('active');
                    }
                });
                
                // Mouse button handler - works during pointer lock
                this.canvas.addEventListener('mousedown', (e) => {
                    if (!this.isActive || this.isPaused) return;
                    
                    // If inventory is open, handle inventory clicks
                    if (this.inventoryOpen) {
                        // TODO: Handle inventory slot clicks
                        return;
                    }
                    
                    // If not locked, any click should request pointer lock
                    if (!this.pointerLocked) {
                        this.canvas.requestPointerLock();
                        return;
                    }
                    
                    if (e.button === 0) {
                        // Left click - BREAK block
                        const hit = this.raycast();
                        if (hit && hit.hit) {
                            const blockType = this.getBlock(hit.hit.x, hit.hit.y, hit.hit.z);
                            
                            // Cannot break water or lava
                            if (blockType === 'water' || blockType === 'lava') {
                                return;
                            }
                            
                            // Helper to check if block is a chest
                            const isChest = (b) => b && (b === 'chest' || b === 'ritualChest' || b === 'buildingChest' || b.toLowerCase().includes('chest'));
                            
                            // Helper to check if block is a socket (indestructible)
                            const isSocket = (b) => b && b.includes('Socket');
                            if (isSocket(blockType)) {
                                return; // Can't break socket blocks
                            }
                            
                            this.setBlock(hit.hit.x, hit.hit.y, hit.hit.z, null);
                            this.stats.blocksBroken++;
                            
                            // Score for breaking blocks
                            if (this.survivalStats) {
                                this.survivalStats.score += 1;
                                this.updateSurvivalHUD();
                            }
                            
                            // Drop the block as an item (if it's a normal block, not chest)
                            if (blockType && !isChest(blockType)) {
                                // Special drops for certain blocks
                                if (blockType === 'appleLeaves') {
                                    // Apple leaves have chance to drop apple
                                    this.dropItem(hit.hit.x + 0.5, hit.hit.y + 0.5, hit.hit.z + 0.5, 'appleLeaves', 1);
                                    if (Math.random() < 0.15) {
                                        this.dropItem(hit.hit.x + 0.5, hit.hit.y + 0.5, hit.hit.z + 0.5, 'apple', 1);
                                    }
                                } else if (blockType === 'cherryLeaves') {
                                    // Cherry leaves have chance to drop sakura petals
                                    this.dropItem(hit.hit.x + 0.5, hit.hit.y + 0.5, hit.hit.z + 0.5, 'cherryLeaves', 1);
                                    if (Math.random() < 0.1) {
                                        this.dropItem(hit.hit.x + 0.5, hit.hit.y + 0.5, hit.hit.z + 0.5, 'sakuraPetal', 1);
                                    }
                                } else {
                                    this.dropItem(hit.hit.x + 0.5, hit.hit.y + 0.5, hit.hit.z + 0.5, blockType, 1);
                                }
                            } else if (isChest(blockType)) {
                                // Breaking a chest drops its contents
                                const chestKey = `${hit.hit.x},${hit.hit.y},${hit.hit.z}`;
                                const contents = this.chestContents && this.chestContents[chestKey];
                                if (contents && Array.isArray(contents)) {
                                    for (const item of contents) {
                                        if (item && item.type) {
                                            this.dropItem(hit.hit.x + 0.5, hit.hit.y + 0.5, hit.hit.z + 0.5, item.type, item.count || 1);
                                        }
                                    }
                                    delete this.chestContents[chestKey];
                                }
                                // Also drop the chest itself
                                this.dropItem(hit.hit.x + 0.5, hit.hit.y + 0.5, hit.hit.z + 0.5, 'chest', 1);
                            }
                        }
                    } else if (e.button === 2) {
                        // Right click - PLACE block, SHOOT, USE item, or interact
                        // First check for chest interaction
                        const hit = this.raycast();
                        if (hit && hit.hit) {
                            const hitBlock = this.getBlock(hit.hit.x, hit.hit.y, hit.hit.z);
                            // Check for any type of chest (case-insensitive)
                            if (hitBlock && (hitBlock === 'chest' || hitBlock === 'ritualChest' || hitBlock === 'buildingChest' || hitBlock.toLowerCase().includes('chest'))) {
                                this.openChest(hit.hit.x, hit.hit.y, hit.hit.z);
                                return;
                            }
                            
                            // Check for ritual socket blocks
                            if (hitBlock && hitBlock.includes('Socket')) {
                                this.interactWithSocket(hit.hit.x, hit.hit.y, hit.hit.z, hitBlock);
                                return;
                            }
                        }
                        
                        // Check held item
                        const heldSlot = this.inventory.hotbar[this.selectedSlot];
                        const heldId = heldSlot ? heldSlot.id : null;
                        
                        if (this.selectedItem === 'ak47') {
                            // Shoot the AK-47!
                            this.shootAK47();
                        } else if (heldId === 'berdger') {
                            // Shoot the Berdger! (infinite burgers)
                            this.shootBerdger();
                        } else if (heldId === 'apple') {
                            // Throw an apple at birds
                            this.throwApple();
                        } else if (heldId === 'seeds') {
                            // Use seeds to calm birds
                            this.useSeeds();
                        } else if (this.selectedItem === 'water_bucket' || this.selectedItem === 'lava_bucket') {
                            // Pour bucket
                            const hit = this.raycast();
                            if (hit && hit.place) {
                                const fluidType = this.selectedItem === 'water_bucket' ? 'water' : 'lava';
                                const placePos = hit.place;
                                
                                // Don't pour inside player
                                const px = Math.floor(this.camera.x);
                                const pz = Math.floor(this.camera.z);
                                const feetY = Math.floor(this.camera.y - this.playerEyeHeight);
                                const headY = Math.floor(this.camera.y - this.playerEyeHeight + this.playerHeight);
                                
                                let wouldCollide = false;
                                for (let checkY = feetY; checkY <= headY; checkY++) {
                                    if (px === placePos.x && checkY === placePos.y && pz === placePos.z) {
                                        wouldCollide = true;
                                        break;
                                    }
                                }
                                
                                if (!wouldCollide) {
                                    // Place source fluid block with full level (8)
                                    this.setBlock(placePos.x, placePos.y, placePos.z, fluidType);
                                    this.setFluidLevel(placePos.x, placePos.y, placePos.z, 8);
                                    
                                    // Add to fluid update queue for spreading
                                    this.fluidUpdates.push({
                                        x: placePos.x,
                                        y: placePos.y,
                                        z: placePos.z,
                                        type: fluidType,
                                        level: 8  // Source block has max level
                                    });
                                    
                                    // Consume bucket
                                    const slot = this.inventory.hotbar[this.selectedSlot];
                                    if (slot && slot.count > 1) {
                                        slot.count--;
                                    } else {
                                        this.inventory.hotbar[this.selectedSlot] = null;
                                        this.selectedItem = null;
                                    }
                                    this.updateHotbar();
                                }
                            }
                        } else if (this.selectedBlock) {
                            // Place block
                            const hit = this.raycast();
                            if (hit && hit.place) {
                                // Don't place block inside player
                                const px = Math.floor(this.camera.x);
                                const pz = Math.floor(this.camera.z);
                                const placePos = hit.place;
                                
                                // Check if placement would be inside player body
                                const feetY = Math.floor(this.camera.y - this.playerEyeHeight);
                                const headY = Math.floor(this.camera.y - this.playerEyeHeight + this.playerHeight);
                                
                                let wouldCollide = false;
                                for (let checkY = feetY; checkY <= headY; checkY++) {
                                    if (px === placePos.x && checkY === placePos.y && pz === placePos.z) {
                                        wouldCollide = true;
                                        break;
                                    }
                                }
                                
                                if (!wouldCollide) {
                                    this.setBlock(placePos.x, placePos.y, placePos.z, this.selectedBlock);
                                    this.stats.blocksPlaced++;
                                    
                                    // Consume block from inventory
                                    const slot = this.inventory.hotbar[this.selectedSlot];
                                    if (slot && slot.count > 0) {
                                        slot.count--;
                                        if (slot.count <= 0) {
                                            this.inventory.hotbar[this.selectedSlot] = null;
                                            this.selectedBlock = null;
                                        }
                                        this.updateHotbarDisplay();
                                    }
                                }
                            }
                        }
                    }
                });
                
                // Prevent context menu from appearing
                this.canvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                });
                
                // Scroll wheel - change hotbar selection
                this.canvas.addEventListener('wheel', (e) => {
                    if (!this.isActive || this.isPaused || this.inventoryOpen) return;
                    e.preventDefault();
                    
                    // Scroll down = next slot, scroll up = previous slot
                    if (e.deltaY > 0) {
                        this.selectedSlot = (this.selectedSlot + 1) % 9;
                    } else if (e.deltaY < 0) {
                        this.selectedSlot = (this.selectedSlot + 8) % 9; // +8 is same as -1 mod 9
                    }
                    
                    // Update selected item
                    const slot = this.inventory.hotbar[this.selectedSlot];
                    if (slot) {
                        if (slot.type === 'block') {
                            this.selectedBlock = slot.id;
                            this.selectedItem = null;
                        } else if (slot.type === 'weapon') {
                            this.selectedItem = slot.id;
                            this.selectedBlock = null;
                        } else if (slot.type === 'bucket') {
                            this.selectedItem = slot.id;
                            this.selectedBlock = null;
                        }
                    } else {
                        this.selectedBlock = null;
                        this.selectedItem = null;
                    }
                    this.updateHotbar();
                }, { passive: false });
                
                // Also catch wheel events on the game container to prevent page scroll
                const gameContainer = document.getElementById('minecraftGame');
                gameContainer.addEventListener('wheel', (e) => {
                    if (this.isActive) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                }, { passive: false });
                
                // Mouse movement - use movementX/Y deltas (works across screen boundaries)
                document.addEventListener('mousemove', (e) => {
                    if (!this.isActive || this.isPaused || !this.pointerLocked) return;
                    
                    // movementX/Y provide delta movement even across screen edges
                    this.camera.rotY -= e.movementX * 0.003;
                    this.camera.rotX = Math.max(-1.5, Math.min(1.5, this.camera.rotX + e.movementY * 0.003));
                });
                
                // Visibility change - pause when tab hidden
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden && this.isActive && !this.isPaused) {
                        this.pause();
                    }
                });
                
                // Window resize - update canvas if fullscreen
                window.addEventListener('resize', () => {
                    const isFs = document.fullscreenElement || document.webkitFullscreenElement;
                    if (isFs && this.isActive) {
                        this.canvas.width = window.innerWidth;
                        this.canvas.height = window.innerHeight;
                    }
                });
                
                // Hotbar clicks
                document.querySelectorAll('.hotbar-slot').forEach((slot, index) => {
                    slot.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.selectedSlot = index;
                        const invSlot = this.inventory.hotbar[index];
                        if (invSlot) {
                            if (invSlot.type === 'block') {
                                this.selectedBlock = invSlot.id;
                                this.selectedItem = null;
                            } else if (invSlot.type === 'weapon') {
                                this.selectedItem = invSlot.id;
                                this.selectedBlock = null;
                            }
                        }
                        this.updateHotbar();
                    });
                });
            },
            
            setupMenus() {
                // Resume button
                document.getElementById('btnResume').addEventListener('click', () => this.resume());
                
                // Fullscreen toggle button
                document.getElementById('btnFullscreen').addEventListener('click', (e) => {
                    e.preventDefault();
                    const container = document.getElementById('minecraftGame');
                    const isFs = document.fullscreenElement || document.webkitFullscreenElement;
                    
                    if (isFs) {
                        // Exit fullscreen
                        if (document.exitFullscreen) {
                            document.exitFullscreen();
                        } else if (document.webkitExitFullscreen) {
                            document.webkitExitFullscreen();
                        }
                    } else {
                        // Enter fullscreen - must be in same click handler
                        if (container.requestFullscreen) {
                            container.requestFullscreen().catch(err => console.log('Fullscreen error:', err));
                        } else if (container.webkitRequestFullscreen) {
                            container.webkitRequestFullscreen();
                        }
                    }
                    
                    // Resume game after toggling
                    this.resume();
                });
                
                // Update button text on fullscreen change
                document.addEventListener('fullscreenchange', () => this.updateFullscreenButton());
                document.addEventListener('webkitfullscreenchange', () => this.updateFullscreenButton());
                
                // Account button (disabled)
                document.getElementById('btnAccount').addEventListener('click', (e) => {
                    e.preventDefault();
                });
                
                // Stats button
                document.getElementById('btnStats').addEventListener('click', () => {
                    this.showSubmenu('menuStats');
                    this.updateStatsDisplay();
                });
                
                // Options button
                document.getElementById('btnOptions').addEventListener('click', () => {
                    this.showSubmenu('menuOptions');
                });
                
                // Quit button
                document.getElementById('btnQuit').addEventListener('click', () => this.stop());
                
                // Back buttons
                document.getElementById('statsBack').addEventListener('click', () => this.showSubmenu('menuMain'));
                document.getElementById('optionsBack').addEventListener('click', () => this.showSubmenu('menuMain'));
                
                // Options controls
                document.getElementById('optBrightness').addEventListener('input', (e) => {
                    this.settings.brightness = parseInt(e.target.value);
                    this.applyFilters();
                });
                
                document.getElementById('optFilter').addEventListener('change', (e) => {
                    this.settings.filter = e.target.value;
                    this.applyFilters();
                });
                
                document.getElementById('optRenderDist').addEventListener('change', (e) => {
                    this.settings.renderDistance = parseInt(e.target.value);
                });
                
                // Toggle switches
                ['optShadows', 'optLighting', 'optAA', 'optShowFps'].forEach(id => {
                    document.getElementById(id).addEventListener('click', (e) => {
                        const toggle = e.target;
                        const isOn = toggle.dataset.on === 'true';
                        toggle.dataset.on = (!isOn).toString();
                        toggle.classList.toggle('on', !isOn);
                        
                        if (id === 'optShadows') this.settings.shadows = !isOn;
                        if (id === 'optLighting') this.settings.lighting = !isOn;
                        if (id === 'optAA') {
                            this.settings.antialiasing = !isOn;
                            this.canvas.style.imageRendering = !isOn ? 'pixelated' : 'auto';
                        }
                        if (id === 'optShowFps') this.settings.showFps = !isOn;
                    });
                });
                
                // Target FPS slider
                document.getElementById('optTargetFps').addEventListener('input', (e) => {
                    const fps = parseInt(e.target.value);
                    this.settings.targetFps = fps;
                    document.getElementById('targetFpsValue').textContent = fps;
                });
            },
            
            showSubmenu(menuId) {
                document.querySelectorAll('.pause-submenu').forEach(m => m.classList.remove('active'));
                document.getElementById(menuId).classList.add('active');
            },
            
            updateStatsDisplay() {
                document.getElementById('statPlaced').textContent = this.stats.blocksPlaced;
                document.getElementById('statBroken').textContent = this.stats.blocksBroken;
                document.getElementById('statDistance').textContent = Math.floor(this.stats.distance) + 'm';
                document.getElementById('statJumps').textContent = this.stats.jumps;
                
                const elapsed = Math.floor((Date.now() - this.stats.startTime) / 1000);
                const mins = Math.floor(elapsed / 60);
                const secs = elapsed % 60;
                document.getElementById('statTime').textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
            },
            
            applyFilters() {
                let filter = `brightness(${this.settings.brightness}%)`;
                
                switch (this.settings.filter) {
                    case 'sepia':
                        filter += ' sepia(80%)';
                        break;
                    case 'grayscale':
                        filter += ' grayscale(100%)';
                        break;
                    case 'trippy':
                        filter += ' hue-rotate(' + (Date.now() % 3600) / 10 + 'deg) saturate(200%)';
                        break;
                }
                
                this.canvas.style.filter = filter;
            },
            
            updateHotbar() {
                const slots = document.querySelectorAll('.hotbar-slot');
                slots.forEach((slot, index) => {
                    const isSelected = index === this.selectedSlot;
                    slot.classList.toggle('selected', isSelected);
                });
            },
            
            // Update hotbar display with item counts and icons
            updateHotbarDisplay() {
                const slots = document.querySelectorAll('.hotbar-slot');
                slots.forEach((slot, index) => {
                    const item = this.inventory.hotbar[index];
                    const isSelected = index === this.selectedSlot;
                    slot.classList.toggle('selected', isSelected);
                    
                    // Set count attribute
                    if (item && item.count) {
                        slot.setAttribute('data-count', item.count);
                    } else {
                        slot.setAttribute('data-count', '');
                    }
                    
                    // Clear and redraw canvas
                    let canvas = slot.querySelector('canvas');
                    if (!canvas) {
                        canvas = document.createElement('canvas');
                        canvas.width = 32;
                        canvas.height = 32;
                        canvas.style.width = '100%';
                        canvas.style.height = '100%';
                        canvas.style.position = 'absolute';
                        canvas.style.top = '2px';
                        canvas.style.left = '2px';
                        slot.appendChild(canvas);
                    }
                    
                    if (item) {
                        this.drawMiniBlock(canvas, item.id);
                        
                        // Update durability bar if exists
                        let durBar = slot.querySelector('.durability-bar');
                        if (item.durability !== undefined && item.maxDurability) {
                            if (!durBar) {
                                durBar = document.createElement('div');
                                durBar.className = 'durability-bar';
                                durBar.innerHTML = '<div class="durability-fill"></div>';
                                slot.appendChild(durBar);
                            }
                            const fill = durBar.querySelector('.durability-fill');
                            const percent = (item.durability / item.maxDurability) * 100;
                            fill.style.width = percent + '%';
                            fill.style.backgroundColor = percent > 50 ? '#4a4' : percent > 25 ? '#aa4' : '#a44';
                            durBar.style.display = 'block';
                        } else if (durBar) {
                            durBar.style.display = 'none';
                        }
                    } else {
                        // Clear canvas for empty slot
                        const ctx = canvas.getContext('2d');
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        // Hide durability bar
                        const durBar = slot.querySelector('.durability-bar');
                        if (durBar) durBar.style.display = 'none';
                    }
                });
            },
            
            // Shoot the AK-47
            shootAK47() {
                if (this.shootCooldown > 0) return;
                
                // Check durability and reduce it
                const slot = this.inventory.hotbar[this.selectedSlot];
                if (slot && slot.id === 'ak47') {
                    if (slot.durability !== undefined && slot.durability <= 0) {
                        // Gun is broken!
                        return;
                    }
                    // Reduce durability
                    if (slot.durability !== undefined) {
                        slot.durability--;
                        if (slot.durability <= 0) {
                            // Gun breaks
                            this.inventory.hotbar[this.selectedSlot] = null;
                            this.selectedItem = null;
                            this.showPickupNotification('ak47', -1); // Show break notification
                        }
                        this.updateHotbarDisplay();
                    }
                }
                
                this.shootCooldown = 8; // Frames between shots
                this.muzzleFlash = 5;   // Frames of muzzle flash
                
                // Get shoot direction
                const pitch = this.camera.rotX;
                const yaw = this.camera.rotY;
                const dirX = -Math.sin(yaw) * Math.cos(pitch);
                const dirY = -Math.sin(pitch);
                const dirZ = Math.cos(yaw) * Math.cos(pitch);
                
                // Create bullet particle
                const bulletSpeed = 2.5;
                const bullet = {
                    x: this.camera.x + dirX * 0.5,
                    y: this.camera.y + dirY * 0.5,
                    z: this.camera.z + dirZ * 0.5,
                    vx: dirX * bulletSpeed,
                    vy: dirY * bulletSpeed,
                    vz: dirZ * bulletSpeed,
                    life: 60,
                    type: 'bullet',
                    trail: []
                };
                this.particles.push(bullet);
                
                // Check for bird hits and apply velocity knockback
                const knockbackForce = 0.8;
                let hitBird = null;
                let hitDist = Infinity;
                
                // Check pest birds - find closest hit
                for (const pest of this.pestBirds) {
                    const dx = pest.x - this.camera.x;
                    const dy = pest.y - this.camera.y;
                    const dz = pest.z - this.camera.z;
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    
                    if (dist < 15 && dist < hitDist) {
                        const birdDirX = dx / dist;
                        const birdDirY = dy / dist;
                        const birdDirZ = dz / dist;
                        const dot = dirX * birdDirX + dirY * birdDirY + dirZ * birdDirZ;
                        
                        if (dot > 0.9) {
                            hitBird = pest;
                            hitDist = dist;
                        }
                    }
                }
                
                // Apply knockback with velocity
                if (hitBird) {
                    // Set velocity for knockback animation
                    hitBird.vx = dirX * knockbackForce + (Math.random() - 0.5) * 0.2;
                    hitBird.vy = dirY * knockbackForce + 0.3 + Math.random() * 0.2; // Add upward force
                    hitBird.vz = dirZ * knockbackForce + (Math.random() - 0.5) * 0.2;
                    hitBird.state = 'knockback';
                    hitBird.stateTimer = 90;
                    
                    // Create ricochet particles
                    for (let i = 0; i < 8; i++) {
                        const ricochetSpeed = 0.15 + Math.random() * 0.2;
                        // Reflect direction with randomness
                        const rx = -dirX * 0.5 + (Math.random() - 0.5) * 1.5;
                        const ry = Math.random() * 0.8 + 0.2;
                        const rz = -dirZ * 0.5 + (Math.random() - 0.5) * 1.5;
                        const len = Math.sqrt(rx * rx + ry * ry + rz * rz);
                        
                        this.particles.push({
                            x: hitBird.x,
                            y: hitBird.y,
                            z: hitBird.z,
                            vx: (rx / len) * ricochetSpeed,
                            vy: (ry / len) * ricochetSpeed,
                            vz: (rz / len) * ricochetSpeed,
                            life: 25 + Math.random() * 20,
                            type: 'ricochet',
                            size: 2 + Math.random() * 3
                        });
                    }
                    
                    // Feather particles
                    for (let i = 0; i < 5; i++) {
                        this.particles.push({
                            x: hitBird.x + (Math.random() - 0.5) * 0.3,
                            y: hitBird.y + (Math.random() - 0.5) * 0.3,
                            z: hitBird.z + (Math.random() - 0.5) * 0.3,
                            vx: (Math.random() - 0.5) * 0.1,
                            vy: 0.05 + Math.random() * 0.05,
                            vz: (Math.random() - 0.5) * 0.1,
                            life: 40 + Math.random() * 30,
                            type: 'feather',
                            rotation: Math.random() * Math.PI * 2,
                            rotSpeed: (Math.random() - 0.5) * 0.3
                        });
                    }
                    
                    // Birds bounce player around when shot!
                    // Small random knockback to player
                    const playerKnockback = 0.08 + Math.random() * 0.05;
                    this.velocity.y += 0.05 + Math.random() * 0.03;  // Small upward bump
                    // Push player away from bird
                    const toBirdX = hitBird.x - this.camera.x;
                    const toBirdZ = hitBird.z - this.camera.z;
                    const toBirdDist = Math.sqrt(toBirdX * toBirdX + toBirdZ * toBirdZ);
                    if (toBirdDist > 0.1) {
                        // Push player in random direction with slight bias away from bird
                        this.camera.x -= (toBirdX / toBirdDist) * playerKnockback * 0.3 + (Math.random() - 0.5) * playerKnockback;
                        this.camera.z -= (toBirdZ / toBirdDist) * playerKnockback * 0.3 + (Math.random() - 0.5) * playerKnockback;
                    }
                    
                    // Special spawn chances!
                    const spawnRoll = Math.random();
                    let birdsToSpawn = 0;
                    
                    if (spawnRoll < 0.01) {
                        // 1/100 chance: SWARM! 20 birds spawn
                        birdsToSpawn = 20;
                    } else if (spawnRoll < 0.1) {
                        // 1/10 chance: 5 birds spawn
                        birdsToSpawn = 5;
                    }
                    
                    // Spawn the extra birds
                    for (let i = 0; i < birdsToSpawn; i++) {
                        const newAngle = Math.random() * Math.PI * 2;
                        const newRadius = 2 + Math.random() * 3;
                        this.pestBirds.push({
                            x: hitBird.x + Math.cos(newAngle) * newRadius,
                            y: hitBird.y + (Math.random() - 0.5) * 2,
                            z: hitBird.z + Math.sin(newAngle) * newRadius,
                            vx: 0, vy: 0, vz: 0,
                            targetOffsetX: 0, targetOffsetY: 0, targetOffsetZ: 0,
                            state: 'circling',
                            stateTimer: 10 + Math.random() * 20,
                            angle: newAngle,
                            circleRadius: newRadius,
                            baseCircleRadius: newRadius,
                            circleSpeed: 0.07 + Math.random() * 0.05,
                            swoopProgress: 0,
                            wingPhase: Math.random() * Math.PI * 2,
                            size: 0.15 + Math.random() * 0.08,
                            chirpTimer: Math.random() * 30,
                            knockbackSpin: 0,
                            anger: 1 + Math.floor(Math.random() * 3), // Spawned angry (1-3)
                            timesShot: 0,
                            spawnThreshold: 4 + Math.floor(Math.random() * 4)
                        });
                    }
                }
                
                // Check regular birds
                for (const bird of this.birds) {
                    const dx = bird.x - this.camera.x;
                    const dy = bird.y - this.camera.y;
                    const dz = bird.z - this.camera.z;
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    
                    if (dist < 25) {
                        const birdDirX = dx / dist;
                        const birdDirY = dy / dist;
                        const birdDirZ = dz / dist;
                        const dot = dirX * birdDirX + dirY * birdDirY + dirZ * birdDirZ;
                        
                        if (dot > 0.85) {
                            // Knock away by modifying orbit
                            bird.radius += 8;
                            bird.baseY += 5;
                            
                            // Create some ricochet sparks
                            for (let i = 0; i < 5; i++) {
                                this.particles.push({
                                    x: bird.x,
                                    y: bird.y,
                                    z: bird.z,
                                    vx: (Math.random() - 0.5) * 0.3,
                                    vy: Math.random() * 0.2,
                                    vz: (Math.random() - 0.5) * 0.3,
                                    life: 20 + Math.random() * 15,
                                    type: 'ricochet',
                                    size: 2 + Math.random() * 2
                                });
                            }
                        }
                    }
                }
            },
            
            // Update particles
            updateParticles() {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    p.life--;
                    
                    if (p.life <= 0) {
                        this.particles.splice(i, 1);
                        continue;
                    }
                    
                    // Update position
                    p.x += p.vx;
                    p.y += p.vy;
                    p.z += p.vz;
                    
                    if (p.type === 'bullet') {
                        // Store trail positions
                        p.trail.push({ x: p.x, y: p.y, z: p.z });
                        if (p.trail.length > 8) p.trail.shift();
                        
                        // Check for block collision
                        const bx = Math.floor(p.x);
                        const by = Math.floor(p.y);
                        const bz = Math.floor(p.z);
                        if (this.getBlock(bx, by, bz)) {
                            // Hit a block - create impact sparks
                            for (let j = 0; j < 6; j++) {
                                this.particles.push({
                                    x: p.x,
                                    y: p.y,
                                    z: p.z,
                                    vx: (Math.random() - 0.5) * 0.2,
                                    vy: Math.random() * 0.15,
                                    vz: (Math.random() - 0.5) * 0.2,
                                    life: 15 + Math.random() * 10,
                                    type: 'spark',
                                    size: 2 + Math.random() * 2
                                });
                            }
                            this.particles.splice(i, 1);
                        }
                    } else if (p.type === 'ricochet' || p.type === 'spark') {
                        p.vy -= 0.008; // Gravity
                        p.vx *= 0.97;
                        p.vz *= 0.97;
                    } else if (p.type === 'feather') {
                        p.vy -= 0.002; // Light gravity
                        p.vx *= 0.98;
                        p.vz *= 0.98;
                        p.rotation += p.rotSpeed;
                    } else if (p.type === 'burger') {
                        // Burger projectile - flies fast, affected slightly by gravity
                        p.vy -= 0.003;
                        // Check for bird collision
                        for (const pest of this.pestBirds) {
                            const dx = pest.x - p.x;
                            const dy = pest.y - p.y;
                            const dz = pest.z - p.z;
                            const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                            if (dist < 1.5) {
                                // Hit! Send bird flying and enrage it
                                const knockForce = 2.5;
                                pest.vx = (p.vx * 0.5) + (dx / dist) * knockForce;
                                pest.vy = Math.abs(p.vy) + 0.5;
                                pest.vz = (p.vz * 0.5) + (dz / dist) * knockForce;
                                pest.state = 'knockback';
                                pest.stateTimer = 120;
                                pest.anger = Math.min(5, pest.anger + 2); // Extra anger from burgers!
                                p.life = 0; // Burger consumed
                                
                                // Burger splat particles
                                for (let j = 0; j < 8; j++) {
                                    this.particles.push({
                                        x: p.x, y: p.y, z: p.z,
                                        vx: (Math.random() - 0.5) * 0.3,
                                        vy: Math.random() * 0.2,
                                        vz: (Math.random() - 0.5) * 0.3,
                                        life: 20,
                                        type: 'burgerSplat',
                                        size: 3 + Math.random() * 3
                                    });
                                }
                            }
                        }
                    } else if (p.type === 'burgerSplat') {
                        p.vy -= 0.01;
                        p.vx *= 0.95;
                        p.vz *= 0.95;
                    } else if (p.type === 'apple') {
                        // Apple projectile - flies with arc, knocks birds away
                        p.vy += (p.gravity || -0.008);
                        // Check for bird collision
                        for (const pest of this.pestBirds) {
                            const dx = pest.x - p.x;
                            const dy = pest.y - p.y;
                            const dz = pest.z - p.z;
                            const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                            if (dist < 1.5) {
                                // Hit! Send bird flying but DON'T enrage it
                                const knockForce = 3.0;
                                pest.vx = (p.vx * 0.5) + (dx / dist) * knockForce;
                                pest.vy = 0.8; // Pop up
                                pest.vz = (p.vz * 0.5) + (dz / dist) * knockForce;
                                pest.state = 'knockback';
                                pest.stateTimer = 180; // Longer stun
                                // Apples calm birds slightly
                                pest.anger = Math.max(0, pest.anger - 0.5);
                                p.life = 0;
                                
                                // Score for hitting bird
                                if (this.survivalStats) {
                                    this.survivalStats.score += 50;
                                    this.updateSurvivalHUD();
                                }
                                
                                // Apple splat particles
                                for (let j = 0; j < 6; j++) {
                                    this.particles.push({
                                        x: p.x, y: p.y, z: p.z,
                                        vx: (Math.random() - 0.5) * 0.3,
                                        vy: Math.random() * 0.2,
                                        vz: (Math.random() - 0.5) * 0.3,
                                        life: 15,
                                        type: 'appleSplat',
                                        size: 2 + Math.random() * 2
                                    });
                                }
                            }
                        }
                        // Check for decorative bird collision during swarm
                        for (const bird of this.birds) {
                            if (bird.swarmMode) {
                                const dx = bird.x - p.x;
                                const dy = bird.y - p.y;
                                const dz = bird.z - p.z;
                                const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                                if (dist < 2) {
                                    bird.swarmMode = false;
                                    bird.swarmTimer = 0;
                                    p.life = 0;
                                    if (this.survivalStats) {
                                        this.survivalStats.score += 25;
                                        this.updateSurvivalHUD();
                                    }
                                }
                            }
                        }
                        // Hit ground
                        const groundY = this.getGroundHeightBelow(p.x, p.z, p.y + 10);
                        if (p.y <= groundY + 0.5) {
                            p.life = 0;
                        }
                    } else if (p.type === 'appleSplat') {
                        p.vy -= 0.015;
                        p.vx *= 0.9;
                        p.vz *= 0.9;
                    } else if (p.type === 'petal') {
                        // Cherry blossom petals - float and flutter with wind
                        p.vy -= 0.0008; // Very light gravity for graceful fall
                        p.vx += this.wind.x * 0.15;
                        p.vz += this.wind.z * 0.15;
                        p.vx *= 0.985;
                        p.vz *= 0.985;
                        p.rotation += p.rotSpeed + this.wind.x * 0.08;
                        p.flutter += p.flutterSpeed || 0.08;
                        
                        // More complex flutter pattern - both horizontal sway and tumbling
                        p.x += Math.sin(p.flutter) * 0.025;
                        p.y += Math.cos(p.flutter * 1.3) * 0.008; // Slight vertical bob
                        p.z += Math.cos(p.flutter * 0.7) * 0.015;
                        
                        // Hit ground - disappear
                        if (p.y < this.getGroundHeightBelow(p.x, p.z, p.y + 10) + 1) {
                            p.life = 0;
                        }
                    }
                }
            },
            
            // Wind system - creates natural gusts that affect petals and birds
            updateWind() {
                this.wind.gustTimer++;
                
                // Change wind direction occasionally (gusts)
                if (this.wind.gustTimer > 120 + Math.random() * 180) {
                    this.wind.gustTimer = 0;
                    // New target wind direction
                    const gustStrength = 0.01 + Math.random() * 0.04;
                    const gustAngle = Math.random() * Math.PI * 2;
                    this.wind.targetX = Math.cos(gustAngle) * gustStrength;
                    this.wind.targetZ = Math.sin(gustAngle) * gustStrength;
                }
                
                // Smoothly interpolate toward target
                this.wind.x += (this.wind.targetX - this.wind.x) * 0.02;
                this.wind.z += (this.wind.targetZ - this.wind.z) * 0.02;
                
                // Add small random turbulence
                this.wind.x += (Math.random() - 0.5) * 0.002;
                this.wind.z += (Math.random() - 0.5) * 0.002;
            },
            
            // Spawn cherry blossom petals near trees
            updatePetals() {
                if (!this.cherryTrees || this.cherryTrees.length === 0) return;
                
                // Count current petals
                const currentPetals = this.particles.filter(p => p.type === 'petal').length;
                const maxPetals = 150; // Performance cap
                
                // Spawn multiple petals per frame for dense shower effect
                const petalsToSpawn = Math.min(5, maxPetals - currentPetals); // Spawn up to 5 per frame
                
                for (let i = 0; i < petalsToSpawn; i++) {
                    // 60% chance per slot to actually spawn (creates natural variation)
                    if (Math.random() > 0.6) continue;
                    
                    // Pick a random cherry tree
                    const tree = this.cherryTrees[Math.floor(Math.random() * this.cherryTrees.length)];
                    const dist = Math.sqrt((tree.x - this.camera.x) ** 2 + (tree.z - this.camera.z) ** 2);
                    
                    // Spawn petals for trees within range, with falloff
                    const spawnRange = 40;
                    if (dist < spawnRange) {
                        // Higher spawn chance for closer trees
                        const spawnChance = 1 - (dist / spawnRange) * 0.5;
                        if (Math.random() < spawnChance) {
                            // Wider spawn area around tree canopy
                            const spreadX = (Math.random() - 0.5) * 10;
                            const spreadZ = (Math.random() - 0.5) * 10;
                            
                            // Also spawn some petals floating in the air (wind-carried)
                            const heightBonus = Math.random() < 0.3 ? Math.random() * 8 : 0;
                            
                            this.particles.push({
                                x: tree.x + spreadX,
                                y: tree.y + Math.random() * 3 + heightBonus,
                                z: tree.z + spreadZ,
                                vx: this.wind.x * 1.5 + (Math.random() - 0.5) * 0.03,
                                vy: -0.008 - Math.random() * 0.015, // Slower fall for more graceful effect
                                vz: this.wind.z * 1.5 + (Math.random() - 0.5) * 0.03,
                                life: 250 + Math.random() * 200, // Longer life
                                type: 'petal',
                                size: 2.5 + Math.random() * 2.5,
                                rotation: Math.random() * Math.PI * 2,
                                rotSpeed: (Math.random() - 0.5) * 0.15,
                                flutter: Math.random() * Math.PI * 2,
                                flutterSpeed: 0.05 + Math.random() * 0.05
                            });
                        }
                    }
                }
                
                // Also spawn ambient petals in the air around player (wind-blown)
                if (currentPetals < maxPetals * 0.8 && Math.random() < 0.3) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 10 + Math.random() * 20;
                    this.particles.push({
                        x: this.camera.x + Math.cos(angle) * radius,
                        y: this.camera.y + 5 + Math.random() * 10,
                        z: this.camera.z + Math.sin(angle) * radius,
                        vx: this.wind.x * 2 + (Math.random() - 0.5) * 0.02,
                        vy: -0.005 - Math.random() * 0.01,
                        vz: this.wind.z * 2 + (Math.random() - 0.5) * 0.02,
                        life: 150 + Math.random() * 100,
                        type: 'petal',
                        size: 2 + Math.random() * 2,
                        rotation: Math.random() * Math.PI * 2,
                        rotSpeed: (Math.random() - 0.5) * 0.12,
                        flutter: Math.random() * Math.PI * 2,
                        flutterSpeed: 0.04 + Math.random() * 0.04
                    });
                }
            },
            
            // Drop an item on the ground
            dropItem(x, y, z, type, count) {
                if (!this.droppedItems) this.droppedItems = [];
                this.droppedItems.push({
                    x: x + (Math.random() - 0.5) * 0.3,
                    y: y,
                    z: z + (Math.random() - 0.5) * 0.3,
                    vy: 0.1 + Math.random() * 0.05,
                    type: type,
                    count: count,
                    bobPhase: Math.random() * Math.PI * 2,
                    pickupDelay: 30 // Frames before can be picked up
                });
            },
            
            // Update dropped items (physics and pickup)
            updateDroppedItems() {
                if (!this.droppedItems) return;
                
                for (let i = this.droppedItems.length - 1; i >= 0; i--) {
                    const item = this.droppedItems[i];
                    
                    // Pickup delay
                    if (item.pickupDelay > 0) item.pickupDelay--;
                    
                    // Physics
                    item.vy -= 0.015; // Gravity
                    item.y += item.vy;
                    
                    // Ground collision
                    const groundY = this.getGroundHeightBelow(item.x, item.z, item.y + 5) + 1.3;
                    if (item.y < groundY) {
                        item.y = groundY;
                        item.vy = 0;
                    }
                    
                    // Bobbing animation
                    item.bobPhase += 0.05;
                    
                    // Check pickup by player
                    if (item.pickupDelay <= 0) {
                        const dx = item.x - this.camera.x;
                        const dy = item.y - this.camera.y;
                        const dz = item.z - this.camera.z;
                        const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                        
                        if (dist < 2) {
                            // Try to add to inventory
                            if (this.addToInventory(item.type, item.count)) {
                                this.droppedItems.splice(i, 1);
                            }
                        }
                    }
                }
            },
            
            // Add item to inventory (hotbar first, then main inventory)
            addToInventory(type, count) {
                // Determine item category
                let itemType = 'block';  // Default
                if (type === 'ak47' || type === 'berdger') itemType = 'weapon';
                if (type === 'water_bucket' || type === 'lava_bucket') itemType = 'bucket';
                if (this.ritualItems && this.ritualItems.includes(type)) itemType = 'item';
                if (type === 'seeds' || type === 'apple') itemType = 'item';
                
                // Show pickup animation
                this.showPickupNotification(type, count);
                
                // Try to stack with existing items in hotbar first
                for (let i = 0; i < 9; i++) {
                    const slot = this.inventory.hotbar[i];
                    if (slot && (slot.id === type || slot.type === type) && slot.count < 64) {
                        const canAdd = Math.min(count, 64 - slot.count);
                        slot.count += canAdd;
                        count -= canAdd;
                        if (count <= 0) {
                            this.updateHotbarDisplay();
                            return true;
                        }
                    }
                }
                
                // Try to stack with existing items in main inventory
                for (let i = 0; i < 27; i++) {
                    const slot = this.inventory.main[i];
                    if (slot && (slot.id === type || slot.type === type) && slot.count < 64) {
                        const canAdd = Math.min(count, 64 - slot.count);
                        slot.count += canAdd;
                        count -= canAdd;
                        if (count <= 0) {
                            this.updateHotbarDisplay();
                            return true;
                        }
                    }
                }
                
                // Find empty slot in hotbar
                for (let i = 0; i < 9; i++) {
                    if (!this.inventory.hotbar[i]) {
                        const itemDef = this.itemTypes[type] || {};
                        this.inventory.hotbar[i] = { 
                            type: itemType, 
                            id: type, 
                            count,
                            durability: itemDef.durability,
                            maxDurability: itemDef.maxDurability
                        };
                        this.updateHotbarDisplay();
                        return true;
                    }
                }
                
                // Find empty slot in main inventory
                for (let i = 0; i < 27; i++) {
                    if (!this.inventory.main[i]) {
                        const itemDef = this.itemTypes[type] || {};
                        this.inventory.main[i] = { 
                            type: itemType, 
                            id: type, 
                            count,
                            durability: itemDef.durability,
                            maxDurability: itemDef.maxDurability
                        };
                        this.updateHotbarDisplay();
                        return true;
                    }
                }
                
                return false; // All inventory full
            },
            
            // Show pickup notification (uses batch queue for multiple pickups)
            showPickupNotification(type, count) {
                // Handle broken items immediately (don't batch)
                if (count < 0) {
                    const container = document.getElementById('pickupNotification');
                    if (!container) return;
                    
                    const itemNames = {
                        grass: 'Grass Block', dirt: 'Dirt', stone: 'Stone', wood: 'Wood',
                        appleLeaves: 'Apple Leaves', leaves: 'Leaves', sand: 'Sand', brick: 'Brick',
                        ak47: 'AK-47', water_bucket: 'Water Bucket', lava_bucket: 'Lava Bucket',
                        obsidian: 'Obsidian', cherryWood: 'Cherry Wood', cherryLeaves: 'Cherry Leaves',
                        chest: 'Chest', seeds: 'Seeds', berdger: 'The Berdger', apple: 'Apple',
                        sakuraPetal: 'Cherry Petal', shimenawa: 'Sacred Rope', omamori: 'Charm',
                        ema: 'Wish Plaque', incense: 'Incense', whiteBrick: 'White Brick',
                        redBrick: 'Red Brick', glowstone: 'Glowstone', ritualStone: 'Ritual Stone'
                    };
                    
                    const notification = document.createElement('div');
                    notification.className = 'pickup-item';
                    notification.style.borderColor = 'rgba(255, 50, 50, 0.8)';
                    notification.innerHTML = `
                        <span class="pickup-icon">ðŸ’”</span>
                        <span style="color:#ff6666">${itemNames[type] || type} broke!</span>
                    `;
                    container.appendChild(notification);
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.parentNode.removeChild(notification);
                        }
                    }, 2000);
                    return;
                }
                
                // Use batch queue for normal pickups
                this.queuePickupNotification(type, count);
            },
            
            // Draw a mini 3D block for inventory display
            drawMiniBlock(canvas, type) {
                const ctx = canvas.getContext('2d');
                const colors = this.blockColors[type];
                const w = canvas.width;
                const h = canvas.height;
                
                ctx.clearRect(0, 0, w, h);
                
                const cx = w / 2;
                const cy = h / 2;
                const size = Math.min(w, h) * 0.35;
                
                // Special item rendering for non-blocks
                if (!colors) {
                    ctx.save();
                    ctx.translate(cx, cy);
                    
                    if (type === 'apple') {
                        // Red apple
                        ctx.fillStyle = '#dc143c';
                        ctx.beginPath();
                        ctx.arc(0, 0, size * 0.7, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = 'rgba(255,255,255,0.3)';
                        ctx.beginPath();
                        ctx.arc(-size * 0.2, -size * 0.2, size * 0.25, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#654321';
                        ctx.fillRect(-1, -size * 0.8, 3, size * 0.3);
                        ctx.fillStyle = '#228b22';
                        ctx.beginPath();
                        ctx.ellipse(3, -size * 0.7, 4, 2, 0.3, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (type === 'seeds') {
                        ctx.fillStyle = '#daa520';
                        for (let i = 0; i < 5; i++) {
                            const angle = (i / 5) * Math.PI * 2;
                            const sx = Math.cos(angle) * size * 0.4;
                            const sy = Math.sin(angle) * size * 0.3;
                            ctx.beginPath();
                            ctx.ellipse(sx, sy, 3, 5, angle, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    } else if (type === 'ak47') {
                        ctx.fillStyle = '#333';
                        ctx.fillRect(-size * 0.6, -size * 0.1, size * 1.2, size * 0.25);
                        ctx.fillStyle = '#8b4513';
                        ctx.fillRect(-size * 0.3, size * 0.1, size * 0.4, size * 0.4);
                        ctx.fillStyle = '#222';
                        ctx.fillRect(size * 0.1, size * 0.1, size * 0.15, size * 0.35);
                    } else if (type === 'berdger') {
                        ctx.fillStyle = '#daa520';
                        ctx.beginPath();
                        ctx.ellipse(0, -size * 0.3, size * 0.5, size * 0.25, 0, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#8b4513';
                        ctx.fillRect(-size * 0.4, -size * 0.15, size * 0.8, size * 0.2);
                        ctx.fillStyle = '#228b22';
                        ctx.fillRect(-size * 0.35, -size * 0.05, size * 0.7, size * 0.1);
                        ctx.fillStyle = '#daa520';
                        ctx.beginPath();
                        ctx.ellipse(0, size * 0.2, size * 0.55, size * 0.3, 0, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (type === 'water_bucket' || type === 'lava_bucket') {
                        ctx.fillStyle = '#888';
                        ctx.beginPath();
                        ctx.moveTo(-size * 0.4, -size * 0.3);
                        ctx.lineTo(size * 0.4, -size * 0.3);
                        ctx.lineTo(size * 0.3, size * 0.5);
                        ctx.lineTo(-size * 0.3, size * 0.5);
                        ctx.closePath();
                        ctx.fill();
                        ctx.fillStyle = type === 'water_bucket' ? '#4a90d9' : '#ff6600';
                        ctx.beginPath();
                        ctx.moveTo(-size * 0.3, -size * 0.1);
                        ctx.lineTo(size * 0.3, -size * 0.1);
                        ctx.lineTo(size * 0.25, size * 0.4);
                        ctx.lineTo(-size * 0.25, size * 0.4);
                        ctx.closePath();
                        ctx.fill();
                    } else if (type === 'sakuraPetal') {
                        ctx.fillStyle = '#ffb7c5';
                        ctx.beginPath();
                        ctx.ellipse(0, 0, size * 0.6, size * 0.3, 0.3, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (type === 'shimenawa') {
                        ctx.strokeStyle = '#daa520';
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.moveTo(-size * 0.5, 0);
                        ctx.quadraticCurveTo(0, -size * 0.4, size * 0.5, 0);
                        ctx.stroke();
                    } else if (type === 'omamori') {
                        ctx.fillStyle = '#cc0000';
                        ctx.fillRect(-size * 0.3, -size * 0.5, size * 0.6, size);
                        ctx.fillStyle = '#ffd700';
                        ctx.fillRect(-size * 0.25, -size * 0.35, size * 0.5, size * 0.15);
                    } else if (type === 'ema') {
                        ctx.fillStyle = '#deb887';
                        ctx.beginPath();
                        ctx.moveTo(0, -size * 0.5);
                        ctx.lineTo(size * 0.4, -size * 0.2);
                        ctx.lineTo(size * 0.4, size * 0.4);
                        ctx.lineTo(-size * 0.4, size * 0.4);
                        ctx.lineTo(-size * 0.4, -size * 0.2);
                        ctx.closePath();
                        ctx.fill();
                    } else if (type === 'incense') {
                        ctx.fillStyle = '#8b4513';
                        ctx.fillRect(-1, -size * 0.6, 3, size * 1.2);
                        ctx.fillStyle = '#ff6600';
                        ctx.beginPath();
                        ctx.arc(0.5, -size * 0.6, 3, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        // Unknown item - draw placeholder
                        ctx.fillStyle = '#888';
                        ctx.fillRect(-size * 0.4, -size * 0.4, size * 0.8, size * 0.8);
                        ctx.fillStyle = '#444';
                        ctx.font = '8px monospace';
                        ctx.textAlign = 'center';
                        ctx.fillText('?', 0, 3);
                    }
                    ctx.restore();
                    return;
                }
                
                // Isometric 3D block drawing for blocks
                const blockSize = Math.min(w, h) * 0.25;
                
                // Handle rgba colors for transparent blocks like water
                let topColor = colors.top;
                let sideColor = colors.side;
                if (typeof topColor === 'string' && topColor.includes('rgba')) {
                    // Make opaque for icon display
                    topColor = topColor.replace(/[\d.]+\)$/, '1)');
                    sideColor = sideColor.replace(/[\d.]+\)$/, '1)');
                }
                
                // Top face (brightest)
                ctx.fillStyle = topColor;
                ctx.beginPath();
                ctx.moveTo(cx, cy - blockSize);
                ctx.lineTo(cx + blockSize, cy - blockSize/2);
                ctx.lineTo(cx, cy);
                ctx.lineTo(cx - blockSize, cy - blockSize/2);
                ctx.closePath();
                ctx.fill();
                
                // Left face (medium)
                ctx.fillStyle = sideColor;
                ctx.beginPath();
                ctx.moveTo(cx - blockSize, cy - blockSize/2);
                ctx.lineTo(cx, cy);
                ctx.lineTo(cx, cy + blockSize);
                ctx.lineTo(cx - blockSize, cy + blockSize/2);
                ctx.closePath();
                ctx.fill();
                
                // Right face (darkest)
                let rightColor;
                try {
                    rightColor = this.darkenColor(sideColor.replace(/rgba?\([^)]+\)/, '#888888'), 0.7);
                } catch(e) {
                    rightColor = this.darkenColor(sideColor, 0.7);
                }
                ctx.fillStyle = rightColor;
                ctx.beginPath();
                ctx.moveTo(cx, cy);
                ctx.lineTo(cx + blockSize, cy - blockSize/2);
                ctx.lineTo(cx + blockSize, cy + blockSize/2);
                ctx.lineTo(cx, cy + blockSize);
                ctx.closePath();
                ctx.fill();
                
                // Outline
                ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                ctx.lineWidth = 0.5;
                ctx.beginPath();
                ctx.moveTo(cx, cy - size);
                ctx.lineTo(cx + size, cy - size/2);
                ctx.lineTo(cx + size, cy + size/2);
                ctx.lineTo(cx, cy + size);
                ctx.lineTo(cx - size, cy + size/2);
                ctx.lineTo(cx - size, cy - size/2);
                ctx.closePath();
                ctx.stroke();
            },
            
            // Draw 3D item for dropped items in the world
            drawDroppedItem3D(ctx, cx, cy, size, type, bobPhase) {
                const colors = this.blockColors[type];
                const rotation = (bobPhase || 0) * 0.5; // Slowly rotate
                
                ctx.save();
                ctx.translate(cx, cy);
                
                // Non-block items get special rendering
                if (!colors) {
                    // Special item rendering
                    if (type === 'apple') {
                        // Red apple
                        ctx.fillStyle = '#dc143c';
                        ctx.beginPath();
                        ctx.arc(0, 0, size * 0.8, 0, Math.PI * 2);
                        ctx.fill();
                        // Highlight
                        ctx.fillStyle = 'rgba(255,255,255,0.3)';
                        ctx.beginPath();
                        ctx.arc(-size * 0.2, -size * 0.2, size * 0.3, 0, Math.PI * 2);
                        ctx.fill();
                        // Stem
                        ctx.fillStyle = '#654321';
                        ctx.fillRect(-1, -size * 0.9, 2, size * 0.3);
                        ctx.fillStyle = '#228b22';
                        ctx.beginPath();
                        ctx.ellipse(2, -size * 0.8, 3, 2, 0.3, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (type === 'seeds') {
                        // Wheat seeds
                        ctx.fillStyle = '#daa520';
                        for (let i = 0; i < 5; i++) {
                            const angle = (i / 5) * Math.PI * 2 + rotation;
                            const sx = Math.cos(angle) * size * 0.4;
                            const sy = Math.sin(angle) * size * 0.3;
                            ctx.beginPath();
                            ctx.ellipse(sx, sy, size * 0.2, size * 0.1, angle, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    } else if (type === 'ak47') {
                        // Gun silhouette
                        ctx.fillStyle = '#333';
                        ctx.fillRect(-size * 0.8, -size * 0.15, size * 1.6, size * 0.3);
                        ctx.fillRect(-size * 0.3, -size * 0.15, size * 0.15, size * 0.5);
                        ctx.fillRect(size * 0.3, -size * 0.4, size * 0.5, size * 0.25);
                    } else if (type === 'berdger') {
                        // Mini burger
                        ctx.fillStyle = '#D2691E';
                        ctx.beginPath();
                        ctx.ellipse(0, -size * 0.2, size * 0.7, size * 0.35, 0, Math.PI, 0);
                        ctx.fill();
                        ctx.fillStyle = '#654321';
                        ctx.fillRect(-size * 0.6, -size * 0.1, size * 1.2, size * 0.25);
                        ctx.fillStyle = '#228B22';
                        ctx.fillRect(-size * 0.55, size * 0.1, size * 1.1, size * 0.1);
                        ctx.fillStyle = '#DEB887';
                        ctx.beginPath();
                        ctx.ellipse(0, size * 0.25, size * 0.65, size * 0.3, 0, 0, Math.PI);
                        ctx.fill();
                    } else if (type === 'water_bucket' || type === 'lava_bucket') {
                        // Bucket
                        ctx.fillStyle = '#888';
                        ctx.beginPath();
                        ctx.moveTo(-size * 0.5, -size * 0.5);
                        ctx.lineTo(size * 0.5, -size * 0.5);
                        ctx.lineTo(size * 0.4, size * 0.5);
                        ctx.lineTo(-size * 0.4, size * 0.5);
                        ctx.closePath();
                        ctx.fill();
                        // Contents
                        ctx.fillStyle = type === 'water_bucket' ? '#4a90d9' : '#ff6600';
                        ctx.fillRect(-size * 0.35, -size * 0.3, size * 0.7, size * 0.6);
                        // Handle
                        ctx.strokeStyle = '#666';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(0, -size * 0.6, size * 0.4, Math.PI * 0.2, Math.PI * 0.8);
                        ctx.stroke();
                    } else if (type === 'sakuraPetal') {
                        // Pink petal
                        ctx.fillStyle = '#ffb7c5';
                        ctx.beginPath();
                        ctx.ellipse(0, 0, size * 0.6, size * 0.3, rotation, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (type === 'shimenawa') {
                        // Sacred rope
                        ctx.strokeStyle = '#daa520';
                        ctx.lineWidth = size * 0.2;
                        ctx.beginPath();
                        ctx.moveTo(-size * 0.6, 0);
                        ctx.bezierCurveTo(-size * 0.3, -size * 0.4, size * 0.3, size * 0.4, size * 0.6, 0);
                        ctx.stroke();
                    } else if (type === 'omamori') {
                        // Charm
                        ctx.fillStyle = '#ff4444';
                        ctx.fillRect(-size * 0.3, -size * 0.5, size * 0.6, size * 0.8);
                        ctx.fillStyle = '#gold';
                        ctx.fillRect(-size * 0.2, -size * 0.4, size * 0.4, size * 0.15);
                    } else if (type === 'ema') {
                        // Wooden plaque
                        ctx.fillStyle = '#deb887';
                        ctx.beginPath();
                        ctx.moveTo(0, -size * 0.6);
                        ctx.lineTo(size * 0.5, -size * 0.2);
                        ctx.lineTo(size * 0.5, size * 0.5);
                        ctx.lineTo(-size * 0.5, size * 0.5);
                        ctx.lineTo(-size * 0.5, -size * 0.2);
                        ctx.closePath();
                        ctx.fill();
                    } else if (type === 'incense') {
                        // Incense stick
                        ctx.fillStyle = '#8b4513';
                        ctx.fillRect(-1, -size * 0.6, 2, size * 1.2);
                        ctx.fillStyle = '#ff6600';
                        ctx.beginPath();
                        ctx.arc(0, -size * 0.6, 3, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        // Default cube for unknown items
                        ctx.fillStyle = '#888';
                        ctx.fillRect(-size * 0.5, -size * 0.5, size, size);
                    }
                    ctx.restore();
                    return;
                }
                
                // Block items - draw isometric cube
                const s = size * 0.8;
                
                // Top face
                ctx.fillStyle = colors.top;
                ctx.beginPath();
                ctx.moveTo(0, -s);
                ctx.lineTo(s, -s/2);
                ctx.lineTo(0, 0);
                ctx.lineTo(-s, -s/2);
                ctx.closePath();
                ctx.fill();
                
                // Left face
                ctx.fillStyle = colors.side;
                ctx.beginPath();
                ctx.moveTo(-s, -s/2);
                ctx.lineTo(0, 0);
                ctx.lineTo(0, s);
                ctx.lineTo(-s, s/2);
                ctx.closePath();
                ctx.fill();
                
                // Right face
                ctx.fillStyle = this.darkenColor(colors.side, 0.7);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(s, -s/2);
                ctx.lineTo(s, s/2);
                ctx.lineTo(0, s);
                ctx.closePath();
                ctx.fill();
                
                // Outline
                ctx.strokeStyle = 'rgba(0,0,0,0.4)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, -s);
                ctx.lineTo(s, -s/2);
                ctx.lineTo(s, s/2);
                ctx.lineTo(0, s);
                ctx.lineTo(-s, s/2);
                ctx.lineTo(-s, -s/2);
                ctx.closePath();
                ctx.stroke();
                
                ctx.restore();
            },
            
            // Update hotbar visual display
            updateHotbarDisplay() {
                const slots = document.querySelectorAll('.hotbar-slot');
                
                slots.forEach((slot, index) => {
                    const invSlot = this.inventory.hotbar[index];
                    
                    // Clear existing content
                    slot.innerHTML = '';
                    
                    if (invSlot) {
                        const itemId = invSlot.id || invSlot.type;
                        
                        // Create mini block canvas
                        const miniCanvas = document.createElement('canvas');
                        miniCanvas.width = 32;
                        miniCanvas.height = 32;
                        miniCanvas.style.width = '100%';
                        miniCanvas.style.height = '100%';
                        this.drawMiniBlock(miniCanvas, itemId);
                        slot.appendChild(miniCanvas);
                        
                        // Set count attribute (CSS handles display)
                        slot.setAttribute('data-count', invSlot.count > 1 ? invSlot.count : '');
                        
                        // Add durability bar for tools
                        if (invSlot.maxDurability && invSlot.durability !== undefined) {
                            const durBar = document.createElement('div');
                            durBar.className = 'durability-bar';
                            const durFill = document.createElement('div');
                            durFill.className = 'durability-fill';
                            const percent = (invSlot.durability / invSlot.maxDurability) * 100;
                            durFill.style.width = percent + '%';
                            // Color based on durability
                            if (percent > 50) durFill.style.background = '#4f4';
                            else if (percent > 25) durFill.style.background = '#ff0';
                            else durFill.style.background = '#f44';
                            durBar.appendChild(durFill);
                            slot.appendChild(durBar);
                        }
                    } else {
                        slot.setAttribute('data-count', '');
                    }
                });
                
                this.updateHotbar();
            },
            
            // Use seeds to calm birds
            useSeeds() {
                const slot = this.inventory.hotbar[this.selectedSlot];
                if (slot && slot.id === 'seeds' && slot.count > 0) {
                    slot.count--;
                    if (slot.count <= 0) {
                        this.inventory.hotbar[this.selectedSlot] = null;
                        this.selectedItem = null;
                    }
                    this.updateHotbarDisplay();
                    
                    // Calm birds for 10 seconds (600 frames)
                    this.seedCalmTimer = 600;
                    
                    // Visual effect - toss seeds
                    for (let i = 0; i < 10; i++) {
                        this.particles.push({
                            x: this.camera.x + (Math.random() - 0.5) * 2,
                            y: this.camera.y - 0.5,
                            z: this.camera.z + (Math.random() - 0.5) * 2,
                            vx: (Math.random() - 0.5) * 0.2,
                            vy: 0.1 + Math.random() * 0.1,
                            vz: (Math.random() - 0.5) * 0.2,
                            life: 60,
                            type: 'spark',
                            size: 2
                        });
                    }
                    return true;
                }
                return false;
            },
            
            // Shoot the berdger (burger launcher)
            shootBerdger() {
                const slot = this.inventory.hotbar[this.selectedSlot];
                if (slot && slot.id === 'berdger') {
                    // Berdger has infinite ammo - it's invincible!
                    // Use the same direction calculation as raycast
                    const pitch = this.camera.rotX;
                    const yaw = this.camera.rotY;
                    const cosPitch = Math.cos(pitch);
                    const sinPitch = Math.sin(pitch);
                    
                    const dirX = -Math.sin(yaw) * cosPitch;
                    const dirY = -sinPitch;  // Fixed: now matches raycast
                    const dirZ = Math.cos(yaw) * cosPitch;
                    
                    // Rapid fire burgers!
                    this.particles.push({
                        x: this.camera.x + dirX * 0.5,
                        y: this.camera.y + dirY * 0.5,
                        z: this.camera.z + dirZ * 0.5,
                        vx: dirX * 0.8,
                        vy: dirY * 0.8,
                        vz: dirZ * 0.8,
                        life: 120,
                        type: 'burger',
                        size: 8,
                        trail: []
                    });
                    return true;
                }
                return false;
            },
            
            // Throw an apple at birds
            throwApple() {
                const slot = this.inventory.hotbar[this.selectedSlot];
                if (slot && slot.id === 'apple' && slot.count > 0) {
                    slot.count--;
                    if (slot.count <= 0) {
                        this.inventory.hotbar[this.selectedSlot] = null;
                        this.selectedItem = null;
                    }
                    this.updateHotbarDisplay();
                    
                    // Use the same direction as raycast
                    const pitch = this.camera.rotX;
                    const yaw = this.camera.rotY;
                    const cosPitch = Math.cos(pitch);
                    const sinPitch = Math.sin(pitch);
                    
                    const dirX = -Math.sin(yaw) * cosPitch;
                    const dirY = -sinPitch;
                    const dirZ = Math.cos(yaw) * cosPitch;
                    
                    // Throw apple
                    this.particles.push({
                        x: this.camera.x + dirX * 0.5,
                        y: this.camera.y + dirY * 0.5,
                        z: this.camera.z + dirZ * 0.5,
                        vx: dirX * 0.6,
                        vy: dirY * 0.6 + 0.1, // Slight arc
                        vz: dirZ * 0.6,
                        life: 180,
                        type: 'apple',
                        size: 6,
                        gravity: -0.008
                    });
                    return true;
                }
                return false;
            },
            
            // Check and complete ritual
            checkRitual() {
                if (this.ritualComplete) return;
                
                // Check if player has all ritual items
                const hasItems = {};
                for (const item of this.ritualItems) {
                    hasItems[item] = false;
                }
                
                for (let i = 0; i < 9; i++) {
                    const slot = this.inventory.hotbar[i];
                    if (slot && this.ritualItems.includes(slot.id)) {
                        hasItems[slot.id] = true;
                    }
                }
                
                const allPresent = this.ritualItems.every(item => hasItems[item]);
                
                if (allPresent) {
                    // Complete the Omamori ritual!
                    this.ritualComplete = true;
                    this.ritualBlessingActive = true;
                    this.ritualBlessingTimer = 36000; // 10 minutes at 60fps
                    
                    // Consume ritual items
                    for (let i = 0; i < 9; i++) {
                        const slot = this.inventory.hotbar[i];
                        if (slot && this.ritualItems.includes(slot.id)) {
                            this.inventory.hotbar[i] = null;
                        }
                    }
                    this.updateHotbarDisplay();
                    
                    // Reward: All birds become permanently calmed and friendly
                    for (const pest of this.pestBirds) {
                        pest.anger = 0;
                        pest.state = 'circling';
                    }
                    
                    // Grand visual effect
                    for (let i = 0; i < 50; i++) {
                        this.particles.push({
                            x: this.camera.x + (Math.random() - 0.5) * 8,
                            y: this.camera.y + Math.random() * 5,
                            z: this.camera.z + (Math.random() - 0.5) * 8,
                            vx: (Math.random() - 0.5) * 0.1,
                            vy: 0.05 + Math.random() * 0.1,
                            vz: (Math.random() - 0.5) * 0.1,
                            life: 120 + Math.random() * 60,
                            type: 'petal',
                            size: 4 + Math.random() * 3,
                            rotation: Math.random() * Math.PI * 2,
                            rotSpeed: (Math.random() - 0.5) * 0.2,
                            flutter: Math.random() * Math.PI * 2
                        });
                    }
                    
                    return true;
                }
                return false;
            },
            
            // Interact with ritual socket blocks
            interactWithSocket(x, y, z, socketType) {
                // Map socket types to required items
                const socketItemMap = {
                    'petalSocket': 'sakuraPetal',
                    'ropeSocket': 'shimenawa',
                    'charmSocket': 'omamori',
                    'plaqueSocket': 'ema',
                    'incenseSocket': 'incense'
                };
                
                // Map socket types to filled versions
                const filledSocketMap = {
                    'petalSocket': 'petalSocketFilled',
                    'ropeSocket': 'ropeSocketFilled',
                    'charmSocket': 'charmSocketFilled',
                    'plaqueSocket': 'plaqueSocketFilled',
                    'incenseSocket': 'incenseSocketFilled'
                };
                
                const requiredItem = socketItemMap[socketType];
                if (!requiredItem) return;
                
                // Check if already filled
                if (socketType.includes('Filled')) return;
                
                // Check if player has the required item
                const slot = this.inventory.hotbar[this.selectedSlot];
                if (slot && slot.id === requiredItem && slot.count > 0) {
                    // Place item on socket
                    slot.count--;
                    if (slot.count <= 0) {
                        this.inventory.hotbar[this.selectedSlot] = null;
                    }
                    this.updateHotbarDisplay();
                    
                    // Change block to filled version
                    this.setBlock(x, y, z, filledSocketMap[socketType]);
                    
                    // Track socket completion
                    if (!this.socketsFilled) this.socketsFilled = {};
                    this.socketsFilled[socketType] = true;
                    
                    // Visual effect
                    for (let i = 0; i < 20; i++) {
                        this.particles.push({
                            x: x + 0.5 + (Math.random() - 0.5) * 0.5,
                            y: y + 1 + Math.random() * 0.5,
                            z: z + 0.5 + (Math.random() - 0.5) * 0.5,
                            vx: (Math.random() - 0.5) * 0.1,
                            vy: 0.1 + Math.random() * 0.1,
                            vz: (Math.random() - 0.5) * 0.1,
                            life: 60 + Math.random() * 40,
                            type: 'spark',
                            size: 3 + Math.random() * 2
                        });
                    }
                    
                    // Check if all sockets are filled
                    const allSocketsFilled = Object.keys(socketItemMap).every(
                        socket => this.socketsFilled && this.socketsFilled[socket]
                    );
                    
                    if (allSocketsFilled && !this.ritualComplete) {
                        // COMPLETE THE TEMPLE RITUAL!
                        this.ritualComplete = true;
                        this.ritualBlessingActive = true;
                        this.ritualBlessingTimer = 60 * 60 * 10; // 10 minutes at 60fps
                        
                        // Trigger the creative reward
                        this.triggerRitualReward();
                        
                        // Calm all birds
                        if (this.pestBirds) {
                            for (const pest of this.pestBirds) {
                                pest.anger = 0;
                                pest.state = 'fleeing';
                                pest.stateTimer = 600;
                            }
                        }
                        
                        // Score bonus
                        if (this.survivalStats) {
                            this.survivalStats.score += 5000;
                            this.survivalStats.currentObjective = { text: 'Blessing active - birds flee!', type: 'complete' };
                            this.updateSurvivalHUD();
                        }
                        
                        // Grand visual effect
                        for (let i = 0; i < 100; i++) {
                            this.particles.push({
                                x: x + 0.5 + (Math.random() - 0.5) * 10,
                                y: y + Math.random() * 8,
                                z: z + 0.5 + (Math.random() - 0.5) * 10,
                                vx: (Math.random() - 0.5) * 0.15,
                                vy: 0.1 + Math.random() * 0.15,
                                vz: (Math.random() - 0.5) * 0.15,
                                life: 180 + Math.random() * 120,
                                type: 'petal',
                                size: 4 + Math.random() * 4,
                                rotation: Math.random() * Math.PI * 2,
                                rotSpeed: (Math.random() - 0.5) * 0.2,
                                flutter: Math.random() * Math.PI * 2
                            });
                        }
                    }
                }
            },
            
            // Open chest UI - simply take all items
            openChest(x, y, z) {
                if (!this.chestContents) this.chestContents = {};
                
                const chestKey = `${x},${y},${z}`;
                const contents = this.chestContents[chestKey];
                
                if (contents && Array.isArray(contents) && contents.length > 0) {
                    // Take all items from chest
                    for (const item of contents) {
                        if (!item) continue;
                        const itemType = item.type || item.id;
                        const itemCount = item.count || 1;
                        
                        if (itemType) {
                            if (!this.addToInventory(itemType, itemCount)) {
                                // Inventory full - drop item
                                this.dropItem(x + 0.5, y + 1.5, z + 0.5, itemType, itemCount);
                            }
                        }
                    }
                    // Empty the chest
                    this.chestContents[chestKey] = [];
                    this.updateHotbarDisplay();
                }
            },
            
            // Drop currently held item
            dropHeldItem() {
                const slot = this.inventory.hotbar[this.selectedSlot];
                if (slot && slot.count > 0) {
                    // Drop one item in front of player
                    const dirX = -Math.sin(this.camera.rotY);
                    const dirZ = Math.cos(this.camera.rotY);
                    const itemId = slot.id || slot.type;
                    this.dropItem(
                        this.camera.x + dirX * 1.5,
                        this.camera.y,
                        this.camera.z + dirZ * 1.5,
                        itemId,
                        1
                    );
                    
                    slot.count--;
                    if (slot.count <= 0) {
                        this.inventory.hotbar[this.selectedSlot] = null;
                        this.selectedItem = null;
                    }
                    this.updateHotbarDisplay();
                }
            },
            
            // Debug console system
            debugConsoleOpen: false,
            debugNoclip: false,
            debugGodMode: false,
            debugShowCoords: false,
            debugFly: false,
            debugMoveSpeed: null,
            
            toggleDebugConsole() {
                this.debugConsoleOpen = !this.debugConsoleOpen;
                const consoleEl = document.getElementById('debugConsole');
                if (consoleEl) {
                    consoleEl.classList.toggle('active', this.debugConsoleOpen);
                    if (this.debugConsoleOpen) {
                        const input = document.getElementById('debugInput');
                        if (input) {
                            setTimeout(() => input.focus(), 50);
                        }
                        this.debugLog('Debug console opened. Type "help" for commands.', 'info');
                    }
                }
            },
            
            setupDebugConsole() {
                const input = document.getElementById('debugInput');
                if (input) {
                    input.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            const cmd = input.value.trim();
                            if (cmd) {
                                this.executeDebugCommand(cmd);
                                input.value = '';
                            }
                        }
                        if (e.key === '`' || e.key === '~') {
                            e.preventDefault();
                            this.toggleDebugConsole();
                        }
                        e.stopPropagation();
                    });
                    input.addEventListener('keyup', (e) => e.stopPropagation());
                }
            },
            
            debugLog(msg, type = 'normal') {
                const output = document.getElementById('debugOutput');
                if (output) {
                    const div = document.createElement('div');
                    div.className = type;
                    div.textContent = `> ${msg}`;
                    output.appendChild(div);
                    output.scrollTop = output.scrollHeight;
                    
                    // Limit log size
                    while (output.children.length > 100) {
                        output.removeChild(output.firstChild);
                    }
                }
            },
            
            executeDebugCommand(cmd) {
                const parts = cmd.toLowerCase().split(' ');
                const command = parts[0];
                const args = parts.slice(1);
                
                this.debugLog(cmd, 'normal');
                
                switch (command) {
                    case 'help':
                        this.debugLog('Commands:', 'info');
                        this.debugLog('  noclip - Toggle flying through walls', 'info');
                        this.debugLog('  god - Toggle invincibility', 'info');
                        this.debugLog('  coords - Toggle coordinate display', 'info');
                        this.debugLog('  tp <x> <y> <z> - Teleport to position', 'info');
                        this.debugLog('  give <item> [count] - Give item', 'info');
                        this.debugLog('  spawn <mob> [count] - Spawn mobs', 'info');
                        this.debugLog('    mobs: bird, fish, cat, creeper, bluebird', 'info');
                        this.debugLog('  time <ms> - Set bird event timer', 'info');
                        this.debugLog('  kill - Kill all mobs', 'info');
                        this.debugLog('  clear - Clear console', 'info');
                        this.debugLog('  pos - Show current position', 'info');
                        this.debugLog('  fly - Toggle flight mode', 'info');
                        this.debugLog('  speed <value> - Set move speed', 'info');
                        this.debugLog('  ritual - Complete ritual instantly', 'info');
                        this.debugLog('  score <value> - Set score', 'info');
                        this.debugLog('  temple - Teleport to ritual temple', 'info');
                        break;
                        
                    case 'noclip':
                        this.debugNoclip = !this.debugNoclip;
                        this.debugLog(`Noclip: ${this.debugNoclip ? 'ON' : 'OFF'}`, this.debugNoclip ? 'success' : 'warn');
                        break;
                        
                    case 'god':
                        this.debugGodMode = !this.debugGodMode;
                        this.debugLog(`God mode: ${this.debugGodMode ? 'ON' : 'OFF'}`, this.debugGodMode ? 'success' : 'warn');
                        break;
                        
                    case 'coords':
                        this.debugShowCoords = !this.debugShowCoords;
                        this.debugLog(`Coords display: ${this.debugShowCoords ? 'ON' : 'OFF'}`, 'success');
                        break;
                        
                    case 'fly':
                        this.debugFly = !this.debugFly;
                        this.debugLog(`Fly mode: ${this.debugFly ? 'ON' : 'OFF'}`, this.debugFly ? 'success' : 'warn');
                        break;
                        
                    case 'tp':
                        if (args.length >= 3) {
                            const x = parseFloat(args[0]);
                            const y = parseFloat(args[1]);
                            const z = parseFloat(args[2]);
                            if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
                                this.camera.x = x;
                                this.camera.y = y;
                                this.camera.z = z;
                                this.velocity = { x: 0, y: 0, z: 0 };
                                this.debugLog(`Teleported to ${x.toFixed(1)}, ${y.toFixed(1)}, ${z.toFixed(1)}`, 'success');
                            } else {
                                this.debugLog('Invalid coordinates', 'error');
                            }
                        } else {
                            this.debugLog('Usage: tp <x> <y> <z>', 'error');
                        }
                        break;
                        
                    case 'temple':
                        if (this.ritualTempleLocation) {
                            this.camera.x = this.ritualTempleLocation.x + 5;
                            this.camera.y = this.ritualTempleLocation.y + 3;
                            this.camera.z = this.ritualTempleLocation.z + 5;
                            this.velocity = { x: 0, y: 0, z: 0 };
                            this.debugLog('Teleported to Ritual Temple', 'success');
                        } else {
                            this.debugLog('Temple not found', 'error');
                        }
                        break;
                        
                    case 'pos':
                        this.debugLog(`Position: ${this.camera.x.toFixed(2)}, ${this.camera.y.toFixed(2)}, ${this.camera.z.toFixed(2)}`, 'info');
                        this.debugLog(`Rotation: ${(this.camera.rotX * 180 / Math.PI).toFixed(1)}Â°, ${(this.camera.rotY * 180 / Math.PI).toFixed(1)}Â°`, 'info');
                        break;
                        
                    case 'give':
                        if (args.length >= 1) {
                            const itemId = args[0];
                            const count = args.length >= 2 ? parseInt(args[1]) : 1;
                            if (this.blockColors[itemId] || this.itemTypes[itemId]) {
                                this.addToInventory(itemId, count);
                                this.debugLog(`Given ${count}x ${itemId}`, 'success');
                            } else {
                                this.debugLog(`Unknown item: ${itemId}`, 'error');
                                this.debugLog('Items: ' + Object.keys(this.itemTypes).slice(0, 10).join(', ') + '...', 'info');
                            }
                        } else {
                            this.debugLog('Usage: give <item> [count]', 'error');
                        }
                        break;
                        
                    case 'spawn':
                        const mobType = args[0];
                        const spawnCount = args.length >= 2 ? parseInt(args[1]) : 1;
                        const validMobs = ['bird', 'pest', 'fish', 'cat', 'creeper', 'bluebird'];
                        
                        if (mobType === 'bird' || mobType === 'pest') {
                            for (let i = 0; i < spawnCount; i++) this.spawnPestBird();
                            this.debugLog(`Spawned ${spawnCount} pest bird(s)`, 'success');
                        } else if (mobType === 'fish') {
                            for (let i = 0; i < spawnCount; i++) this.spawnFish();
                            this.debugLog(`Spawned ${spawnCount} fish`, 'success');
                        } else if (mobType === 'cat') {
                            for (let i = 0; i < spawnCount; i++) this.spawnCat();
                            this.debugLog(`Spawned ${spawnCount} cat(s)`, 'success');
                        } else if (mobType === 'creeper') {
                            for (let i = 0; i < spawnCount; i++) this.spawnCreeper();
                            this.debugLog(`Spawned ${spawnCount} creeper(s)`, 'success');
                        } else if (mobType === 'bluebird') {
                            for (let i = 0; i < spawnCount; i++) this.spawnBlueBird();
                            this.debugLog(`Spawned ${spawnCount} blue bird(s)`, 'success');
                        } else {
                            this.debugLog('Usage: spawn <mob> [count]', 'error');
                            this.debugLog('Mobs: ' + validMobs.join(', '), 'info');
                        }
                        break;
                        
                    case 'kill':
                        let totalKilled = 0;
                        totalKilled += this.pestBirds ? this.pestBirds.length : 0;
                        totalKilled += this.blueBirds ? this.blueBirds.length : 0;
                        totalKilled += this.creepers ? this.creepers.length : 0;
                        this.pestBirds = [];
                        this.blueBirds = [];
                        this.creepers = [];
                        this.debugLog(`Killed ${totalKilled} mobs`, 'success');
                        break;
                        
                    case 'time':
                        if (args.length >= 1) {
                            const time = parseInt(args[0]);
                            if (!isNaN(time) && this.birdEvent) {
                                this.birdEvent.timer = time;
                                this.debugLog(`Bird event timer set to ${time}ms`, 'success');
                            }
                        } else {
                            this.debugLog('Usage: time <ms>', 'error');
                        }
                        break;
                        
                    case 'clear':
                        const outputEl = document.getElementById('debugOutput');
                        if (outputEl) outputEl.innerHTML = '';
                        break;
                        
                    case 'speed':
                        if (args.length >= 1) {
                            this.debugMoveSpeed = parseFloat(args[0]);
                            this.debugLog(`Speed set to ${this.debugMoveSpeed}`, 'success');
                        } else {
                            this.debugLog('Usage: speed <value> (default: 0.12)', 'error');
                        }
                        break;
                        
                    case 'ritual':
                        this.ritualComplete = true;
                        this.ritualBlessingActive = true;
                        this.ritualBlessingTimer = 60 * 60 * 10;
                        this.socketsFilled = {
                            'petalSocket': true, 'ropeSocket': true, 'charmSocket': true,
                            'plaqueSocket': true, 'incenseSocket': true
                        };
                        this.triggerRitualReward();
                        this.debugLog('Ritual completed!', 'success');
                        break;
                        
                    case 'score':
                        if (args.length >= 1 && this.survivalStats) {
                            this.survivalStats.score = parseInt(args[0]);
                            this.updateSurvivalHUD();
                            this.debugLog(`Score set to ${this.survivalStats.score}`, 'success');
                        }
                        break;
                        
                    default:
                        this.debugLog(`Unknown command: ${command}`, 'error');
                }
            },
            
            // Ritual reward - creative bonus for completing the temple ritual
            triggerRitualReward() {
                // Show blessing effect
                if (this.birdEvent) {
                    this.showBirdAlert('ðŸŒ¸ DIVINE BLESSING ACTIVATED! ðŸŒ¸');
                }
                
                // 1. Grant player ritual flight ability (separate from debug fly)
                this.ritualFlight = true;
                this.ritualFlightTimer = 60 * 60 * 2; // 2 minutes of flight
                
                // 2. Create protective barrier that repels birds
                this.ritualBarrierActive = true;
                
                // 3. Give player special items
                this.addToInventory('berdger', 1);
                this.addToInventory('apple', 32);
                
                // 4. Massive score bonus
                if (this.survivalStats) {
                    this.survivalStats.score += 10000;
                    this.survivalStats.wave++;
                    this.survivalStats.currentObjective = { text: 'âœ¨ Divine protection active!', type: 'blessed' };
                    this.updateSurvivalHUD();
                }
                
                // 5. All pest birds flee
                for (const pest of this.pestBirds) {
                    pest.state = 'fleeing';
                    pest.stateTimer = 1200; // 20 seconds flee
                    pest.anger = 0;
                }
                
                // 6. Spawn golden particles around player
                for (let i = 0; i < 100; i++) {
                    this.particles.push({
                        x: this.camera.x + (Math.random() - 0.5) * 10,
                        y: this.camera.y + Math.random() * 8 - 2,
                        z: this.camera.z + (Math.random() - 0.5) * 10,
                        vx: (Math.random() - 0.5) * 0.15,
                        vy: 0.1 + Math.random() * 0.2,
                        vz: (Math.random() - 0.5) * 0.15,
                        life: 200 + Math.random() * 100,
                        type: 'blessing',
                        size: 4 + Math.random() * 4
                    });
                }
            },
            
            // Batch pickup notification system
            pickupQueue: {},
            pickupTimer: null,
            
            queuePickupNotification(type, count) {
                if (!this.pickupQueue[type]) {
                    this.pickupQueue[type] = 0;
                }
                this.pickupQueue[type] += count;
                
                // Clear existing timer and set new one
                if (this.pickupTimer) {
                    clearTimeout(this.pickupTimer);
                }
                
                // Wait 500ms for more pickups before showing notification
                this.pickupTimer = setTimeout(() => {
                    this.flushPickupNotifications();
                }, 500);
            },
            
            flushPickupNotifications() {
                const container = document.getElementById('pickupNotification');
                if (!container) return;
                
                const itemNames = {
                    grass: 'Grass Block', dirt: 'Dirt', stone: 'Stone', wood: 'Wood',
                    appleLeaves: 'Apple Leaves', leaves: 'Leaves', sand: 'Sand', brick: 'Brick',
                    ak47: 'AK-47', water_bucket: 'Water Bucket', lava_bucket: 'Lava Bucket',
                    obsidian: 'Obsidian', cherryWood: 'Cherry Wood', cherryLeaves: 'Cherry Leaves',
                    chest: 'Chest', seeds: 'Seeds', berdger: 'The Berdger', apple: 'Apple',
                    sakuraPetal: 'Cherry Petal', shimenawa: 'Sacred Rope', omamori: 'Charm',
                    ema: 'Wish Plaque', incense: 'Incense', whiteBrick: 'White Brick',
                    redBrick: 'Red Brick', glowstone: 'Glowstone', ritualStone: 'Ritual Stone'
                };
                
                for (const [type, count] of Object.entries(this.pickupQueue)) {
                    if (count === 0) continue;
                    
                    const notification = document.createElement('div');
                    notification.className = 'pickup-item';
                    
                    // Create mini block canvas
                    const miniCanvas = document.createElement('canvas');
                    miniCanvas.width = 24;
                    miniCanvas.height = 24;
                    this.drawMiniBlock(miniCanvas, type);
                    
                    notification.innerHTML = `
                        <span class="pickup-icon"></span>
                        <span>+${count} ${itemNames[type] || type}</span>
                    `;
                    notification.querySelector('.pickup-icon').appendChild(miniCanvas);
                    
                    container.appendChild(notification);
                    
                    // Remove after animation
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.parentNode.removeChild(notification);
                        }
                    }, 2000);
                }
                
                // Clear queue
                this.pickupQueue = {};
                this.pickupTimer = null;
            },
            
            // Fluid dynamics simulation - not yet implemented
            // Fluid dynamics simulation - spreads water/lava realistically
            // Set fluid level at position
            setFluidLevel(x, y, z, level) {
                const key = `${x},${y},${z}`;
                if (level <= 0) {
                    delete this.fluidLevels[key];
                } else {
                    this.fluidLevels[key] = Math.min(8, Math.max(1, level));
                }
            },
            
            getFluidLevel(x, y, z) {
                return this.fluidLevels[`${x},${y},${z}`] || 0;
            },
            
            updateFluids() {
                // Process fluid updates slowly for visible spreading effect
                if (!this.fluidUpdateTimer) this.fluidUpdateTimer = 0;
                this.fluidUpdateTimer++;
                if (this.fluidUpdateTimer < 8) return;  // Update every 8 frames (~7.5 updates/sec)
                this.fluidUpdateTimer = 0;
                
                // Process 1-2 fluid blocks per update cycle for gradual spread
                const maxUpdates = 2;
                let processed = 0;
                
                while (this.fluidUpdates.length > 0 && processed < maxUpdates) {
                    const fluid = this.fluidUpdates.shift();
                    processed++;
                    
                    // Skip if block is no longer fluid (was replaced by player)
                    const currentBlock = this.getBlock(fluid.x, fluid.y, fluid.z);
                    if (!currentBlock || !this.fluidBlocks.includes(currentBlock)) {
                        // Clean up fluid level if block was removed
                        this.setFluidLevel(fluid.x, fluid.y, fluid.z, 0);
                        continue;
                    }
                    
                    const currentLevel = fluid.level || 8;
                    
                    // Priority 1: Flow DOWN (gravity)
                    const belowBlock = this.getBlock(fluid.x, fluid.y - 1, fluid.z);
                    
                    // Check for water/lava interactions when flowing down
                    if (belowBlock === 'water' && fluid.type === 'lava') {
                        // Lava falling onto water = STONE
                        this.setBlock(fluid.x, fluid.y - 1, fluid.z, 'stone');
                        this.setFluidLevel(fluid.x, fluid.y - 1, fluid.z, 0);
                        continue;
                    } else if (belowBlock === 'lava' && fluid.type === 'water') {
                        // Water falling onto lava = OBSIDIAN
                        this.setBlock(fluid.x, fluid.y - 1, fluid.z, 'obsidian');
                        this.setFluidLevel(fluid.x, fluid.y - 1, fluid.z, 0);
                        continue;
                    }
                    
                    if (!belowBlock) {
                        // Empty space below - flow down with full level (falling fluid is full)
                        this.setBlock(fluid.x, fluid.y - 1, fluid.z, fluid.type);
                        this.setFluidLevel(fluid.x, fluid.y - 1, fluid.z, 8);
                        this.fluidUpdates.push({
                            x: fluid.x,
                            y: fluid.y - 1,
                            z: fluid.z,
                            type: fluid.type,
                            level: 8  // Falling fluid has full level
                        });
                        continue;  // Prioritize downward flow
                    }
                    
                    // Priority 2: Spread HORIZONTALLY (only if can't flow down)
                    // Horizontal spread decreases level by 1
                    const spreadLevel = currentLevel - 1;
                    if (spreadLevel <= 0) continue;  // Can't spread further
                    
                    if (belowBlock && !this.fluidBlocks.includes(belowBlock)) {
                        // Solid block below - spread horizontally
                        const directions = [
                            { x: 1, z: 0 },
                            { x: -1, z: 0 },
                            { x: 0, z: 1 },
                            { x: 0, z: -1 }
                        ];
                        
                        // Randomize spread direction for natural look
                        for (let i = directions.length - 1; i > 0; i--) {
                            const j = Math.floor(Math.random() * (i + 1));
                            [directions[i], directions[j]] = [directions[j], directions[i]];
                        }
                        
                        for (const dir of directions) {
                            const nx = fluid.x + dir.x;
                            const nz = fluid.z + dir.z;
                            const neighborBlock = this.getBlock(nx, fluid.y, nz);
                            const neighborLevel = this.getFluidLevel(nx, fluid.y, nz);
                            
                            // Water + Lava horizontal interaction
                            if (fluid.type === 'lava' && neighborBlock === 'water') {
                                // Lava touching water horizontally = stone (at neighbor)
                                this.setBlock(nx, fluid.y, nz, 'stone');
                                this.setFluidLevel(nx, fluid.y, nz, 0);
                                continue;
                            } else if (fluid.type === 'water' && neighborBlock === 'lava') {
                                // Water touching lava horizontally = stone (at neighbor) 
                                this.setBlock(nx, fluid.y, nz, 'stone');
                                this.setFluidLevel(nx, fluid.y, nz, 0);
                                continue;
                            }
                            
                            // Spread to empty spaces or lower-level same fluid
                            if (!neighborBlock) {
                                this.setBlock(nx, fluid.y, nz, fluid.type);
                                this.setFluidLevel(nx, fluid.y, nz, spreadLevel);
                                this.fluidUpdates.push({
                                    x: nx,
                                    y: fluid.y,
                                    z: nz,
                                    type: fluid.type,
                                    level: spreadLevel
                                });
                            } else if (neighborBlock === fluid.type && neighborLevel < spreadLevel) {
                                // Flow into lower-level same fluid
                                this.setFluidLevel(nx, fluid.y, nz, spreadLevel);
                                this.fluidUpdates.push({
                                    x: nx,
                                    y: fluid.y,
                                    z: nz,
                                    type: fluid.type,
                                    level: spreadLevel
                                });
                            }
                        }
                    }
                }
            },
            
            // Toggle inventory screen
            toggleInventory() {
                this.inventoryOpen = !this.inventoryOpen;
                const invScreen = document.getElementById('inventoryScreen');
                if (invScreen) {
                    invScreen.classList.toggle('active', this.inventoryOpen);
                }
                
                if (this.inventoryOpen) {
                    this.inventoryHeldItem = null; // Clear held item when opening
                    this.renderInventory();
                    // Release pointer lock but DON'T pause - game continues in background
                    if (document.pointerLockElement) {
                        document.exitPointerLock();
                    }
                } else {
                    this.inventoryHeldItem = null; // Clear held item when closing
                    // Set flag to prevent pause from pointer lock release
                    this.justClosedInventory = true;
                    setTimeout(() => { this.justClosedInventory = false; }, 100);
                    // Re-request pointer lock when closing inventory
                    if (!this.isPaused) {
                        this.canvas.requestPointerLock();
                    }
                }
            },
            
            // Render inventory UI
            renderInventory() {
                const invScreen = document.getElementById('inventoryScreen');
                if (!invScreen) return;
                
                // Helper to get readable item name
                const getItemName = (slot) => {
                    if (!slot) return '';
                    const id = slot.id || slot.type;
                    const names = {
                        grass: 'Grass Block', dirt: 'Dirt', stone: 'Stone', wood: 'Wood',
                        leaves: 'Leaves', water: 'Water', sand: 'Sand', brick: 'Brick',
                        ak47: 'AK-47', water_bucket: 'Water Bucket', lava_bucket: 'Lava Bucket',
                        lava: 'Lava', obsidian: 'Obsidian', cherryWood: 'Cherry Wood',
                        cherryLeaves: 'Cherry Leaves', chest: 'Chest',
                        ritualChest: 'Ritual Chest', buildingChest: 'Building Chest',
                        seeds: 'Seeds', berdger: 'The Berdger',
                        sakuraPetal: 'Sacred Cherry Petal', shimenawa: 'Sacred Rope',
                        omamori: 'Protective Charm', ema: 'Wooden Wish Plaque',
                        incense: 'Purifying Incense'
                    };
                    return names[id] || id;
                };
                
                let html = '<div class="inventory-container">';
                html += '<h2>Inventory</h2>';
                
                // Crafting section
                html += '<div class="crafting-section">';
                html += '<h3>Crafting</h3>';
                html += '<div class="recipe-list">';
                for (const recipe of this.recipes) {
                    const canCraft = this.canCraftRecipe(recipe);
                    html += `<div class="recipe ${canCraft ? 'craftable' : 'disabled'}" data-recipe="${recipe.name}">`;
                    html += `<span class="recipe-name">${recipe.name}</span>`;
                    html += `<span class="recipe-ingredients">`;
                    recipe.ingredients.forEach(ing => {
                        html += `${ing.count}x ${ing.id} `;
                    });
                    html += `</span>`;
                    html += `<span class="recipe-result">â†’ ${recipe.result.count}x ${recipe.result.id}</span>`;
                    if (canCraft) {
                        html += `<button class="craft-btn" onclick="minecraftGame.craftRecipe('${recipe.name}')">Craft</button>`;
                    }
                    html += '</div>';
                }
                html += '</div></div>';
                
                // Hotbar
                html += '<div class="inv-hotbar">';
                html += '<h3>Hotbar</h3>';
                html += '<div class="inv-slots" id="hotbarSlots">';
                this.inventory.hotbar.forEach((slot, i) => {
                    const emoji = this.getItemEmoji(slot);
                    const hasItem = slot && slot.count > 0;
                    const isHeld = this.inventoryHeldItem && this.inventoryHeldItem.source === 'hotbar' && this.inventoryHeldItem.index === i;
                    const tooltip = hasItem ? getItemName(slot) : '';
                    html += `<div class="inv-slot ${i === this.selectedSlot ? 'selected' : ''} ${hasItem ? 'has-item' : ''} ${isHeld ? 'held' : ''}" 
                        data-source="hotbar" data-index="${i}" ${tooltip ? `data-tooltip="${tooltip}"` : ''}
                        draggable="${hasItem}">${emoji}<span class="count">${slot ? slot.count : ''}</span></div>`;
                });
                html += '</div></div>';
                
                // Main inventory
                html += '<div class="inv-main">';
                html += '<h3>Storage</h3>';
                html += '<div class="inv-slots" id="storageSlots">';
                for (let i = 0; i < 27; i++) {
                    const slot = this.inventory.main[i];
                    const hasItem = slot && slot.count > 0;
                    const isHeld = this.inventoryHeldItem && this.inventoryHeldItem.source === 'main' && this.inventoryHeldItem.index === i;
                    if (slot) {
                        const emoji = this.getItemEmoji(slot);
                        const tooltip = getItemName(slot);
                        html += `<div class="inv-slot has-item ${isHeld ? 'held' : ''}" data-source="main" data-index="${i}" ${tooltip ? `data-tooltip="${tooltip}"` : ''} draggable="true">${emoji}<span class="count">${slot.count}</span></div>`;
                    } else {
                        html += `<div class="inv-slot empty" data-source="main" data-index="${i}" draggable="false"></div>`;
                    }
                }
                html += '</div></div>';
                
                html += '<p class="inv-hint">Click items to pick up/place | Drag also works | Press E or ESC to close</p>';
                html += '</div>';
                
                invScreen.innerHTML = html;
                
                // Setup drag and drop handlers
                this.setupInventoryDragDrop();
            },
            
            setupInventoryDragDrop() {
                const invScreen = document.getElementById('inventoryScreen');
                const slots = document.querySelectorAll('#inventoryScreen .inv-slot');
                
                // Track held item for click-to-move
                if (!this.inventoryHeldItem) this.inventoryHeldItem = null;
                
                // Prevent page scrolling when scrolling inside inventory
                const invContainer = invScreen.querySelector('.inventory-container');
                if (invContainer) {
                    invContainer.addEventListener('wheel', (e) => {
                        e.stopPropagation();
                        // Allow scrolling inside the container but prevent it from bubbling
                        const { scrollTop, scrollHeight, clientHeight } = invContainer;
                        const atTop = scrollTop === 0;
                        const atBottom = scrollTop + clientHeight >= scrollHeight;
                        
                        // Only prevent default if we're trying to scroll beyond bounds
                        if ((atTop && e.deltaY < 0) || (atBottom && e.deltaY > 0)) {
                            e.preventDefault();
                        }
                    }, { passive: false });
                }
                
                // Prevent scroll on the inventory screen during drag operations
                invScreen.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                });
                
                invScreen.addEventListener('drop', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                });
                
                slots.forEach(slot => {
                    // Click to select/place items (more reliable than drag)
                    slot.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        const source = slot.dataset.source;
                        const index = parseInt(slot.dataset.index);
                        const slotArray = source === 'hotbar' ? this.inventory.hotbar : this.inventory.main;
                        const clickedItem = slotArray[index];
                        
                        if (this.inventoryHeldItem) {
                            // Place held item in this slot (swap if occupied)
                            this.swapInventorySlots(
                                this.inventoryHeldItem.source,
                                this.inventoryHeldItem.index,
                                source,
                                index
                            );
                            this.inventoryHeldItem = null;
                            this.renderInventory();
                            this.updateHotbar();
                            this.updateHotbarDisplay();
                        } else if (clickedItem && clickedItem.count > 0) {
                            // Pick up this item
                            this.inventoryHeldItem = { source, index };
                            this.renderInventory();
                        }
                    });
                    
                    // Also support drag and drop
                    slot.addEventListener('dragstart', (e) => {
                        e.stopPropagation();
                        const source = slot.dataset.source;
                        const index = parseInt(slot.dataset.index);
                        this.draggedItem = { source, index };
                        slot.classList.add('dragging');
                        e.dataTransfer.effectAllowed = 'move';
                        e.dataTransfer.setDragImage(slot, 20, 20);
                    });
                    
                    slot.addEventListener('dragend', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        slot.classList.remove('dragging');
                        this.draggedItem = null;
                    });
                    
                    slot.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        e.dataTransfer.dropEffect = 'move';
                        slot.classList.add('drag-over');
                    });
                    
                    slot.addEventListener('dragleave', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        slot.classList.remove('drag-over');
                    });
                    
                    slot.addEventListener('drop', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        slot.classList.remove('drag-over');
                        
                        if (!this.draggedItem) return;
                        
                        const targetSource = slot.dataset.source;
                        const targetIndex = parseInt(slot.dataset.index);
                        
                        // Store scroll position
                        const invContainer = document.querySelector('.inventory-container');
                        const scrollTop = invContainer ? invContainer.scrollTop : 0;
                        
                        // Swap items between source and target
                        this.swapInventorySlots(
                            this.draggedItem.source, 
                            this.draggedItem.index,
                            targetSource,
                            targetIndex
                        );
                        
                        this.draggedItem = null;
                        this.renderInventory();
                        this.updateHotbar();
                        this.updateHotbarDisplay();
                        
                        // Restore scroll position
                        const newContainer = document.querySelector('.inventory-container');
                        if (newContainer) {
                            newContainer.scrollTop = scrollTop;
                        }
                    });
                });
            },
            
            swapInventorySlots(srcType, srcIdx, destType, destIdx) {
                const srcArray = srcType === 'hotbar' ? this.inventory.hotbar : this.inventory.main;
                const destArray = destType === 'hotbar' ? this.inventory.hotbar : this.inventory.main;
                
                // Get items
                const srcItem = srcArray[srcIdx];
                const destItem = destArray[destIdx];
                
                // Swap
                srcArray[srcIdx] = destItem;
                destArray[destIdx] = srcItem;
                
                // Update selected block/item if hotbar changed
                if (srcType === 'hotbar' || destType === 'hotbar') {
                    const currentSlot = this.inventory.hotbar[this.selectedSlot];
                    if (currentSlot) {
                        if (currentSlot.type === 'block') {
                            this.selectedBlock = currentSlot.id;
                            this.selectedItem = null;
                        } else if (currentSlot.type === 'weapon') {
                            this.selectedItem = currentSlot.id;
                            this.selectedBlock = null;
                        }
                    } else {
                        this.selectedBlock = null;
                        this.selectedItem = null;
                    }
                }
            },
            
            getItemEmoji(slot) {
                if (!slot) return '';
                const id = slot.id || slot.type;
                const emojis = {
                    grass: 'ðŸŒ¿', dirt: 'ðŸŸ«', stone: 'ðŸª¨', wood: 'ðŸªµ',
                    leaves: 'ðŸŒ¸', water: 'ðŸ’§', sand: 'ðŸ–ï¸', brick: 'ðŸ§±',
                    ak47: 'ðŸ”«', water_bucket: 'ðŸª£', lava_bucket: 'ðŸ«§',
                    lava: 'ðŸ”¥', obsidian: 'ðŸŸ£', cherryWood: 'ðŸªµ', cherryLeaves: 'ðŸŒ¸',
                    chest: 'ðŸ“¦', ritualChest: 'ðŸ“¦', buildingChest: 'ðŸ“¦',
                    seeds: 'ðŸŒ¾', berdger: 'ðŸ”',
                    sakuraPetal: 'ðŸŒ¸', shimenawa: 'ðŸª¢', omamori: 'ðŸŽ€',
                    ema: 'ðŸª§', incense: 'ðŸ•¯ï¸'
                };
                return emojis[id] || 'â“';
            },
            
            canCraftRecipe(recipe) {
                for (const ingredient of recipe.ingredients) {
                    const total = this.countItem(ingredient.id);
                    if (total < ingredient.count) return false;
                }
                return true;
            },
            
            countItem(itemId) {
                let count = 0;
                for (const slot of this.inventory.hotbar) {
                    if (slot && slot.id === itemId) count += slot.count;
                }
                for (const slot of this.inventory.main) {
                    if (slot && slot.id === itemId) count += slot.count;
                }
                return count;
            },
            
            craftRecipe(recipeName) {
                const recipe = this.recipes.find(r => r.name === recipeName);
                if (!recipe || !this.canCraftRecipe(recipe)) return;
                
                // Remove ingredients
                for (const ingredient of recipe.ingredients) {
                    this.removeItem(ingredient.id, ingredient.count);
                }
                
                // Add result
                this.addItem(recipe.result);
                
                // Re-render inventory
                this.renderInventory();
            },
            
            removeItem(itemId, count) {
                let remaining = count;
                
                // Remove from hotbar first
                for (const slot of this.inventory.hotbar) {
                    if (slot && slot.id === itemId && remaining > 0) {
                        const remove = Math.min(slot.count, remaining);
                        slot.count -= remove;
                        remaining -= remove;
                    }
                }
                
                // Then from main inventory
                for (const slot of this.inventory.main) {
                    if (slot && slot.id === itemId && remaining > 0) {
                        const remove = Math.min(slot.count, remaining);
                        slot.count -= remove;
                        remaining -= remove;
                    }
                }
            },
            
            addItem(item) {
                // Try to stack with existing items first
                for (const slot of this.inventory.hotbar) {
                    if (slot && slot.id === item.id && slot.count < 64) {
                        const add = Math.min(64 - slot.count, item.count);
                        slot.count += add;
                        item.count -= add;
                        if (item.count <= 0) return;
                    }
                }
                
                for (const slot of this.inventory.main) {
                    if (slot && slot.id === item.id && slot.count < 64) {
                        const add = Math.min(64 - slot.count, item.count);
                        slot.count += add;
                        item.count -= add;
                        if (item.count <= 0) return;
                    }
                }
                
                // Find empty slot
                for (let i = 0; i < this.inventory.main.length; i++) {
                    if (!this.inventory.main[i]) {
                        this.inventory.main[i] = { ...item };
                        return;
                    }
                }
            },
            
            raycast() {
                // Calculate ray direction from camera angles
                // rotY = yaw (horizontal), rotX = pitch (vertical)
                const pitch = this.camera.rotX;
                const yaw = this.camera.rotY;
                
                const cosPitch = Math.cos(pitch);
                const sinPitch = Math.sin(pitch);
                const cosYaw = Math.cos(yaw);
                const sinYaw = Math.sin(yaw);
                
                // Direction vector (matches movement and projection)
                const dx = -sinYaw * cosPitch;
                const dy = -sinPitch;
                const dz = cosYaw * cosPitch;
                
                // Normalize direction (important for accurate distance calculation)
                const len = Math.sqrt(dx * dx + dy * dy + dz * dz);
                const dirX = dx / len;
                const dirY = dy / len;
                const dirZ = dz / len;
                
                // Ray origin - start slightly in front of camera to avoid self-intersection
                const startOffset = 0.1;
                let x = this.camera.x + dirX * startOffset;
                let y = this.camera.y + dirY * startOffset;
                let z = this.camera.z + dirZ * startOffset;
                
                // Current voxel position
                let voxelX = Math.floor(x);
                let voxelY = Math.floor(y);
                let voxelZ = Math.floor(z);
                
                // Step direction (+1 or -1)
                const stepX = dirX >= 0 ? 1 : -1;
                const stepY = dirY >= 0 ? 1 : -1;
                const stepZ = dirZ >= 0 ? 1 : -1;
                
                // Distance between voxel boundaries along each axis
                const tDeltaX = Math.abs(1 / dirX);
                const tDeltaY = Math.abs(1 / dirY);
                const tDeltaZ = Math.abs(1 / dirZ);
                
                // Distance to first voxel boundary
                let tMaxX, tMaxY, tMaxZ;
                
                if (dirX > 0) {
                    tMaxX = (voxelX + 1 - x) / dirX;
                } else if (dirX < 0) {
                    tMaxX = (voxelX - x) / dirX;
                } else {
                    tMaxX = Infinity;
                }
                
                if (dirY > 0) {
                    tMaxY = (voxelY + 1 - y) / dirY;
                } else if (dirY < 0) {
                    tMaxY = (voxelY - y) / dirY;
                } else {
                    tMaxY = Infinity;
                }
                
                if (dirZ > 0) {
                    tMaxZ = (voxelZ + 1 - z) / dirZ;
                } else if (dirZ < 0) {
                    tMaxZ = (voxelZ - z) / dirZ;
                } else {
                    tMaxZ = Infinity;
                }
                
                // Track the face we entered from (for block placement)
                let enteredFace = null;
                
                // Maximum reach distance (in blocks)
                const maxDistance = 6;
                let t = 0;
                
                // Track last non-fluid entry face for proper placement
                let lastSolidFace = null;
                
                // Track if ray passed through water
                let throughWater = false;
                let throughLava = false;
                
                // DDA traversal loop
                for (let i = 0; i < 100; i++) { // safety limit
                    // Check current voxel for block
                    const block = this.getBlock(voxelX, voxelY, voxelZ);
                    if (block) {
                        // Skip fluid blocks - continue raycast through them
                        if (block === 'water' || block === 'lava') {
                            // Track which fluid we passed through
                            if (block === 'water') throughWater = true;
                            if (block === 'lava') throughLava = true;
                            // Don't update lastSolidFace, just continue
                        } else {
                            // Hit a solid block! Calculate placement position
                            let placePos = null;
                            // Use lastSolidFace if we came through fluids, otherwise use enteredFace
                            const placeFace = lastSolidFace || enteredFace;
                            if (placeFace) {
                                placePos = {
                                    x: voxelX + placeFace.x,
                                    y: voxelY + placeFace.y,
                                    z: voxelZ + placeFace.z
                                };
                            }
                            
                            return {
                                hit: { x: voxelX, y: voxelY, z: voxelZ },
                                place: placePos,
                                block: block,
                                throughWater: throughWater,
                                throughLava: throughLava
                            };
                        }
                    } else {
                        // Empty space - update lastSolidFace
                        lastSolidFace = enteredFace;
                    }
                    
                    // Step to next voxel (choose axis with smallest tMax)
                    if (tMaxX < tMaxY && tMaxX < tMaxZ) {
                        t = tMaxX;
                        if (t > maxDistance) break;
                        voxelX += stepX;
                        tMaxX += tDeltaX;
                        enteredFace = { x: -stepX, y: 0, z: 0 };
                    } else if (tMaxY < tMaxZ) {
                        t = tMaxY;
                        if (t > maxDistance) break;
                        voxelY += stepY;
                        tMaxY += tDeltaY;
                        enteredFace = { x: 0, y: -stepY, z: 0 };
                    } else {
                        t = tMaxZ;
                        if (t > maxDistance) break;
                        voxelZ += stepZ;
                        tMaxZ += tDeltaZ;
                        enteredFace = { x: 0, y: 0, z: -stepZ };
                    }
                }
                
                // No block hit within range
                return null;
            },
            
            update() {
                if (!this.isActive || this.isPaused) return;
                
                // Update weapon cooldowns
                if (this.shootCooldown > 0) this.shootCooldown--;
                if (this.muzzleFlash > 0) this.muzzleFlash--;
                
                // Update ritual flight timer (separate from debug fly)
                if (this.ritualFlightTimer > 0) {
                    this.ritualFlightTimer--;
                    if (this.ritualFlightTimer <= 0) {
                        this.ritualFlight = false;
                    }
                }
                
                const baseSpeed = this.debugMoveSpeed || 0.12;
                const canFly = this.debugNoclip || this.debugFly || this.ritualFlight;
                const speed = canFly ? baseSpeed * 2 : baseSpeed;
                // Forward direction matches camera view: (-sin(rotY), cos(rotY))
                const sin = Math.sin(this.camera.rotY);
                const cos = Math.cos(this.camera.rotY);
                
                // --- NOCLIP/FLY MODE ---
                if (this.debugNoclip || this.debugFly) {
                    let moveX = 0, moveY = 0, moveZ = 0;
                    
                    // Forward/backward (W/S) - includes vertical component when looking up/down
                    if (this.keys['w']) {
                        moveX -= sin * Math.cos(this.camera.rotX) * speed;
                        moveY -= Math.sin(this.camera.rotX) * speed;
                        moveZ += cos * Math.cos(this.camera.rotX) * speed;
                    }
                    if (this.keys['s']) {
                        moveX += sin * Math.cos(this.camera.rotX) * speed;
                        moveY += Math.sin(this.camera.rotX) * speed;
                        moveZ -= cos * Math.cos(this.camera.rotX) * speed;
                    }
                    // Strafe (A/D)
                    if (this.keys['a']) {
                        moveX -= cos * speed;
                        moveZ -= sin * speed;
                    }
                    if (this.keys['d']) {
                        moveX += cos * speed;
                        moveZ += sin * speed;
                    }
                    // Up/Down (Space/Shift)
                    if (this.keys[' ']) moveY += speed;
                    if (this.keys['shift']) moveY -= speed;
                    
                    // Apply movement (no collision in noclip, collision in debug fly)
                    if (this.debugNoclip) {
                        this.camera.x += moveX;
                        this.camera.y += moveY;
                        this.camera.z += moveZ;
                    } else {
                        // Debug fly mode still has collision
                        this.camera.x += moveX;
                        this.camera.y += moveY;
                        this.camera.z += moveZ;
                    }
                    
                    // Reset velocity
                    this.velocity = { x: 0, y: 0, z: 0 };
                    return; // Skip normal physics
                }
                
                // --- RITUAL FLIGHT MODE (with collision) ---
                if (this.ritualFlight) {
                    let moveX = 0, moveY = 0, moveZ = 0;
                    
                    // Horizontal movement
                    if (this.keys['w']) {
                        moveX -= sin * speed;
                        moveZ += cos * speed;
                    }
                    if (this.keys['s']) {
                        moveX += sin * speed;
                        moveZ -= cos * speed;
                    }
                    if (this.keys['a']) {
                        moveX -= cos * speed;
                        moveZ -= sin * speed;
                    }
                    if (this.keys['d']) {
                        moveX += cos * speed;
                        moveZ += sin * speed;
                    }
                    // Vertical flight controls
                    if (this.keys[' ']) moveY += speed;
                    if (this.keys['shift']) moveY -= speed;
                    
                    // Apply with simple collision check
                    const newX = this.camera.x + moveX;
                    const newY = this.camera.y + moveY;
                    const newZ = this.camera.z + moveZ;
                    
                    const feetY = Math.floor(newY - this.playerEyeHeight);
                    const headY = Math.floor(newY);
                    const px = Math.floor(newX);
                    const pz = Math.floor(newZ);
                    
                    let canMove = true;
                    for (let checkY = feetY; checkY <= headY; checkY++) {
                        const block = this.getBlock(px, checkY, pz);
                        if (block && !this.fluidBlocks.includes(block)) {
                            canMove = false;
                            break;
                        }
                    }
                    
                    if (canMove) {
                        this.camera.x = newX;
                        this.camera.y = newY;
                        this.camera.z = newZ;
                    }
                    
                    this.velocity = { x: 0, y: 0, z: 0 };
                    return; // Skip normal physics
                }
                
                // --- FLUID DETECTION ---
                const playerFeetY = this.camera.y - this.playerEyeHeight;
                const playerHeadY = playerFeetY + this.playerHeight;
                const px = Math.floor(this.camera.x);
                const pz = Math.floor(this.camera.z);
                
                // Check fluid at feet, waist, and head
                const feetBlock = this.getBlock(px, Math.floor(playerFeetY), pz);
                const waistBlock = this.getBlock(px, Math.floor(playerFeetY + 0.9), pz);
                const headBlock = this.getBlock(px, Math.floor(playerHeadY - 0.1), pz);
                
                const feetInWater = feetBlock === 'water';
                const feetInLava = feetBlock === 'lava';
                const waistInWater = waistBlock === 'water';
                const waistInLava = waistBlock === 'lava';
                const headInWater = headBlock === 'water';
                const headInLava = headBlock === 'lava';
                
                // Determine swimming state (in fluid at feet or waist level)
                const inWater = feetInWater || waistInWater;
                const inLava = feetInLava || waistInLava;
                const swimming = inWater || inLava;
                const submerged = headInWater || headInLava;
                
                // Store fluid state for rendering effects
                this.inWater = inWater || headInWater;
                this.inLava = inLava || headInLava;
                this.swimming = swimming;
                this.headSubmergedWater = headInWater;  // Only show blue overlay when head is underwater
                this.headSubmergedLava = headInLava;    // Only show lava overlay when head is in lava
                
                // Apply speed modifier when in fluid
                let speedMod = 1.0;
                if (inWater) speedMod = 0.65;  // Water slows to 65%
                if (inLava) speedMod = 0.35;   // Lava slows to 35%
                
                let moveX = 0;
                let moveZ = 0;
                const walkSpeed = baseSpeed;
                
                // Forward/backward (W/S)
                if (this.keys['w']) {
                    moveX -= sin * walkSpeed * speedMod;
                    moveZ += cos * walkSpeed * speedMod;
                }
                if (this.keys['s']) {
                    moveX += sin * walkSpeed * speedMod;
                    moveZ -= cos * walkSpeed * speedMod;
                }
                // Strafe left/right (A/D) - perpendicular to view
                if (this.keys['a']) {
                    moveX -= cos * walkSpeed * speedMod;
                    moveZ -= sin * walkSpeed * speedMod;
                }
                if (this.keys['d']) {
                    moveX += cos * walkSpeed * speedMod;
                    moveZ += sin * walkSpeed * speedMod;
                }
                
                // Track old position
                const oldX = this.camera.x;
                const oldZ = this.camera.z;
                
                // Improved collision detection with smaller steps and wall sliding
                const playerRadius = 0.25; // Slightly smaller for tighter spaces
                const playerHeight = 1.8;
                
                // First, check if we're currently stuck and need to escape
                if (this.collidesAt(this.camera.x, this.camera.y, this.camera.z, playerRadius, playerHeight)) {
                    // EMERGENCY UNSTUCK - aggressive push out
                    let escaped = false;
                    for (let pushDist = 0.1; pushDist <= 1.5 && !escaped; pushDist += 0.1) {
                        const escapeAngles = [0, 45, 90, 135, 180, 225, 270, 315];
                        for (const angle of escapeAngles) {
                            const rad = angle * Math.PI / 180;
                            const testX = this.camera.x + Math.cos(rad) * pushDist;
                            const testZ = this.camera.z + Math.sin(rad) * pushDist;
                            if (!this.collidesAt(testX, this.camera.y, testZ, playerRadius, playerHeight)) {
                                this.camera.x = testX;
                                this.camera.z = testZ;
                                escaped = true;
                                break;
                            }
                        }
                        // Also try pushing up
                        if (!escaped && !this.collidesAt(this.camera.x, this.camera.y + pushDist, this.camera.z, playerRadius, playerHeight)) {
                            this.camera.y += pushDist;
                            escaped = true;
                        }
                    }
                }
                
                // Try full movement first
                let finalX = this.camera.x;
                let finalZ = this.camera.z;
                
                // Step-based collision for smoother wall sliding
                const steps = 8; // More steps for smoother collision
                const stepX = moveX / steps;
                const stepZ = moveZ / steps;
                
                for (let i = 0; i < steps; i++) {
                    // Try X movement with slight margin
                    const testX = finalX + stepX;
                    if (!this.collidesAt(testX, this.camera.y, finalZ, playerRadius, playerHeight)) {
                        finalX = testX;
                    } else {
                        // Try to slide along the wall with reduced speed
                        const slideX = stepX * 0.5;
                        if (!this.collidesAt(finalX + slideX, this.camera.y, finalZ, playerRadius, playerHeight)) {
                            finalX += slideX;
                        }
                    }
                    
                    // Try Z movement with slight margin
                    const testZ = finalZ + stepZ;
                    if (!this.collidesAt(finalX, this.camera.y, testZ, playerRadius, playerHeight)) {
                        finalZ = testZ;
                    } else {
                        // Try to slide along the wall with reduced speed
                        const slideZ = stepZ * 0.5;
                        if (!this.collidesAt(finalX, this.camera.y, finalZ + slideZ, playerRadius, playerHeight)) {
                            finalZ += slideZ;
                        }
                    }
                }
                
                // Final safety check - if still stuck, try small adjustments
                if (this.collidesAt(finalX, this.camera.y, finalZ, playerRadius, playerHeight)) {
                    // Don't move at all if we'd get stuck
                    finalX = this.camera.x;
                    finalZ = this.camera.z;
                }
                
                this.camera.x = finalX;
                this.camera.z = finalZ;
                
                // Track distance
                const dx = this.camera.x - oldX;
                const dz = this.camera.z - oldZ;
                this.stats.distance += Math.sqrt(dx * dx + dz * dz);
                
                // --- GRAVITY / SWIMMING PHYSICS ---
                if (swimming) {
                    // SWIMMING MODE: Buoyancy and fluid drag
                    const buoyancy = inLava ? 0.008 : 0.012;  // Lava is denser, less buoyancy
                    const swimDrag = inLava ? 0.92 : 0.95;    // More drag in lava
                    
                    // Natural buoyancy pushes player up
                    this.velocity.y += buoyancy;
                    
                    // SPACE = swim up
                    if (this.keys[' ']) {
                        const swimUpSpeed = inLava ? 0.04 : 0.06;
                        this.velocity.y += swimUpSpeed;
                    }
                    
                    // SHIFT = swim down
                    if (this.keys['shift']) {
                        const swimDownSpeed = inLava ? 0.03 : 0.04;
                        this.velocity.y -= swimDownSpeed;
                    }
                    
                    // Clamp swim velocity
                    const maxSwimSpeed = inLava ? 0.12 : 0.15;
                    this.velocity.y = Math.max(-maxSwimSpeed, Math.min(maxSwimSpeed, this.velocity.y));
                    
                    // Apply drag (velocity decays over time in fluid)
                    this.velocity.y *= swimDrag;
                    
                    // Surface boost - when at surface and pressing space, jump out
                    if (!submerged && this.keys[' '] && this.velocity.y < 0.15) {
                        this.velocity.y = 0.2;
                    }
                } else {
                    // NORMAL MODE: Standard gravity
                    this.velocity.y += this.gravity;
                }
                
                const newY = this.camera.y + this.velocity.y;
                
                // Ground collision - camera is at hip/waist level (playerEyeHeight above ground)
                const groundY = this.getGroundHeightBelow(this.camera.x, this.camera.z, this.camera.y) + this.playerEyeHeight + 0.5;
                if (newY < groundY) {
                    this.camera.y = groundY;
                    this.velocity.y = 0;
                    this.isJumping = false;
                    
                    // Continuous jumping - if space is held and on ground, jump immediately
                    if (this.keys[' '] && !swimming) {
                        this.velocity.y = 0.28;
                        this.isJumping = true;
                        this.stats.jumps++;
                    }
                } else {
                    this.camera.y = newY;
                }
                
                // Ceiling collision
                const ceilingY = this.getCeilingAbove(this.camera.x, this.camera.z, this.camera.y);
                if (ceilingY !== null && this.camera.y > ceilingY - 0.5) {
                    this.camera.y = ceilingY - 0.5;
                    this.velocity.y = 0;
                }
                
                // World boundary forcefield - keep player inside
                if (this.worldBounds) {
                    const margin = 0.5;  // Keep player slightly inside boundary
                    const bounce = 0.3;  // Bounce back force
                    
                    if (this.camera.x < this.worldBounds.minX + margin) {
                        this.camera.x = this.worldBounds.minX + margin;
                        this.velocity.x = Math.abs(this.velocity.x || 0) * bounce;
                    }
                    if (this.camera.x > this.worldBounds.maxX - margin) {
                        this.camera.x = this.worldBounds.maxX - margin;
                        this.velocity.x = -Math.abs(this.velocity.x || 0) * bounce;
                    }
                    if (this.camera.z < this.worldBounds.minZ + margin) {
                        this.camera.z = this.worldBounds.minZ + margin;
                        this.velocity.z = Math.abs(this.velocity.z || 0) * bounce;
                    }
                    if (this.camera.z > this.worldBounds.maxZ - margin) {
                        this.camera.z = this.worldBounds.maxZ - margin;
                        this.velocity.z = -Math.abs(this.velocity.z || 0) * bounce;
                    }
                    // Prevent falling below world
                    if (this.camera.y < this.worldBounds.minY + this.playerEyeHeight) {
                        this.camera.y = this.worldBounds.minY + this.playerEyeHeight;
                        this.velocity.y = 0.15;  // Bounce up
                    }
                }
                
                // Trippy filter animation
                if (this.settings.filter === 'trippy') {
                    this.applyFilters();
                }
            },
            
            // Check if player would collide with blocks at position
            collidesAt(x, y, z, radius, height) {
                const feetY = y - this.playerEyeHeight; // Camera is at waist level
                // Check corners and center at multiple heights
                const checkPoints = [
                    { x: x - radius, z: z - radius },
                    { x: x + radius, z: z - radius },
                    { x: x - radius, z: z + radius },
                    { x: x + radius, z: z + radius },
                    { x: x, z: z }
                ];
                
                for (const point of checkPoints) {
                    const bx = Math.floor(point.x);
                    const bz = Math.floor(point.z);
                    // Check at feet, middle, and head level
                    for (let checkY = Math.floor(feetY); checkY < Math.floor(feetY + height); checkY++) {
                        const block = this.getBlock(bx, checkY, bz);
                        // Fluids don't block movement - player can walk/swim through them
                        if (block && !this.fluidBlocks.includes(block)) {
                            return true;
                        }
                    }
                }
                return false;
            },
            
            // Get ground height directly below player (not teleporting to trees)
            getGroundHeightBelow(x, z, currentY) {
                const bx = Math.floor(x);
                const bz = Math.floor(z);
                const startY = Math.floor(currentY - this.playerEyeHeight); // Start from feet level
                
                for (let y = startY; y >= 0; y--) {
                    const block = this.getBlock(bx, y, bz);
                    // Fluids don't count as ground - player sinks through them
                    if (block && !this.fluidBlocks.includes(block)) {
                        return y + 1;
                    }
                }
                return 0;
            },
            
            // Get ceiling above player
            getCeilingAbove(x, z, currentY) {
                const bx = Math.floor(x);
                const bz = Math.floor(z);
                const headY = Math.floor(currentY);
                
                for (let y = headY; y <= headY + 3; y++) {
                    const block = this.getBlock(bx, y, bz);
                    // Fluids don't count as ceiling
                    if (block && !this.fluidBlocks.includes(block)) {
                        return y;
                    }
                }
                return null;
            },
            
            render() {
                if (!this.isActive) return;
                
                const ctx = this.ctx;
                const width = this.canvas.width;
                const height = this.canvas.height;
                
                // Sky gradient (cached when dimensions match)
                if (!this.cachedSky || this.cachedSky.w !== width || this.cachedSky.h !== height || this.cachedSky.lighting !== this.settings.lighting) {
                    const skyGrad = ctx.createLinearGradient(0, 0, 0, height);
                    if (this.settings.lighting) {
                        skyGrad.addColorStop(0, '#1a0a1a');
                        skyGrad.addColorStop(0.5, '#2d1f3d');
                        skyGrad.addColorStop(1, '#ffb7c5');
                    } else {
                        skyGrad.addColorStop(0, '#111');
                        skyGrad.addColorStop(1, '#333');
                    }
                    this.cachedSky = { grad: skyGrad, w: width, h: height, lighting: this.settings.lighting };
                }
                ctx.fillStyle = this.cachedSky.grad;
                ctx.fillRect(0, 0, width, height);
                
                // Cache camera values for this frame
                const camX = this.camera.x;
                const camY = this.camera.y;
                const camZ = this.camera.z;
                const cosY = Math.cos(-this.camera.rotY);
                const sinY = Math.sin(-this.camera.rotY);
                const cosX = Math.cos(-this.camera.rotX);
                const sinX = Math.sin(-this.camera.rotX);
                const halfW = width / 2;
                const halfH = height / 2;
                const fov = 400;
                const renderDist = this.settings.renderDistance;
                const renderDistSq = renderDist * renderDist;
                
                // Inline project function for speed
                const project = (x, y, z) => {
                    const dx = x - camX;
                    const dy = y - camY;
                    const dz = z - camZ;
                    const rx = dx * cosY - dz * sinY;
                    const rz = dx * sinY + dz * cosY;
                    const ry = dy * cosX - rz * sinX;
                    const finalZ = dy * sinX + rz * cosX;
                    if (finalZ <= 0.1) return null;
                    return { x: halfW + (rx / finalZ) * fov, y: halfH - (ry / finalZ) * fov, z: finalZ };
                };
                
                // Collect visible blocks with frustum culling
                const blocks = [];
                const camDirX = -Math.sin(this.camera.rotY);
                const camDirZ = Math.cos(this.camera.rotY);
                
                // Performance: Cache world keys if not changed
                const worldKeys = Object.keys(this.world);
                
                for (let i = 0; i < worldKeys.length; i++) {
                    const key = worldKeys[i];
                    const [x, y, z] = key.split(',').map(Number);
                    const dx = x + 0.5 - camX;
                    const dy = y + 0.5 - camY;
                    const dz = z + 0.5 - camZ;
                    const distSq = dx * dx + dy * dy + dz * dz;
                    
                    // Distance culling
                    if (distSq > renderDistSq) continue;
                    
                    // Basic frustum culling - skip blocks behind camera
                    const dot = dx * camDirX + dz * camDirZ;
                    if (dot < -3 && distSq > 16) continue; // Behind camera and not too close
                    
                    blocks.push({ x, y, z, dist: distSq, type: this.world[key] });
                }
                
                // Sort back-to-front (painter's algorithm)
                blocks.sort((a, b) => b.dist - a.dist);
                
                // Render blocks with face culling
                const getBlock = (x, y, z) => this.world[`${x},${y},${z}`];
                const isTransparent = (block) => !block || this.fluidBlocks.includes(block);
                const getFluidLevel = (x, y, z) => this.fluidLevels[`${x},${y},${z}`] || 8;
                const animTime = Date.now() * 0.002; // Animation time for flowing effect
                
                // Separate opaque and transparent blocks for proper rendering
                const opaqueBlocks = [];
                const transparentBlocks = [];
                
                for (let i = 0; i < blocks.length; i++) {
                    const block = blocks[i];
                    const colors = this.blockColors[block.type];
                    if (colors && colors.transparent) {
                        transparentBlocks.push(block);
                    } else {
                        opaqueBlocks.push(block);
                    }
                }
                
                // PROPER RENDERING ORDER for painter's algorithm:
                // 1. Sort transparent blocks back-to-front (furthest first)
                // 2. Sort opaque blocks back-to-front (furthest first) 
                // 3. Draw transparent blocks first (they're behind)
                // 4. Draw opaque blocks last (they overwrite and properly occlude)
                
                // ANGULAR OCCLUSION SYSTEM - check if block is visible from camera angle
                // Uses corner visibility testing for proper edge handling
                const isBlockOccluded = (x, y, z) => {
                    // Test 8 corners of the block plus center
                    const testPoints = [
                        [x + 0.5, y + 0.5, z + 0.5], // center
                        [x + 0.1, y + 0.1, z + 0.1], // corners with small inset
                        [x + 0.9, y + 0.1, z + 0.1],
                        [x + 0.1, y + 0.9, z + 0.1],
                        [x + 0.9, y + 0.9, z + 0.1],
                        [x + 0.1, y + 0.1, z + 0.9],
                        [x + 0.9, y + 0.1, z + 0.9],
                        [x + 0.1, y + 0.9, z + 0.9],
                        [x + 0.9, y + 0.9, z + 0.9],
                    ];
                    
                    // Block is visible if ANY corner/point is visible
                    for (const [px, py, pz] of testPoints) {
                        const dx = px - camX;
                        const dy = py - camY;
                        const dz = pz - camZ;
                        const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                        
                        let pointOccluded = false;
                        // Ray march with finer steps near camera and target
                        const steps = Math.min(8, Math.ceil(dist / 2));
                        for (let i = 1; i < steps; i++) {
                            const t = i / steps;
                            const checkX = Math.floor(camX + dx * t);
                            const checkY = Math.floor(camY + dy * t);
                            const checkZ = Math.floor(camZ + dz * t);
                            
                            // Skip if we're checking the target block itself
                            if (checkX === x && checkY === y && checkZ === z) continue;
                            
                            const checkBlock = getBlock(checkX, checkY, checkZ);
                            // Solid non-fluid, non-transparent block occludes
                            if (checkBlock && !this.fluidBlocks.includes(checkBlock)) {
                                // Check if this block type has transparency property
                                const blockColors = this.blockColors[checkBlock];
                                if (!blockColors || !blockColors.transparent) {
                                    pointOccluded = true;
                                    break;
                                }
                            }
                        }
                        
                        // If this point is visible, the block is visible
                        if (!pointOccluded) return false;
                    }
                    
                    // All points occluded = block is occluded
                    return true;
                };
                
                // Filter out occluded transparent blocks
                const visibleTransparent = transparentBlocks.filter(b => !isBlockOccluded(b.x, b.y, b.z));
                
                // Sort each group - furthest (largest dist) first
                visibleTransparent.sort((a, b) => b.dist - a.dist);
                opaqueBlocks.sort((a, b) => b.dist - a.dist);
                
                // CORRECT ORDER: Draw opaque blocks FIRST, then transparent blocks
                // This allows transparent blocks to see opaque blocks behind them
                const allBlocks = [...opaqueBlocks, ...visibleTransparent];
                
                for (let i = 0; i < allBlocks.length; i++) {
                    const block = allBlocks[i];
                    const { x, y, z, type } = block;
                    const colors = this.blockColors[type];
                    if (!colors) continue;
                    
                    const isFluid = this.fluidBlocks.includes(type);
                    const fluidLevel = isFluid ? getFluidLevel(x, y, z) : 8;
                    // Fluids should fill their block space properly - topY calculation
                    const topY = y + (fluidLevel / 8);
                    
                    // Check adjacent blocks
                    const adjTop = getBlock(x, y + 1, z);
                    const adjBottom = getBlock(x, y - 1, z);
                    const adjFront = getBlock(x, y, z + 1);
                    const adjBack = getBlock(x, y, z - 1);
                    const adjLeft = getBlock(x - 1, y, z);
                    const adjRight = getBlock(x + 1, y, z);
                    
                    let hasTop, hasBottom, hasFront, hasBack, hasLeft, hasRight;
                    
                    if (isFluid) {
                        // For fluids, show top if not covered by same fluid above
                        hasTop = !adjTop || adjTop !== type;
                        hasBottom = !adjBottom || !this.fluidBlocks.includes(adjBottom);
                        
                        // For sides, show face if:
                        // 1. No adjacent block, or
                        // 2. Adjacent is different type (including different fluid), or  
                        // 3. Adjacent is same fluid but at a LOWER level (we need to show our side above their top)
                        const myLevel = fluidLevel;
                        
                        const frontLevel = adjFront === type ? getFluidLevel(x, y, z + 1) : 0;
                        const backLevel = adjBack === type ? getFluidLevel(x, y, z - 1) : 0;
                        const leftLevel = adjLeft === type ? getFluidLevel(x - 1, y, z) : 0;
                        const rightLevel = adjRight === type ? getFluidLevel(x + 1, y, z) : 0;
                        
                        hasFront = !adjFront || (adjFront !== type) || (frontLevel < myLevel);
                        hasBack = !adjBack || (adjBack !== type) || (backLevel < myLevel);
                        hasLeft = !adjLeft || (adjLeft !== type) || (leftLevel < myLevel);
                        hasRight = !adjRight || (adjRight !== type) || (rightLevel < myLevel);
                    } else {
                        // Solid blocks: show face if adjacent is empty OR is transparent (fluid)
                        hasTop = isTransparent(adjTop);
                        hasBottom = isTransparent(adjBottom);
                        hasFront = isTransparent(adjFront);
                        hasBack = isTransparent(adjBack);
                        hasLeft = isTransparent(adjLeft);
                        hasRight = isTransparent(adjRight);
                    }
                    
                    // Skip fully hidden blocks
                    if (!hasTop && !hasBottom && !hasFront && !hasBack && !hasLeft && !hasRight) continue;
                    
                    // Define visible faces
                    const faces = [];
                    
                    // Front face (+Z)
                    if (hasFront) {
                        faces.push({ v: [[x, y, z+1], [x+1, y, z+1], [x+1, topY, z+1], [x, topY, z+1]], color: colors.side, dark: 1, isTop: false });
                    }
                    // Back face (-Z)
                    if (hasBack) {
                        faces.push({ v: [[x+1, y, z], [x, y, z], [x, topY, z], [x+1, topY, z]], color: colors.side, dark: 0.7, isTop: false });
                    }
                    // Top face (+Y)
                    if (hasTop) {
                        faces.push({ v: [[x, topY, z], [x+1, topY, z], [x+1, topY, z+1], [x, topY, z+1]], color: colors.top, dark: 1, isTop: true });
                    }
                    // Bottom face (-Y)
                    if (hasBottom) {
                        faces.push({ v: [[x, y, z+1], [x+1, y, z+1], [x+1, y, z], [x, y, z]], color: colors.bottom, dark: 0.7, isTop: false });
                    }
                    // Left face (-X)
                    if (hasLeft) {
                        faces.push({ v: [[x, y, z], [x, y, z+1], [x, topY, z+1], [x, topY, z]], color: colors.side, dark: 0.85, isTop: false });
                    }
                    // Right face (+X)
                    if (hasRight) {
                        faces.push({ v: [[x+1, y, z+1], [x+1, y, z], [x+1, topY, z], [x+1, topY, z+1]], color: colors.side, dark: 0.85, isTop: false });
                    }
                    
                    // Render visible faces
                    for (let f = 0; f < faces.length; f++) {
                        const face = faces[f];
                        const pts = [];
                        let valid = true;
                        
                        for (let v = 0; v < 4; v++) {
                            const p = project(face.v[v][0], face.v[v][1], face.v[v][2]);
                            if (!p) { valid = false; break; }
                            pts.push(p);
                        }
                        if (!valid || pts.length !== 4) continue;
                        
                        // Apply shadow and get base color
                        let fillColor = face.color;
                        if (this.settings.shadows && face.dark < 1) {
                            fillColor = this.darkenColor(face.color, face.dark);
                        }
                        
                        // Animated fluid rendering
                        if (isFluid && colors.animated) {
                            if (type === 'water') {
                                // ADVANCED WATER RENDERING with Screen-Space Reflections
                                // Implements simplified SSR, Fresnel, caustics, and player reflection
                                
                                const time = animTime;
                                
                                // Multi-octave Gerstner wave simulation
                                const wave1 = Math.sin(time + x * 0.7 + z * 0.5) * 0.4;
                                const wave2 = Math.sin(time * 0.8 - x * 0.3 + z * 0.7) * 0.3;
                                const wave3 = Math.sin(time * 1.3 + x * 0.5 - z * 0.3) * 0.2;
                                const combinedWave = (wave1 + wave2 + wave3) / 3 + 0.5;
                                
                                // Calculate view vector for Fresnel
                                const dx = x + 0.5 - camX;
                                const dy = y + 0.5 - camY;
                                const dz = z + 0.5 - camZ;
                                const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                                
                                // Normal-based view angle
                                const viewDotNormal = Math.abs(dy / (dist || 1));
                                
                                // Schlick's Fresnel approximation
                                const F0 = 0.02; // Water's base reflectivity
                                const fresnel = F0 + (1 - F0) * Math.pow(1 - viewDotNormal, 5);
                                
                                // SCREEN-SPACE REFLECTION approximation
                                // Check if player would be reflected in this water block
                                let playerReflection = 0;
                                const playerDx = this.camera.x - (x + 0.5);
                                const playerDz = this.camera.z - (z + 0.5);
                                const playerDistToWater = Math.sqrt(playerDx * playerDx + playerDz * playerDz);
                                
                                // Player is reflected if close to water and water is below player
                                if (playerDistToWater < 5 && this.camera.y > y + 1) {
                                    // Reflection strength based on distance and angle
                                    const reflectStrengthDist = 1 - (playerDistToWater / 5);
                                    playerReflection = reflectStrengthDist * fresnel * 0.3;
                                }
                                
                                // Environment reflection sampling
                                const skyColors = [
                                    { r: 255, g: 183, b: 197 }, // Sunset pink
                                    { r: 255, g: 218, b: 185 }, // Peach
                                    { r: 135, g: 206, b: 235 }  // Sky blue
                                ];
                                const skyIndex = Math.min(2, Math.floor((1 - viewDotNormal) * 3));
                                const sky = skyColors[skyIndex];
                                
                                // Base water color with depth absorption
                                const depthFactor = Math.min(1, dist / 20);
                                const waterR = 30 + depthFactor * 15;
                                const waterG = 80 + depthFactor * 20;
                                const waterB = 160 - depthFactor * 30;
                                
                                // Player color for reflection (brown shirt tone)
                                const playerColor = { r: 100, g: 60, b: 40 };
                                
                                // Blend reflection and refraction based on Fresnel
                                const reflectStrength = Math.min(0.7, fresnel * 1.5);
                                let r = Math.floor(waterR * (1 - reflectStrength) + sky.r * reflectStrength);
                                let g = Math.floor(waterG * (1 - reflectStrength) + sky.g * reflectStrength);
                                let b = Math.floor(waterB * (1 - reflectStrength) + sky.b * reflectStrength);
                                
                                // Add player reflection tint
                                if (playerReflection > 0) {
                                    r = Math.floor(r * (1 - playerReflection) + playerColor.r * playerReflection);
                                    g = Math.floor(g * (1 - playerReflection) + playerColor.g * playerReflection);
                                    b = Math.floor(b * (1 - playerReflection) + playerColor.b * playerReflection);
                                }
                                
                                // Specular highlights (Blinn-Phong)
                                const sunDir = { x: 0.5, y: 0.8, z: 0.3 };
                                const viewDir = { x: dx/dist, y: dy/dist, z: dz/dist };
                                const halfVec = {
                                    x: sunDir.x + viewDir.x,
                                    y: sunDir.y + viewDir.y,
                                    z: sunDir.z + viewDir.z
                                };
                                const halfLen = Math.sqrt(halfVec.x*halfVec.x + halfVec.y*halfVec.y + halfVec.z*halfVec.z);
                                const specularBase = Math.max(0, halfVec.y / halfLen);
                                const specular = Math.pow(specularBase, 32) * combinedWave * 0.6;
                                
                                // Caustics effect
                                const caustic1 = Math.sin(time * 2 + x * 1.5) * Math.cos(time * 1.5 + z * 1.5);
                                const caustic2 = Math.sin(time * 1.7 - x * 1.2 + z * 0.8);
                                const caustics = (caustic1 * caustic2 + 1) * 0.1;
                                
                                // Final color with all effects
                                const brightness = 0.85 + combinedWave * 0.15 + specular + caustics;
                                const finalR = Math.min(255, Math.floor(r * brightness + specular * 200));
                                const finalG = Math.min(255, Math.floor(g * brightness + specular * 180));
                                const finalB = Math.min(255, Math.floor(b * brightness + specular * 150));
                                
                                // Dynamic transparency
                                const baseAlpha = 0.55;
                                const fresnelAlpha = fresnel * 0.35;
                                const alpha = Math.min(0.9, baseAlpha + fresnelAlpha);
                                
                                fillColor = `rgba(${finalR}, ${finalG}, ${finalB}, ${alpha})`;
                                
                            } else if (type === 'lava') {
                                // Animated lava with glowing/pulsing effect
                                const glowPhase = animTime * 1.5 + x * 0.3 + z * 0.3;
                                const glow = 0.8 + Math.sin(glowPhase) * 0.2;
                                const r = Math.floor(255 * glow);
                                const g = Math.floor((80 + Math.sin(glowPhase * 2) * 30) * glow);
                                const b = Math.floor(30 * (1 - glow * 0.5));
                                fillColor = `rgb(${Math.min(255, r)}, ${Math.min(255, g)}, ${b})`;
                            }
                        }
                        
                        ctx.fillStyle = fillColor;
                        ctx.beginPath();
                        ctx.moveTo(pts[0].x, pts[0].y);
                        ctx.lineTo(pts[1].x, pts[1].y);
                        ctx.lineTo(pts[2].x, pts[2].y);
                        ctx.lineTo(pts[3].x, pts[3].y);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Add subtle edge lines for better depth perception (not for fluids)
                        if (!isFluid) {
                            ctx.strokeStyle = this.darkenColor(fillColor, 0.7);
                            ctx.lineWidth = 0.5;
                            ctx.stroke();
                        }
                    }
                }
                
                // Render world boundary forcefield
                if (this.worldBounds) {
                    const bounds = this.worldBounds;
                    const time = Date.now() * 0.003;
                    
                    // Only render forcefield walls that are visible (within render distance)
                    const wallSegments = [];
                    const segmentSize = 5;  // Size of each forcefield segment
                    
                    // Check each boundary wall
                    const walls = [
                        { axis: 'x', value: bounds.minX, dir: 1 },   // West wall
                        { axis: 'x', value: bounds.maxX, dir: -1 },  // East wall
                        { axis: 'z', value: bounds.minZ, dir: 1 },   // North wall
                        { axis: 'z', value: bounds.maxZ, dir: -1 }   // South wall
                    ];
                    
                    for (const wall of walls) {
                        // Check if wall is within render distance
                        let distToWall;
                        if (wall.axis === 'x') {
                            distToWall = Math.abs(camX - wall.value);
                        } else {
                            distToWall = Math.abs(camZ - wall.value);
                        }
                        
                        if (distToWall > renderDist * 1.5) continue;  // Skip walls too far away
                        
                        // Generate forcefield segments for this wall
                        for (let y = bounds.minY; y < bounds.maxY; y += segmentSize) {
                            const perpStart = wall.axis === 'x' ? bounds.minZ : bounds.minX;
                            const perpEnd = wall.axis === 'x' ? bounds.maxZ : bounds.maxX;
                            
                            for (let p = perpStart; p < perpEnd; p += segmentSize) {
                                // Check if segment is within render distance
                                let segX, segZ;
                                if (wall.axis === 'x') {
                                    segX = wall.value;
                                    segZ = p + segmentSize / 2;
                                } else {
                                    segX = p + segmentSize / 2;
                                    segZ = wall.value;
                                }
                                
                                const segDist = Math.sqrt((segX - camX) ** 2 + (segZ - camZ) ** 2);
                                if (segDist > renderDist) continue;
                                
                                // Define quad corners
                                let corners;
                                const yTop = Math.min(y + segmentSize, bounds.maxY);
                                const pEnd = Math.min(p + segmentSize, perpEnd);
                                
                                if (wall.axis === 'x') {
                                    corners = [
                                        [wall.value, y, p],
                                        [wall.value, y, pEnd],
                                        [wall.value, yTop, pEnd],
                                        [wall.value, yTop, p]
                                    ];
                                } else {
                                    corners = [
                                        [p, y, wall.value],
                                        [pEnd, y, wall.value],
                                        [pEnd, yTop, wall.value],
                                        [p, yTop, wall.value]
                                    ];
                                }
                                
                                // Project corners
                                const pts = [];
                                let valid = true;
                                for (const c of corners) {
                                    const pt = project(c[0], c[1], c[2]);
                                    if (!pt) { valid = false; break; }
                                    pts.push(pt);
                                }
                                if (!valid || pts.length < 4) continue;
                                
                                // Calculate animated glow intensity
                                const gridPhase = ((p + y) * 0.2 + time) % (Math.PI * 2);
                                const alpha = 0.15 + 0.1 * Math.sin(gridPhase);
                                
                                // Draw forcefield panel with cyan/magenta energy effect
                                const hue = (time * 30 + p + y) % 360;
                                ctx.fillStyle = `hsla(${180 + Math.sin(time + p * 0.1) * 20}, 100%, 60%, ${alpha})`;
                                ctx.beginPath();
                                ctx.moveTo(pts[0].x, pts[0].y);
                                ctx.lineTo(pts[1].x, pts[1].y);
                                ctx.lineTo(pts[2].x, pts[2].y);
                                ctx.lineTo(pts[3].x, pts[3].y);
                                ctx.closePath();
                                ctx.fill();
                                
                                // Draw grid lines
                                ctx.strokeStyle = `hsla(180, 100%, 70%, ${alpha * 2})`;
                                ctx.lineWidth = 1;
                                ctx.stroke();
                            }
                        }
                    }
                    
                    // Bottom forcefield (floor at minY)
                    const bottomY = bounds.minY;
                    for (let x = bounds.minX; x < bounds.maxX; x += segmentSize) {
                        for (let z = bounds.minZ; z < bounds.maxZ; z += segmentSize) {
                            const segDist = Math.sqrt((x + segmentSize/2 - camX) ** 2 + (z + segmentSize/2 - camZ) ** 2);
                            if (segDist > renderDist) continue;
                            
                            const xEnd = Math.min(x + segmentSize, bounds.maxX);
                            const zEnd = Math.min(z + segmentSize, bounds.maxZ);
                            
                            const corners = [
                                [x, bottomY, z],
                                [xEnd, bottomY, z],
                                [xEnd, bottomY, zEnd],
                                [x, bottomY, zEnd]
                            ];
                            
                            const pts = [];
                            let valid = true;
                            for (const c of corners) {
                                const pt = project(c[0], c[1], c[2]);
                                if (!pt) { valid = false; break; }
                                pts.push(pt);
                            }
                            if (!valid || pts.length < 4) continue;
                            
                            const gridPhase = ((x + z) * 0.2 + time) % (Math.PI * 2);
                            const alpha = 0.1 + 0.08 * Math.sin(gridPhase);
                            
                            ctx.fillStyle = `hsla(${280 + Math.sin(time + x * 0.1) * 20}, 100%, 50%, ${alpha})`;
                            ctx.beginPath();
                            ctx.moveTo(pts[0].x, pts[0].y);
                            ctx.lineTo(pts[1].x, pts[1].y);
                            ctx.lineTo(pts[2].x, pts[2].y);
                            ctx.lineTo(pts[3].x, pts[3].y);
                            ctx.closePath();
                            ctx.fill();
                            
                            ctx.strokeStyle = `hsla(280, 100%, 60%, ${alpha * 2})`;
                            ctx.lineWidth = 1;
                            ctx.stroke();
                        }
                    }
                }
                
                // Render birds
                for (const bird of this.birds) {
                    // Check if bird is in front of camera
                    const dx = bird.x - camX;
                    const dy = bird.y - camY;
                    const dz = bird.z - camZ;
                    const dot = dx * camDirX + dz * camDirZ;
                    if (dot < 0) continue; // Behind camera
                    
                    const distSq = dx * dx + dy * dy + dz * dz;
                    if (distSq > renderDistSq) continue; // Too far
                    
                    // Project bird center
                    const center = project(bird.x, bird.y, bird.z);
                    if (!center) continue;
                    
                    // Calculate screen size based on distance
                    const screenSize = (bird.size * fov) / center.z;
                    if (screenSize < 2) continue; // Too small to render
                    
                    // Wing flap animation
                    const wingAngle = Math.sin(bird.wingPhase) * 0.5;
                    
                    // Bird facing direction (tangent to circular path)
                    const facingAngle = bird.angle + Math.PI / 2;
                    
                    // Draw bird body (dark pink/magenta for sakura theme)
                    ctx.fillStyle = '#d85a8a';
                    ctx.beginPath();
                    ctx.ellipse(center.x, center.y, screenSize * 0.8, screenSize * 0.4, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw wings
                    ctx.fillStyle = '#ff9ec4';
                    const wingSpan = screenSize * 1.5;
                    const wingHeight = screenSize * 0.6 * (1 + wingAngle);
                    
                    // Left wing
                    ctx.beginPath();
                    ctx.moveTo(center.x, center.y);
                    ctx.quadraticCurveTo(
                        center.x - wingSpan * 0.5, center.y - wingHeight,
                        center.x - wingSpan, center.y + screenSize * 0.2
                    );
                    ctx.quadraticCurveTo(
                        center.x - wingSpan * 0.5, center.y + screenSize * 0.1,
                        center.x, center.y
                    );
                    ctx.fill();
                    
                    // Right wing
                    ctx.beginPath();
                    ctx.moveTo(center.x, center.y);
                    ctx.quadraticCurveTo(
                        center.x + wingSpan * 0.5, center.y - wingHeight,
                        center.x + wingSpan, center.y + screenSize * 0.2
                    );
                    ctx.quadraticCurveTo(
                        center.x + wingSpan * 0.5, center.y + screenSize * 0.1,
                        center.x, center.y
                    );
                    ctx.fill();
                    
                    // Draw head
                    ctx.fillStyle = '#d85a8a';
                    ctx.beginPath();
                    ctx.arc(center.x + screenSize * 0.6, center.y - screenSize * 0.1, screenSize * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Beak
                    ctx.fillStyle = '#ffaa00';
                    ctx.beginPath();
                    ctx.moveTo(center.x + screenSize * 0.9, center.y - screenSize * 0.1);
                    ctx.lineTo(center.x + screenSize * 1.2, center.y);
                    ctx.lineTo(center.x + screenSize * 0.9, center.y + screenSize * 0.1);
                    ctx.fill();
                }
                
                // Render pest birds (smaller, always close to player)
                for (const pest of this.pestBirds) {
                    // Project pest bird
                    const center = project(pest.x, pest.y, pest.z);
                    if (!center) continue;
                    
                    // Calculate screen size (these are smaller)
                    const screenSize = (pest.size * fov) / center.z;
                    if (screenSize < 1) continue;
                    
                    // Frantic wing flap - faster when angry
                    const wingAngle = Math.sin(pest.wingPhase) * 0.7;
                    
                    // Body color - gets redder with anger (0-5 anger levels)
                    const anger = pest.anger || 0;
                    const angerRed = Math.min(255, 107 + anger * 30); // 107 to 255
                    const angerGreen = Math.max(0, 68 - anger * 10);   // 68 to 18
                    const angerBlue = Math.max(0, 35 - anger * 7);     // 35 to 0
                    
                    const isSwooping = pest.state === 'swooping';
                    const bodyColor = anger > 0 
                        ? `rgb(${angerRed}, ${angerGreen}, ${angerBlue})`
                        : (isSwooping ? '#8b4513' : '#6b4423');
                    const wingColor = anger > 0
                        ? `rgb(${Math.min(255, angerRed + 30)}, ${angerGreen + 20}, ${angerBlue + 10})`
                        : (isSwooping ? '#a0522d' : '#8b7355');
                    
                    // Draw body (smaller, rounder - like a sparrow)
                    ctx.fillStyle = bodyColor;
                    ctx.beginPath();
                    ctx.ellipse(center.x, center.y, screenSize * 0.6, screenSize * 0.5, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Angry glow effect for high anger birds
                    if (anger >= 3) {
                        ctx.shadowColor = '#ff0000';
                        ctx.shadowBlur = anger * 3;
                    }
                    
                    // Draw frantic wings
                    ctx.fillStyle = wingColor;
                    const wingSpan = screenSize * 1.2;
                    const wingHeight = screenSize * 0.8 * (1 + wingAngle);
                    
                    // Left wing
                    ctx.beginPath();
                    ctx.moveTo(center.x, center.y);
                    ctx.quadraticCurveTo(
                        center.x - wingSpan * 0.4, center.y - wingHeight,
                        center.x - wingSpan, center.y
                    );
                    ctx.quadraticCurveTo(
                        center.x - wingSpan * 0.4, center.y + screenSize * 0.2,
                        center.x, center.y
                    );
                    ctx.fill();
                    
                    // Right wing
                    ctx.beginPath();
                    ctx.moveTo(center.x, center.y);
                    ctx.quadraticCurveTo(
                        center.x + wingSpan * 0.4, center.y - wingHeight,
                        center.x + wingSpan, center.y
                    );
                    ctx.quadraticCurveTo(
                        center.x + wingSpan * 0.4, center.y + screenSize * 0.2,
                        center.x, center.y
                    );
                    ctx.fill();
                    
                    // Head
                    ctx.fillStyle = bodyColor;
                    ctx.beginPath();
                    ctx.arc(center.x + screenSize * 0.4, center.y - screenSize * 0.15, screenSize * 0.25, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Beady eye
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(center.x + screenSize * 0.45, center.y - screenSize * 0.2, screenSize * 0.08, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Small pointy beak
                    ctx.fillStyle = '#ff6600';
                    ctx.beginPath();
                    ctx.moveTo(center.x + screenSize * 0.6, center.y - screenSize * 0.15);
                    ctx.lineTo(center.x + screenSize * 0.85, center.y - screenSize * 0.1);
                    ctx.lineTo(center.x + screenSize * 0.6, center.y - screenSize * 0.05);
                    ctx.fill();
                    
                    // Tail feathers
                    ctx.fillStyle = wingColor;
                    ctx.beginPath();
                    ctx.moveTo(center.x - screenSize * 0.4, center.y);
                    ctx.lineTo(center.x - screenSize * 0.9, center.y - screenSize * 0.1);
                    ctx.lineTo(center.x - screenSize * 0.95, center.y + screenSize * 0.05);
                    ctx.lineTo(center.x - screenSize * 0.85, center.y + screenSize * 0.15);
                    ctx.lineTo(center.x - screenSize * 0.4, center.y + screenSize * 0.1);
                    ctx.fill();
                    
                    // Reset shadow
                    ctx.shadowBlur = 0;
                    ctx.shadowColor = 'transparent';
                }
                
                // Render blue birds
                if (this.blueBirds) {
                    for (const bird of this.blueBirds) {
                        const center = project(bird.x, bird.y, bird.z);
                        if (!center) continue;
                        
                        const screenSize = Math.max(8, 25 / center.z);
                        const wingAngle = Math.sin(bird.wingPhase) * 0.6;
                        const wingHeight = screenSize * 0.5 * (1 + wingAngle);
                        
                        // Blue body
                        ctx.fillStyle = '#1e90ff';
                        ctx.beginPath();
                        ctx.ellipse(center.x, center.y, screenSize * 0.5, screenSize * 0.3, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Wings
                        ctx.fillStyle = '#00bfff';
                        const wingSpan = screenSize * 1.2;
                        ctx.beginPath();
                        ctx.moveTo(center.x, center.y);
                        ctx.quadraticCurveTo(center.x - wingSpan * 0.5, center.y - wingHeight, center.x - wingSpan, center.y);
                        ctx.quadraticCurveTo(center.x - wingSpan * 0.5, center.y + screenSize * 0.2, center.x, center.y);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.moveTo(center.x, center.y);
                        ctx.quadraticCurveTo(center.x + wingSpan * 0.5, center.y - wingHeight, center.x + wingSpan, center.y);
                        ctx.quadraticCurveTo(center.x + wingSpan * 0.5, center.y + screenSize * 0.2, center.x, center.y);
                        ctx.fill();
                        
                        // Angry eye
                        ctx.fillStyle = '#ff0000';
                        ctx.beginPath();
                        ctx.arc(center.x + screenSize * 0.3, center.y - screenSize * 0.1, screenSize * 0.15, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                // Render fish
                if (this.fish) {
                    for (const fish of this.fish) {
                        const center = project(fish.x, fish.y, fish.z);
                        if (!center) continue;
                        
                        const screenSize = Math.max(4, fish.size * 30 / center.z);
                        const swimOffset = Math.sin(fish.swimPhase) * 0.2;
                        
                        ctx.save();
                        ctx.translate(center.x, center.y);
                        ctx.rotate(Math.atan2(fish.vz, fish.vx) + swimOffset);
                        
                        // Body
                        ctx.fillStyle = fish.color;
                        ctx.beginPath();
                        ctx.ellipse(0, 0, screenSize, screenSize * 0.4, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Tail
                        ctx.beginPath();
                        ctx.moveTo(-screenSize * 0.8, 0);
                        ctx.lineTo(-screenSize * 1.5, -screenSize * 0.4);
                        ctx.lineTo(-screenSize * 1.5, screenSize * 0.4);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Eye
                        ctx.fillStyle = '#000';
                        ctx.beginPath();
                        ctx.arc(screenSize * 0.5, -screenSize * 0.1, screenSize * 0.15, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.restore();
                    }
                }
                
                // Render cats
                if (this.cats) {
                    for (const cat of this.cats) {
                        const center = project(cat.x, cat.y + 0.3, cat.z);
                        if (!center) continue;
                        
                        const screenSize = Math.max(10, 40 / center.z);
                        const walkBob = Math.sin(cat.walkPhase) * screenSize * 0.05;
                        
                        // Body
                        ctx.fillStyle = cat.color;
                        ctx.beginPath();
                        ctx.ellipse(center.x, center.y + walkBob, screenSize * 0.6, screenSize * 0.4, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Head
                        ctx.beginPath();
                        ctx.arc(center.x + screenSize * 0.5, center.y - screenSize * 0.2 + walkBob, screenSize * 0.35, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Ears
                        ctx.beginPath();
                        ctx.moveTo(center.x + screenSize * 0.3, center.y - screenSize * 0.5 + walkBob);
                        ctx.lineTo(center.x + screenSize * 0.4, center.y - screenSize * 0.2 + walkBob);
                        ctx.lineTo(center.x + screenSize * 0.5, center.y - screenSize * 0.5 + walkBob);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.moveTo(center.x + screenSize * 0.6, center.y - screenSize * 0.5 + walkBob);
                        ctx.lineTo(center.x + screenSize * 0.7, center.y - screenSize * 0.2 + walkBob);
                        ctx.lineTo(center.x + screenSize * 0.5, center.y - screenSize * 0.5 + walkBob);
                        ctx.fill();
                        
                        // Eyes
                        ctx.fillStyle = '#00ff00';
                        ctx.beginPath();
                        ctx.ellipse(center.x + screenSize * 0.4, center.y - screenSize * 0.25 + walkBob, screenSize * 0.08, screenSize * 0.12, 0, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.ellipse(center.x + screenSize * 0.6, center.y - screenSize * 0.25 + walkBob, screenSize * 0.08, screenSize * 0.12, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Tail
                        ctx.strokeStyle = cat.color;
                        ctx.lineWidth = screenSize * 0.1;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(center.x - screenSize * 0.5, center.y + walkBob);
                        ctx.quadraticCurveTo(center.x - screenSize * 0.8, center.y - screenSize * 0.3, center.x - screenSize * 0.7, center.y - screenSize * 0.5);
                        ctx.stroke();
                    }
                }
                
                // Render creepers
                if (this.creepers) {
                    for (const creeper of this.creepers) {
                        const center = project(creeper.x, creeper.y + 0.8, creeper.z);
                        if (!center) continue;
                        
                        const screenSize = Math.max(15, 50 / center.z);
                        
                        // Flash white when fusing
                        const bodyColor = (creeper.state === 'fusing' && creeper.flashing) ? '#ffffff' : '#00aa00';
                        
                        // Body (tall rectangle)
                        ctx.fillStyle = bodyColor;
                        ctx.fillRect(center.x - screenSize * 0.3, center.y - screenSize * 0.5, screenSize * 0.6, screenSize);
                        
                        // Head
                        ctx.fillRect(center.x - screenSize * 0.35, center.y - screenSize * 0.9, screenSize * 0.7, screenSize * 0.5);
                        
                        // Face (creepy)
                        ctx.fillStyle = '#000';
                        // Eyes
                        ctx.fillRect(center.x - screenSize * 0.25, center.y - screenSize * 0.8, screenSize * 0.15, screenSize * 0.15);
                        ctx.fillRect(center.x + screenSize * 0.1, center.y - screenSize * 0.8, screenSize * 0.15, screenSize * 0.15);
                        // Mouth (frown)
                        ctx.fillRect(center.x - screenSize * 0.2, center.y - screenSize * 0.55, screenSize * 0.1, screenSize * 0.15);
                        ctx.fillRect(center.x + screenSize * 0.1, center.y - screenSize * 0.55, screenSize * 0.1, screenSize * 0.15);
                        ctx.fillRect(center.x - screenSize * 0.1, center.y - screenSize * 0.5, screenSize * 0.2, screenSize * 0.1);
                        
                        // Legs
                        ctx.fillStyle = bodyColor;
                        ctx.fillRect(center.x - screenSize * 0.3, center.y + screenSize * 0.4, screenSize * 0.2, screenSize * 0.3);
                        ctx.fillRect(center.x + screenSize * 0.1, center.y + screenSize * 0.4, screenSize * 0.2, screenSize * 0.3);
                    }
                }
                
                // Render particles (only those in front of visible blocks)
                for (const p of this.particles) {
                    const center = project(p.x, p.y, p.z);
                    if (!center) continue;
                    
                    // Check if particle is behind a block using simple raycast
                    // Only check bullets since they're the main issue
                    if (p.type === 'bullet') {
                        const dx = p.x - this.camera.x;
                        const dy = p.y - this.camera.y;
                        const dz = p.z - this.camera.z;
                        const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                        
                        // Simple occlusion check - sample a few points between camera and bullet
                        let occluded = false;
                        for (let t = 0.3; t < 0.95; t += 0.2) {
                            const checkX = this.camera.x + dx * t;
                            const checkY = this.camera.y + dy * t;
                            const checkZ = this.camera.z + dz * t;
                            const block = this.getBlock(Math.floor(checkX), Math.floor(checkY), Math.floor(checkZ));
                            if (block && !this.fluidBlocks.includes(block)) {
                                occluded = true;
                                break;
                            }
                        }
                        if (occluded) continue;
                        
                        // Bullet trail
                        if (p.trail.length > 1) {
                            ctx.strokeStyle = 'rgba(255, 200, 50, 0.8)';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            let started = false;
                            for (let i = 0; i < p.trail.length; i++) {
                                const tp = project(p.trail[i].x, p.trail[i].y, p.trail[i].z);
                                if (tp) {
                                    if (!started) {
                                        ctx.moveTo(tp.x, tp.y);
                                        started = true;
                                    } else {
                                        ctx.lineTo(tp.x, tp.y);
                                    }
                                }
                            }
                            if (started) {
                                ctx.lineTo(center.x, center.y);
                                ctx.stroke();
                            }
                        }
                        
                        // Bullet head
                        const bulletSize = Math.max(2, 8 / center.z);
                        ctx.fillStyle = '#ffcc00';
                        ctx.beginPath();
                        ctx.arc(center.x, center.y, bulletSize, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (p.type === 'ricochet' || p.type === 'spark') {
                        const size = Math.max(1, (p.size || 3) * 20 / center.z);
                        const alpha = Math.min(1, p.life / 15);
                        ctx.fillStyle = `rgba(255, ${150 + Math.random() * 100}, 50, ${alpha})`;
                        ctx.beginPath();
                        ctx.arc(center.x, center.y, size, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (p.type === 'blessing') {
                        // Divine blessing particles - golden with sparkle
                        const size = Math.max(2, (p.size || 4) * 20 / center.z);
                        const alpha = Math.min(1, p.life / 30);
                        const sparkle = Math.sin(p.life * 0.3) * 0.5 + 0.5;
                        
                        // Outer glow
                        ctx.fillStyle = `rgba(255, 215, 0, ${alpha * 0.3})`;
                        ctx.beginPath();
                        ctx.arc(center.x, center.y, size * 2, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Inner core
                        ctx.fillStyle = `rgba(255, ${200 + sparkle * 55}, ${100 + sparkle * 155}, ${alpha})`;
                        ctx.beginPath();
                        ctx.arc(center.x, center.y, size, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Central bright spot
                        ctx.fillStyle = `rgba(255, 255, 255, ${alpha * sparkle})`;
                        ctx.beginPath();
                        ctx.arc(center.x, center.y, size * 0.3, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (p.type === 'explosion') {
                        // Creeper explosion particles - fiery orange/yellow
                        const size = Math.max(3, (p.size || 5) * 25 / center.z);
                        const alpha = Math.min(1, p.life / 20);
                        const flicker = Math.random() * 0.3 + 0.7;
                        
                        // Outer fire glow
                        ctx.fillStyle = `rgba(255, 100, 0, ${alpha * 0.4})`;
                        ctx.beginPath();
                        ctx.arc(center.x, center.y, size * 1.5, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Inner fire core
                        ctx.fillStyle = `rgba(255, ${150 + Math.random() * 100}, 0, ${alpha * flicker})`;
                        ctx.beginPath();
                        ctx.arc(center.x, center.y, size, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Hot center
                        ctx.fillStyle = `rgba(255, 255, ${Math.random() * 100}, ${alpha * 0.8})`;
                        ctx.beginPath();
                        ctx.arc(center.x, center.y, size * 0.4, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (p.type === 'feather') {
                        const size = Math.max(2, 15 / center.z);
                        const alpha = Math.min(1, p.life / 20);
                        ctx.save();
                        ctx.translate(center.x, center.y);
                        ctx.rotate(p.rotation);
                        ctx.fillStyle = `rgba(139, 90, 43, ${alpha})`;
                        ctx.beginPath();
                        ctx.ellipse(0, 0, size * 2, size * 0.5, 0, 0, Math.PI * 2);
                        ctx.fill();
                        // Feather spine
                        ctx.strokeStyle = `rgba(100, 60, 30, ${alpha})`;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(-size * 2, 0);
                        ctx.lineTo(size * 2, 0);
                        ctx.stroke();
                        ctx.restore();
                    } else if (p.type === 'petal') {
                        // Cherry blossom petal - pink and flutter
                        // Check occlusion - don't render petals behind walls
                        const dx = p.x - this.camera.x;
                        const dy = p.y - this.camera.y;
                        const dz = p.z - this.camera.z;
                        let occluded = false;
                        for (let t = 0.2; t < 0.9; t += 0.25) {
                            const checkX = this.camera.x + dx * t;
                            const checkY = this.camera.y + dy * t;
                            const checkZ = this.camera.z + dz * t;
                            const block = this.getBlock(Math.floor(checkX), Math.floor(checkY), Math.floor(checkZ));
                            if (block && !this.fluidBlocks.includes(block)) {
                                occluded = true;
                                break;
                            }
                        }
                        if (occluded) continue;
                        
                        const size = Math.max(2, (p.size || 4) * 15 / center.z);
                        const alpha = Math.min(1, p.life / 50);
                        ctx.save();
                        ctx.translate(center.x, center.y);
                        ctx.rotate(p.rotation);
                        // Petal shape
                        ctx.fillStyle = `rgba(255, 183, 197, ${alpha})`;
                        ctx.beginPath();
                        ctx.ellipse(0, 0, size * 1.5, size * 0.7, 0, 0, Math.PI * 2);
                        ctx.fill();
                        // Darker center
                        ctx.fillStyle = `rgba(255, 150, 170, ${alpha})`;
                        ctx.beginPath();
                        ctx.ellipse(0, 0, size * 0.5, size * 0.3, 0, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    } else if (p.type === 'burger') {
                        // Burger projectile - draw a burger!
                        const size = Math.max(3, (p.size || 8) * 20 / center.z);
                        ctx.save();
                        ctx.translate(center.x, center.y);
                        // Bun top
                        ctx.fillStyle = '#D2691E';
                        ctx.beginPath();
                        ctx.ellipse(0, -size * 0.3, size, size * 0.5, 0, Math.PI, 0);
                        ctx.fill();
                        // Patty
                        ctx.fillStyle = '#654321';
                        ctx.fillRect(-size, -size * 0.2, size * 2, size * 0.4);
                        // Lettuce
                        ctx.fillStyle = '#228B22';
                        ctx.fillRect(-size * 0.9, size * 0.1, size * 1.8, size * 0.15);
                        // Bun bottom
                        ctx.fillStyle = '#DEB887';
                        ctx.beginPath();
                        ctx.ellipse(0, size * 0.3, size, size * 0.4, 0, 0, Math.PI);
                        ctx.fill();
                        ctx.restore();
                    } else if (p.type === 'burgerSplat') {
                        // Burger splatter
                        const size = Math.max(2, (p.size || 4) * 10 / center.z);
                        const alpha = Math.min(1, p.life / 10);
                        const colors = ['#D2691E', '#654321', '#228B22', '#FF6347'];
                        ctx.fillStyle = colors[Math.floor(Math.random() * colors.length)].replace(')', `, ${alpha})`).replace('rgb', 'rgba');
                        ctx.beginPath();
                        ctx.arc(center.x, center.y, size, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (p.type === 'apple') {
                        // Apple projectile - draw a red apple
                        const size = Math.max(3, (p.size || 6) * 18 / center.z);
                        ctx.save();
                        ctx.translate(center.x, center.y);
                        // Apple body
                        ctx.fillStyle = '#dc143c';
                        ctx.beginPath();
                        ctx.arc(0, 0, size, 0, Math.PI * 2);
                        ctx.fill();
                        // Highlight
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                        ctx.beginPath();
                        ctx.arc(-size * 0.3, -size * 0.3, size * 0.4, 0, Math.PI * 2);
                        ctx.fill();
                        // Stem
                        ctx.fillStyle = '#654321';
                        ctx.fillRect(-1, -size - 3, 2, 4);
                        // Leaf
                        ctx.fillStyle = '#228b22';
                        ctx.beginPath();
                        ctx.ellipse(3, -size - 1, 4, 2, 0.3, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    } else if (p.type === 'appleSplat') {
                        // Apple splatter
                        const size = Math.max(2, (p.size || 3) * 8 / center.z);
                        const alpha = Math.min(1, p.life / 10);
                        ctx.fillStyle = `rgba(220, 20, 60, ${alpha})`;
                        ctx.beginPath();
                        ctx.arc(center.x, center.y, size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                // Render dropped items (with distance culling and occlusion) - 3D block models
                if (this.droppedItems) {
                    const maxItemDistSq = 400; // 20 blocks squared - reduced for performance
                    for (const item of this.droppedItems) {
                        // Distance culling - skip items too far away
                        const dx = item.x - camX;
                        const dy = item.y - camY;
                        const dz = item.z - camZ;
                        const distSq = dx * dx + dy * dy + dz * dz;
                        if (distSq > maxItemDistSq) continue;
                        
                        // Occlusion check - don't render items through walls
                        let occluded = false;
                        const dist = Math.sqrt(distSq);
                        for (let t = 0.15; t < 0.9; t += 0.2) {
                            const checkX = camX + dx * t;
                            const checkY = camY + dy * t;
                            const checkZ = camZ + dz * t;
                            const block = this.getBlock(Math.floor(checkX), Math.floor(checkY), Math.floor(checkZ));
                            if (block && !this.fluidBlocks.includes(block)) {
                                occluded = true;
                                break;
                            }
                        }
                        if (occluded) continue;
                        
                        const bobOffset = Math.sin(item.bobPhase) * 0.1;
                        const center = project(item.x, item.y + bobOffset, item.z);
                        if (!center || center.z <= 0) continue;
                        
                        const baseSize = Math.max(6, 30 / center.z);
                        
                        // Draw 3D item based on type
                        this.drawDroppedItem3D(ctx, center.x, center.y, baseSize, item.type, item.bobPhase);
                        
                        // Count badge if more than 1
                        if (item.count > 1) {
                            ctx.font = `bold ${Math.max(8, baseSize * 0.5)}px monospace`;
                            ctx.fillStyle = '#fff';
                            ctx.strokeStyle = '#000';
                            ctx.lineWidth = 2;
                            ctx.textAlign = 'center';
                            ctx.strokeText(item.count.toString(), center.x + baseSize * 0.5, center.y + baseSize * 0.4);
                            ctx.fillText(item.count.toString(), center.x + baseSize * 0.5, center.y + baseSize * 0.4);
                        }
                    }
                }
                
                // Draw block highlight (targeted block wireframe)
                if (!this.isPaused && this.pointerLocked) {
                    const hit = this.raycast();
                    if (hit && hit.hit) {
                        const bx = hit.hit.x;
                        const by = hit.hit.y;
                        const bz = hit.hit.z;
                        
                        // Define all 8 corners of the block (slightly expanded for visibility)
                        const e = 0.005; // expansion amount
                        const corners = [
                            [bx - e, by - e, bz - e],
                            [bx + 1 + e, by - e, bz - e],
                            [bx + 1 + e, by + 1 + e, bz - e],
                            [bx - e, by + 1 + e, bz - e],
                            [bx - e, by - e, bz + 1 + e],
                            [bx + 1 + e, by - e, bz + 1 + e],
                            [bx + 1 + e, by + 1 + e, bz + 1 + e],
                            [bx - e, by + 1 + e, bz + 1 + e]
                        ];
                        
                        const projected = corners.map(c => project(c[0], c[1], c[2]));
                        
                        // Draw edges if all corners are visible
                        if (projected.every(p => p !== null)) {
                            // Change color based on what we're looking through
                            let strokeColor = 'rgba(0, 0, 0, 0.8)';
                            let lineWidth = 2;
                            
                            if (hit.throughWater) {
                                // Blue tint when looking through water
                                strokeColor = 'rgba(74, 144, 217, 0.7)';
                                lineWidth = 3;
                            } else if (hit.throughLava) {
                                // Orange tint when looking through lava
                                strokeColor = 'rgba(255, 100, 0, 0.7)';
                                lineWidth = 3;
                            }
                            
                            ctx.strokeStyle = strokeColor;
                            ctx.lineWidth = lineWidth;
                            
                            const edges = [
                                [0,1], [1,2], [2,3], [3,0], // back face
                                [4,5], [5,6], [6,7], [7,4], // front face
                                [0,4], [1,5], [2,6], [3,7]  // connecting edges
                            ];
                            
                            ctx.beginPath();
                            for (const [a, b] of edges) {
                                ctx.moveTo(projected[a].x, projected[a].y);
                                ctx.lineTo(projected[b].x, projected[b].y);
                            }
                            ctx.stroke();
                        }
                        
                        // Show tooltip for ritual socket blocks
                        const targetBlock = this.getBlock(bx, by, bz);
                        this.updateBlockTooltip(targetBlock);
                    } else {
                        this.updateBlockTooltip(null);
                    }
                }
                
                // Debug info display
                if (this.debugShowCoords) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(width - 200, 10, 190, 80);
                    ctx.fillStyle = '#0f0';
                    ctx.font = '12px monospace';
                    ctx.textAlign = 'left';
                    ctx.fillText(`X: ${this.camera.x.toFixed(2)}`, width - 190, 28);
                    ctx.fillText(`Y: ${this.camera.y.toFixed(2)}`, width - 190, 43);
                    ctx.fillText(`Z: ${this.camera.z.toFixed(2)}`, width - 190, 58);
                    ctx.fillText(`Blocks: ${Object.keys(this.world).length}`, width - 190, 73);
                    ctx.fillText(`Birds: ${this.pestBirds.length}`, width - 190, 88);
                }
                
                // Player model (first person body when looking down)
                this.renderPlayerModel(ctx, halfW, halfH, width, height);
                
                // Crosshair
                if (!this.isPaused && this.pointerLocked) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(halfW - 10, halfH);
                    ctx.lineTo(halfW + 10, halfH);
                    ctx.moveTo(halfW, halfH - 10);
                    ctx.lineTo(halfW, halfH + 10);
                    ctx.stroke();
                }
                
                // Bird event alert
                if (this.birdEvent && this.birdEvent.alertMessage && this.birdEvent.alertFade > 0) {
                    const alpha = Math.min(1, this.birdEvent.alertFade / 1000);
                    const pulse = 0.8 + Math.sin(Date.now() * 0.01) * 0.2;
                    
                    ctx.save();
                    ctx.globalAlpha = alpha;
                    
                    // Background box
                    ctx.fillStyle = `rgba(0, 0, 0, ${0.7 * pulse})`;
                    const alertWidth = Math.min(width * 0.8, 500);
                    const alertHeight = 60;
                    const alertX = (width - alertWidth) / 2;
                    const alertY = 80;
                    
                    ctx.fillRect(alertX, alertY, alertWidth, alertHeight);
                    
                    // Border
                    ctx.strokeStyle = `rgba(255, 100, 100, ${pulse})`;
                    ctx.lineWidth = 3;
                    ctx.strokeRect(alertX, alertY, alertWidth, alertHeight);
                    
                    // Text
                    ctx.fillStyle = `rgba(255, 255, 255, ${pulse})`;
                    ctx.font = 'bold 20px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText(this.birdEvent.alertMessage, width / 2, alertY + 38);
                    
                    ctx.restore();
                }
                
                // Bird event timer display (small, top right)
                if (this.birdEvent && !this.isPaused) {
                    const timeLeft = Math.max(0, this.birdEvent.timer);
                    const minutes = Math.floor(timeLeft / 60000);
                    const seconds = Math.floor((timeLeft % 60000) / 1000);
                    const timeStr = `ðŸ¦ ${minutes}:${seconds.toString().padStart(2, '0')}`;
                    
                    ctx.save();
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    ctx.fillRect(width - 100, 10, 90, 25);
                    ctx.fillStyle = timeLeft < 60000 ? '#ff6666' : '#fff';
                    ctx.font = '14px monospace';
                    ctx.textAlign = 'right';
                    ctx.fillText(timeStr, width - 15, 28);
                    ctx.restore();
                }
                
                // Render AK-47 if selected - Traditional FPS horizontal gun
                if (this.selectedItem === 'ak47' && !this.isPaused) {
                    const s = Math.min(width, height) * 0.0055;
                    
                    // Position gun in lower right corner, pointing left toward center
                    const baseX = width * 0.75;
                    const baseY = height * 0.78;
                    
                    ctx.save();
                    ctx.translate(baseX, baseY);
                    ctx.rotate(-0.1); // Slight upward angle
                    
                    // === HAND (holding grip) ===
                    ctx.fillStyle = '#d4a574';  // Skin tone
                    ctx.beginPath();
                    ctx.ellipse(45 * s, 25 * s, 18 * s, 12 * s, 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    // Fingers wrapped around grip
                    ctx.fillStyle = '#c49a6c';
                    for (let i = 0; i < 4; i++) {
                        ctx.beginPath();
                        ctx.ellipse((35 + i * 7) * s, 35 * s, 4 * s, 8 * s, 0.2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    // Thumb
                    ctx.fillStyle = '#d4a574';
                    ctx.beginPath();
                    ctx.ellipse(30 * s, 15 * s, 6 * s, 10 * s, -0.5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // === STOCK (right side, behind receiver) ===
                    ctx.fillStyle = '#5a3d2b';
                    ctx.beginPath();
                    ctx.moveTo(80 * s, -5 * s);
                    ctx.lineTo(160 * s, 0 * s);
                    ctx.lineTo(165 * s, 25 * s);
                    ctx.lineTo(155 * s, 30 * s);
                    ctx.lineTo(80 * s, 25 * s);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Stock wood grain
                    ctx.fillStyle = '#6b4d3b';
                    ctx.fillRect(100 * s, 2 * s, 50 * s, 8 * s);
                    ctx.fillRect(95 * s, 15 * s, 55 * s, 6 * s);
                    
                    // Stock butt plate
                    ctx.fillStyle = '#333';
                    ctx.fillRect(155 * s, -2 * s, 8 * s, 30 * s);
                    
                    // === RECEIVER (main body) ===
                    ctx.fillStyle = '#2a2a2a';
                    ctx.fillRect(-30 * s, -8 * s, 115 * s, 30 * s);
                    
                    // Receiver top cover
                    ctx.fillStyle = '#3a3a3a';
                    ctx.fillRect(-25 * s, -12 * s, 100 * s, 8 * s);
                    
                    // Ejection port
                    ctx.fillStyle = '#1a1a1a';
                    ctx.fillRect(15 * s, -6 * s, 25 * s, 12 * s);
                    
                    // === BARREL & HANDGUARD ===
                    ctx.fillStyle = '#1a1a1a';
                    ctx.fillRect(-140 * s, -4 * s, 115 * s, 14 * s);
                    
                    // Barrel
                    ctx.fillStyle = '#111';
                    ctx.fillRect(-180 * s, 0 * s, 45 * s, 8 * s);
                    
                    // Barrel hole
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.ellipse(-182 * s, 4 * s, 3 * s, 3 * s, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Gas tube
                    ctx.fillStyle = '#333';
                    ctx.fillRect(-130 * s, -10 * s, 100 * s, 5 * s);
                    
                    // Handguard ventilation holes
                    ctx.fillStyle = '#111';
                    for (let i = 0; i < 4; i++) {
                        ctx.beginPath();
                        ctx.ellipse((-120 + i * 22) * s, 3 * s, 6 * s, 3 * s, 0, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // === FRONT SIGHT ===
                    ctx.fillStyle = '#1a1a1a';
                    ctx.fillRect(-145 * s, -20 * s, 6 * s, 18 * s);
                    ctx.fillRect(-148 * s, -22 * s, 12 * s, 4 * s);
                    
                    // === REAR SIGHT ===
                    ctx.fillRect(-5 * s, -18 * s, 15 * s, 8 * s);
                    
                    // === MAGAZINE (curved) ===
                    ctx.fillStyle = '#333';
                    ctx.beginPath();
                    ctx.moveTo(10 * s, 22 * s);
                    ctx.lineTo(35 * s, 22 * s);
                    ctx.quadraticCurveTo(45 * s, 50 * s, 35 * s, 80 * s);
                    ctx.lineTo(15 * s, 85 * s);
                    ctx.quadraticCurveTo(5 * s, 55 * s, 10 * s, 22 * s);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Magazine ridges
                    ctx.strokeStyle = '#222';
                    ctx.lineWidth = 1.5 * s;
                    for (let i = 0; i < 4; i++) {
                        ctx.beginPath();
                        ctx.moveTo((12 + i * 2) * s, (35 + i * 12) * s);
                        ctx.lineTo((32 + i * 1) * s, (38 + i * 12) * s);
                        ctx.stroke();
                    }
                    
                    // === GRIP ===
                    ctx.fillStyle = '#5a3d2b';
                    ctx.beginPath();
                    ctx.moveTo(45 * s, 22 * s);
                    ctx.lineTo(65 * s, 22 * s);
                    ctx.lineTo(70 * s, 65 * s);
                    ctx.lineTo(45 * s, 70 * s);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Grip texture
                    ctx.fillStyle = '#4a2d1b';
                    for (let i = 0; i < 5; i++) {
                        ctx.fillRect(50 * s, (28 + i * 8) * s, 12 * s, 3 * s);
                    }
                    
                    // === TRIGGER GUARD ===
                    ctx.strokeStyle = '#2a2a2a';
                    ctx.lineWidth = 3 * s;
                    ctx.beginPath();
                    ctx.arc(25 * s, 35 * s, 15 * s, -0.8, 2.2);
                    ctx.stroke();
                    
                    // Trigger
                    ctx.fillStyle = '#222';
                    ctx.fillRect(22 * s, 28 * s, 4 * s, 12 * s);
                    
                    // === MUZZLE FLASH ===
                    if (this.muzzleFlash > 0) {
                        const flashSize = 25 + Math.random() * 20;
                        const flashX = -190 * s;
                        const flashY = 4 * s;
                        
                        // Outer glow
                        ctx.fillStyle = 'rgba(255, 100, 0, 0.5)';
                        ctx.beginPath();
                        ctx.arc(flashX, flashY, flashSize * s * 1.5, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Orange middle
                        ctx.fillStyle = 'rgba(255, 150, 0, 0.8)';
                        ctx.beginPath();
                        ctx.arc(flashX, flashY, flashSize * s, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Yellow core
                        ctx.fillStyle = '#ffff00';
                        ctx.beginPath();
                        ctx.arc(flashX, flashY, flashSize * s * 0.4, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Flash spikes pointing left (toward screen center)
                        ctx.strokeStyle = '#ffff88';
                        ctx.lineWidth = 2;
                        for (let i = 0; i < 6; i++) {
                            const angle = Math.PI + (Math.random() - 0.5) * 1.5;
                            const len = (20 + Math.random() * 35) * s;
                            ctx.beginPath();
                            ctx.moveTo(flashX, flashY);
                            ctx.lineTo(flashX + Math.cos(angle) * len, flashY + Math.sin(angle) * len);
                            ctx.stroke();
                        }
                    }
                    
                    ctx.restore();
                }
                
                // Fluid overlay effects - only when HEAD is submerged
                if (this.headSubmergedWater) {
                    // Blue tint when head is underwater
                    ctx.fillStyle = 'rgba(0, 100, 200, 0.25)';
                    ctx.fillRect(0, 0, width, height);
                }
                
                if (this.headSubmergedLava) {
                    // Intense orange/red overlay with animated flames
                    const time = Date.now() * 0.005;
                    
                    // Base lava tint
                    ctx.fillStyle = 'rgba(255, 80, 0, 0.4)';
                    ctx.fillRect(0, 0, width, height);
                    
                    // Animated flame edges
                    ctx.fillStyle = 'rgba(255, 50, 0, 0.6)';
                    
                    // Bottom flames
                    for (let i = 0; i < 12; i++) {
                        const x = (i / 12) * width;
                        const flameHeight = 60 + Math.sin(time + i * 0.8) * 30 + Math.sin(time * 1.5 + i) * 20;
                        ctx.beginPath();
                        ctx.moveTo(x - 30, height);
                        ctx.quadraticCurveTo(x, height - flameHeight, x + 30, height);
                        ctx.fill();
                    }
                    
                    // Top flames (dripping down)
                    ctx.fillStyle = 'rgba(255, 100, 0, 0.5)';
                    for (let i = 0; i < 8; i++) {
                        const x = (i / 8) * width + 40;
                        const flameHeight = 40 + Math.sin(time * 0.8 + i * 1.2) * 25;
                        ctx.beginPath();
                        ctx.moveTo(x - 25, 0);
                        ctx.quadraticCurveTo(x, flameHeight, x + 25, 0);
                        ctx.fill();
                    }
                    
                    // Side flames
                    ctx.fillStyle = 'rgba(255, 60, 0, 0.5)';
                    for (let i = 0; i < 6; i++) {
                        const y = (i / 6) * height;
                        const flameWidth = 40 + Math.sin(time + i) * 20;
                        // Left side
                        ctx.beginPath();
                        ctx.moveTo(0, y - 30);
                        ctx.quadraticCurveTo(flameWidth, y, 0, y + 30);
                        ctx.fill();
                        // Right side
                        ctx.beginPath();
                        ctx.moveTo(width, y - 30);
                        ctx.quadraticCurveTo(width - flameWidth, y, width, y + 30);
                        ctx.fill();
                    }
                    
                    // Vignette effect
                    const gradient = ctx.createRadialGradient(width/2, height/2, 0, width/2, height/2, width * 0.7);
                    gradient.addColorStop(0, 'rgba(255, 50, 0, 0)');
                    gradient.addColorStop(0.7, 'rgba(255, 30, 0, 0.3)');
                    gradient.addColorStop(1, 'rgba(200, 0, 0, 0.6)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, width, height);
                }
            },
            
            project(x, y, z) {
                const dx = x - this.camera.x;
                const dy = y - this.camera.y;
                const dz = z - this.camera.z;
                
                const cosY = Math.cos(-this.camera.rotY);
                const sinY = Math.sin(-this.camera.rotY);
                const rx = dx * cosY - dz * sinY;
                const rz = dx * sinY + dz * cosY;
                
                const cosX = Math.cos(-this.camera.rotX);
                const sinX = Math.sin(-this.camera.rotX);
                const ry = dy * cosX - rz * sinX;
                const finalZ = dy * sinX + rz * cosX;
                
                if (finalZ <= 0.1) return null;
                
                const fov = 400;
                const screenX = this.canvas.width / 2 + (rx / finalZ) * fov;
                const screenY = this.canvas.height / 2 - (ry / finalZ) * fov;
                
                return { x: screenX, y: screenY, z: finalZ };
            },
            
            // Update block tooltip display
            updateBlockTooltip(blockType) {
                const tooltip = document.getElementById('blockTooltip');
                if (!tooltip) return;
                
                const socketInfo = {
                    'petalSocket': { name: 'Petal Socket', item: 'Requires: Sakura Petal', desc: 'Place a cherry blossom petal here' },
                    'ropeSocket': { name: 'Rope Socket', item: 'Requires: Sacred Rope', desc: 'Place a shimenawa rope here' },
                    'charmSocket': { name: 'Charm Socket', item: 'Requires: Omamori', desc: 'Place the protective charm here' },
                    'plaqueSocket': { name: 'Plaque Socket', item: 'Requires: Wish Plaque', desc: 'Place a wooden ema here' },
                    'incenseSocket': { name: 'Incense Socket', item: 'Requires: Incense', desc: 'Place purifying incense here' },
                    'petalSocketFilled': { name: 'Petal Socket âœ“', item: 'FILLED', desc: 'Cherry petal placed!' },
                    'ropeSocketFilled': { name: 'Rope Socket âœ“', item: 'FILLED', desc: 'Sacred rope placed!' },
                    'charmSocketFilled': { name: 'Charm Socket âœ“', item: 'FILLED', desc: 'Charm placed!' },
                    'plaqueSocketFilled': { name: 'Plaque Socket âœ“', item: 'FILLED', desc: 'Wish plaque placed!' },
                    'incenseSocketFilled': { name: 'Incense Socket âœ“', item: 'FILLED', desc: 'Incense placed!' }
                };
                
                const info = blockType ? socketInfo[blockType] : null;
                if (info) {
                    tooltip.classList.add('active');
                    tooltip.querySelector('.tooltip-title').textContent = info.name;
                    const isFilled = info.item === 'FILLED';
                    tooltip.querySelector('.tooltip-desc').innerHTML = 
                        `<span style="color:${isFilled ? '#4f4' : '#ffd700'}">${info.item}</span><br>${info.desc}`;
                } else {
                    tooltip.classList.remove('active');
                }
            },
            
            // Render player model (first-person body visible when looking down)
            renderPlayerModel(ctx, centerX, centerY, width, height) {
                // Only show body when looking down
                const lookDownAmount = Math.max(0, this.camera.rotX * 2); // 0 to 1 as player looks down
                if (lookDownAmount < 0.05) {
                    // Always show hands with held item even when not looking down
                    this.renderHeldItem(ctx, centerX, centerY, width, height);
                    return;
                }
                
                const alpha = Math.min(1, lookDownAmount);
                
                ctx.save();
                
                // Body position based on look angle
                const bodyY = height - 50 + (1 - lookDownAmount) * 200;
                
                // Draw the 3D body with shading
                this.drawPlayerBody3D(ctx, centerX, bodyY, alpha, lookDownAmount);
                
                ctx.restore();
                
                // Always render held item
                this.renderHeldItem(ctx, centerX, centerY, width, height);
            },
            
            // Render held item in first person
            renderHeldItem(ctx, centerX, centerY, width, height) {
                const slot = this.inventory.hotbar[this.selectedSlot];
                if (!slot) return;
                
                const itemId = slot.id;
                const bobOffset = Math.sin(Date.now() * 0.003) * 3;
                
                // Hand position (bottom right of screen)
                const handX = width - 120;
                const handY = height - 100 + bobOffset;
                const size = 60;
                
                ctx.save();
                ctx.translate(handX, handY);
                ctx.rotate(-0.2); // Slight tilt
                
                // Draw hand
                ctx.fillStyle = '#ffdab9'; // Skin tone
                ctx.beginPath();
                ctx.ellipse(0, 20, 25, 35, 0.3, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw item based on type
                const colors = this.blockColors[itemId];
                
                if (colors) {
                    // Block item - draw 3D cube
                    const s = size * 0.5;
                    ctx.translate(0, -10);
                    
                    // Top face
                    ctx.fillStyle = colors.top;
                    ctx.beginPath();
                    ctx.moveTo(0, -s);
                    ctx.lineTo(s, -s/2);
                    ctx.lineTo(0, 0);
                    ctx.lineTo(-s, -s/2);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Left face
                    ctx.fillStyle = colors.side;
                    ctx.beginPath();
                    ctx.moveTo(-s, -s/2);
                    ctx.lineTo(0, 0);
                    ctx.lineTo(0, s);
                    ctx.lineTo(-s, s/2);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Right face
                    ctx.fillStyle = this.darkenColor(colors.side, 0.7);
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(s, -s/2);
                    ctx.lineTo(s, s/2);
                    ctx.lineTo(0, s);
                    ctx.closePath();
                    ctx.fill();
                } else {
                    // Non-block item
                    if (itemId === 'ak47') {
                        ctx.fillStyle = '#333';
                        ctx.fillRect(-30, -20, 80, 15);
                        ctx.fillStyle = '#8b4513';
                        ctx.fillRect(-10, -5, 25, 25);
                        ctx.fillStyle = '#222';
                        ctx.fillRect(10, -5, 8, 20);
                    } else if (itemId === 'berdger') {
                        // Burger
                        ctx.fillStyle = '#daa520';
                        ctx.beginPath();
                        ctx.ellipse(0, -15, 25, 12, 0, Math.PI, 0);
                        ctx.fill();
                        ctx.fillStyle = '#8b4513';
                        ctx.fillRect(-22, -8, 44, 10);
                        ctx.fillStyle = '#228b22';
                        ctx.fillRect(-20, 0, 40, 5);
                        ctx.fillStyle = '#daa520';
                        ctx.beginPath();
                        ctx.ellipse(0, 10, 23, 10, 0, 0, Math.PI);
                        ctx.fill();
                    } else if (itemId === 'apple') {
                        ctx.fillStyle = '#dc143c';
                        ctx.beginPath();
                        ctx.arc(0, -5, 20, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#654321';
                        ctx.fillRect(-2, -30, 4, 10);
                        ctx.fillStyle = '#228b22';
                        ctx.beginPath();
                        ctx.ellipse(5, -28, 8, 4, 0.5, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (itemId === 'water_bucket' || itemId === 'lava_bucket') {
                        ctx.fillStyle = '#888';
                        ctx.beginPath();
                        ctx.moveTo(-20, -25);
                        ctx.lineTo(20, -25);
                        ctx.lineTo(15, 15);
                        ctx.lineTo(-15, 15);
                        ctx.closePath();
                        ctx.fill();
                        ctx.fillStyle = itemId === 'water_bucket' ? '#4a90d9' : '#ff6600';
                        ctx.fillRect(-15, -15, 30, 25);
                    } else if (itemId === 'seeds') {
                        ctx.fillStyle = '#daa520';
                        for (let i = 0; i < 5; i++) {
                            ctx.beginPath();
                            ctx.ellipse(Math.cos(i) * 10, Math.sin(i) * 8 - 10, 4, 6, i, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }
                
                ctx.restore();
            },
            
            // Draw the player body in 3D style with shading
            drawPlayerBody3D(ctx, centerX, bodyY, alpha, lookAmount) {
                ctx.save();
                
                // 3D depth effect - darker on edges
                const edgeShade = 0.7;
                
                // Torso - cherry blossom pink themed with 3D shading
                const gradient = ctx.createLinearGradient(centerX - 50, bodyY, centerX + 50, bodyY);
                gradient.addColorStop(0, `rgba(180, 130, 150, ${alpha})`);
                gradient.addColorStop(0.3, `rgba(255, 183, 197, ${alpha})`);
                gradient.addColorStop(0.7, `rgba(255, 183, 197, ${alpha})`);
                gradient.addColorStop(1, `rgba(180, 130, 150, ${alpha})`);
                ctx.fillStyle = gradient;
                
                // Draw torso as trapezoid with rounded corners
                ctx.beginPath();
                ctx.moveTo(centerX - 35, bodyY + 5);
                ctx.lineTo(centerX + 35, bodyY + 5);
                ctx.quadraticCurveTo(centerX + 50, bodyY + 40, centerX + 45, bodyY + 80);
                ctx.lineTo(centerX - 45, bodyY + 80);
                ctx.quadraticCurveTo(centerX - 50, bodyY + 40, centerX - 35, bodyY + 5);
                ctx.closePath();
                ctx.fill();
                
                // Collar V-neck
                ctx.fillStyle = `rgba(255, 240, 245, ${alpha * 0.8})`;
                ctx.beginPath();
                ctx.moveTo(centerX - 20, bodyY + 5);
                ctx.lineTo(centerX, bodyY + 25);
                ctx.lineTo(centerX + 20, bodyY + 5);
                ctx.closePath();
                ctx.fill();
                
                // Arms with 3D shading
                const armGradient = ctx.createRadialGradient(centerX - 55, bodyY + 30, 0, centerX - 55, bodyY + 30, 30);
                armGradient.addColorStop(0, `rgba(255, 228, 205, ${alpha})`);
                armGradient.addColorStop(1, `rgba(220, 180, 160, ${alpha})`);
                ctx.fillStyle = armGradient;
                ctx.beginPath();
                ctx.ellipse(centerX - 52, bodyY + 35, 14, 28, -0.2, 0, Math.PI * 2);
                ctx.fill();
                
                const armGradient2 = ctx.createRadialGradient(centerX + 55, bodyY + 30, 0, centerX + 55, bodyY + 30, 30);
                armGradient2.addColorStop(0, `rgba(255, 228, 205, ${alpha})`);
                armGradient2.addColorStop(1, `rgba(220, 180, 160, ${alpha})`);
                ctx.fillStyle = armGradient2;
                ctx.beginPath();
                ctx.ellipse(centerX + 52, bodyY + 35, 14, 28, 0.2, 0, Math.PI * 2);
                ctx.fill();
                
                // Hands
                ctx.fillStyle = `rgba(255, 218, 195, ${alpha})`;
                ctx.beginPath();
                ctx.arc(centerX - 55, bodyY + 60, 12, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(centerX + 55, bodyY + 60, 12, 0, Math.PI * 2);
                ctx.fill();
                
                // Legs with jeans texture effect
                const jeansGradient = ctx.createLinearGradient(centerX - 40, bodyY + 75, centerX + 40, bodyY + 75);
                jeansGradient.addColorStop(0, `rgba(50, 70, 100, ${alpha})`);
                jeansGradient.addColorStop(0.3, `rgba(70, 90, 120, ${alpha})`);
                jeansGradient.addColorStop(0.7, `rgba(70, 90, 120, ${alpha})`);
                jeansGradient.addColorStop(1, `rgba(50, 70, 100, ${alpha})`);
                ctx.fillStyle = jeansGradient;
                
                // Left leg
                ctx.beginPath();
                ctx.roundRect(centerX - 38, bodyY + 78, 28, 55, 3);
                ctx.fill();
                
                // Right leg
                ctx.beginPath();
                ctx.roundRect(centerX + 10, bodyY + 78, 28, 55, 3);
                ctx.fill();
                
                // Boots with shine
                ctx.fillStyle = `rgba(100, 60, 30, ${alpha})`;
                ctx.beginPath();
                ctx.roundRect(centerX - 42, bodyY + 128, 35, 20, 4);
                ctx.fill();
                ctx.beginPath();
                ctx.roundRect(centerX + 7, bodyY + 128, 35, 20, 4);
                ctx.fill();
                
                // Boot shine
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.2})`;
                ctx.beginPath();
                ctx.ellipse(centerX - 30, bodyY + 133, 8, 3, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(centerX + 20, bodyY + 133, 8, 3, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            },
            
            darkenColor(hex, factor) {
                // Use cache to avoid repeated hex parsing
                const key = hex + factor;
                if (!this.colorCache) this.colorCache = {};
                if (this.colorCache[key]) return this.colorCache[key];
                
                const r = Math.floor(parseInt(hex.slice(1, 3), 16) * factor);
                const g = Math.floor(parseInt(hex.slice(3, 5), 16) * factor);
                const b = Math.floor(parseInt(hex.slice(5, 7), 16) * factor);
                const result = `rgb(${r},${g},${b})`;
                this.colorCache[key] = result;
                return result;
            },
            
            gameLoop(timestamp) {
                // Completely stop loop when game is inactive
                if (!this.isActive) {
                    this.gameLoopId = null;
                    return;
                }
                
                // Initialize lastFrameTime if needed
                if (!this.lastFrameTime) this.lastFrameTime = timestamp;
                
                // Calculate frame interval based on target FPS
                const targetInterval = 1000 / this.settings.targetFps;
                const elapsed = timestamp - this.lastFrameTime;
                
                // Only update if enough time has passed for target FPS
                if (elapsed >= targetInterval) {
                    this.lastFrameTime = timestamp - (elapsed % targetInterval);
                    
                    // Update FPS counter
                    this.fpsCounter.frames++;
                    if (timestamp - this.fpsCounter.lastTime >= 1000) {
                        this.fpsCounter.fps = this.fpsCounter.frames;
                        this.fpsCounter.frames = 0;
                        this.fpsCounter.lastTime = timestamp;
                        
                        // Update debug console FPS
                        const debugFps = document.getElementById('debugFps');
                        if (debugFps) {
                            debugFps.textContent = `${this.fpsCounter.fps} FPS`;
                        }
                    }
                    
                    // Only update physics if not paused
                    if (!this.isPaused) {
                        this.update();
                        this.updateBirds();
                        this.updateParticles();
                        this.updateFluids();  // Fluid spreading simulation
                        this.updateWind();    // Wind dynamics
                        this.updatePetals();  // Cherry blossom petals
                        this.updateDroppedItems();  // Ground items
                        this.render();
                        
                        // Render FPS counter
                        if (this.settings.showFps) {
                            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                            this.ctx.fillRect(this.canvas.width - 70, this.canvas.height - 25, 65, 20);
                            this.ctx.fillStyle = '#00ff00';
                            this.ctx.font = '12px monospace';
                            this.ctx.textAlign = 'right';
                            this.ctx.fillText(`${this.fpsCounter.fps} FPS`, this.canvas.width - 10, this.canvas.height - 10);
                            this.ctx.textAlign = 'left';
                        }
                    }
                }
                
                // Store the ID so we can cancel it on stop
                this.gameLoopId = requestAnimationFrame((ts) => this.gameLoop(ts));
            },
            
            start() {
                // Initialize world on first start (deferred from page load)
                this.fullInit();
                
                this.isActive = true;
                this.isPaused = false;
                this.pointerLocked = false;
                this.stats = { blocksPlaced: 0, blocksBroken: 0, distance: 0, jumps: 0, startTime: Date.now() };
                document.getElementById('minecraftGame').classList.add('active');
                document.getElementById('pauseMenu').classList.remove('active');
                document.getElementById('gameUI').style.display = 'flex';
                
                // Find safe spawn location using a spiral search
                const findSafeSpawn = () => {
                    const preferredX = 0;
                    const preferredZ = -8;
                    
                    // Helper to check if a position is safe for spawning
                    const isSpawnSafe = (x, z) => {
                        // Find ground level
                        let groundY = null;
                        for (let checkY = 40; checkY >= 0; checkY--) {
                            const block = this.getBlock(x, checkY, z);
                            if (block && block !== 'water' && block !== 'lava') {
                                groundY = checkY;
                                break;
                            }
                        }
                        
                        if (groundY === null) return null; // No ground found
                        
                        const feetY = groundY + 1;
                        const bodyY = groundY + 2;
                        const headY = groundY + 3;
                        
                        // Check if there's space for the player (2 blocks of air above ground)
                        const feetBlock = this.getBlock(x, feetY, z);
                        const bodyBlock = this.getBlock(x, bodyY, z);
                        
                        // Both spaces must be empty or fluid (can spawn in water but not in solid)
                        const feetClear = !feetBlock || feetBlock === 'water' || feetBlock === 'lava';
                        const bodyClear = !bodyBlock || bodyBlock === 'water' || bodyBlock === 'lava';
                        
                        // Prefer spawning on dry land
                        const groundBlock = this.getBlock(x, groundY, z);
                        const isDryLand = groundBlock !== 'water' && groundBlock !== 'lava' && groundBlock !== 'sand';
                        
                        if (feetClear && bodyClear) {
                            return {
                                x: x,
                                y: feetY + this.playerEyeHeight,
                                z: z,
                                priority: isDryLand ? 1 : 2 // Prefer dry land
                            };
                        }
                        
                        return null;
                    };
                    
                    // Try preferred location first
                    let bestSpawn = isSpawnSafe(preferredX, preferredZ);
                    if (bestSpawn && bestSpawn.priority === 1) {
                        return bestSpawn;
                    }
                    
                    // Spiral search outward from preferred location
                    const maxRadius = 30;
                    for (let radius = 1; radius <= maxRadius; radius++) {
                        for (let dx = -radius; dx <= radius; dx++) {
                            for (let dz = -radius; dz <= radius; dz++) {
                                // Only check perimeter of current radius
                                if (Math.abs(dx) !== radius && Math.abs(dz) !== radius) continue;
                                
                                const spawn = isSpawnSafe(preferredX + dx, preferredZ + dz);
                                if (spawn) {
                                    if (spawn.priority === 1) {
                                        return spawn; // Found perfect spot
                                    }
                                    if (!bestSpawn || spawn.priority < bestSpawn.priority) {
                                        bestSpawn = spawn;
                                    }
                                }
                            }
                        }
                        
                        // If we found something decent, use it
                        if (bestSpawn && radius > 5) {
                            return bestSpawn;
                        }
                    }
                    
                    // Fallback - spawn high in the sky
                    return { x: 0, y: 30, z: 0 };
                };
                
                const spawnPos = findSafeSpawn();
                this.camera = { x: spawnPos.x + 0.5, y: spawnPos.y, z: spawnPos.z + 0.5, rotX: -0.3, rotY: 0 };
                this.canvas.style.filter = '';
                
                // Reset player state
                this.velocity = { x: 0, y: 0, z: 0 };
                this.isJumping = false;
                this.inWater = false;
                this.inLava = false;
                this.swimming = false;
                this.headSubmergedWater = false;
                this.headSubmergedLava = false;
                
                // Clear any lingering particles/fluids from previous session
                this.particles = [];
                this.fluidUpdates = [];
                
                // Initialize bird event system
                this.birdEvent = {
                    timer: 5 * 60 * 1000, // 5 minutes in ms
                    lastUpdate: Date.now(),
                    currentEvent: 0,
                    events: [
                        {
                            name: 'SWARM',
                            description: 'the birds will swarm!',
                            action: () => this.triggerBirdSwarm()
                        },
                        {
                            name: 'RAGE',
                            description: 'the birds will rage!',
                            action: () => this.triggerBirdRage()
                        },
                        {
                            name: 'MULTIPLY',
                            description: 'the birds will multiply!',
                            action: () => this.triggerBirdMultiply()
                        },
                        {
                            name: 'CREEPER INVASION',
                            description: 'creepers will stalk you!',
                            action: () => this.triggerCreeperInvasion()
                        }
                    ],
                    alertShown: { five: false, three: false, one: false, thirty: false, ten: false },
                    alertMessage: null,
                    alertFade: 0
                };
                
                // Initialize survival game stats
                this.survivalStats = {
                    score: 0,
                    wave: 1,
                    birdsDefeated: 0,
                    objectiveTimer: 0,
                    currentObjective: null,
                    objectives: [
                        { text: 'Survive the bird apocalypse!', type: 'survive' },
                        { text: 'Find the Ritual Temple', type: 'find_temple' },
                        { text: 'Collect 5 apples', type: 'collect', item: 'apple', count: 5 },
                        { text: 'Knock back 10 birds', type: 'knockback', count: 10 },
                        { text: 'Complete the Omamori ritual', type: 'ritual' }
                    ]
                };
                this.survivalStats.currentObjective = this.survivalStats.objectives[0];
                this.updateSurvivalHUD();
                
                // Hide main site animations to save GPU compositing
                const petalCanvas = document.getElementById('petalCanvas');
                if (petalCanvas) petalCanvas.style.display = 'none';
                
                // Hide flame particles container
                const flameParticles = document.getElementById('flameParticles');
                if (flameParticles) flameParticles.style.visibility = 'hidden';
                
                // Lock page scrolling while game is active
                document.body.style.overflow = 'hidden';
                document.documentElement.style.overflow = 'hidden';
                
                // Show click-to-play - user must click to lock pointer
                document.getElementById('clickToPlay').classList.add('active');
                
                // Start game loop (cancel any existing one first)
                if (this.gameLoopId) {
                    cancelAnimationFrame(this.gameLoopId);
                }
                
                // Force hotbar refresh with delay to ensure DOM is ready
                setTimeout(() => {
                    this.updateHotbarDisplay();
                    this.updateHotbar();
                }, 50);
                
                this.gameLoop();
            },
            
            pause() {
                if (!this.isActive) return;
                this.isPaused = true;
                document.getElementById('pauseMenu').classList.add('active');
                document.getElementById('gameUI').style.display = 'none';
                document.getElementById('clickToPlay').classList.remove('active');
                this.showSubmenu('menuMain');
                
                // Exit pointer lock if still locked
                if (document.pointerLockElement) {
                    document.exitPointerLock();
                }
            },
            
            resume() {
                this.isPaused = false;
                document.getElementById('pauseMenu').classList.remove('active');
                document.getElementById('gameUI').style.display = 'flex';
                
                // Must show click-to-play because we need a new user gesture to re-lock
                // (Browser security: can't re-lock immediately after ESC release)
                document.getElementById('clickToPlay').classList.add('active');
            },
            
            updateFullscreenButton() {
                const btn = document.getElementById('btnFullscreen');
                const isFs = document.fullscreenElement || document.webkitFullscreenElement;
                btn.textContent = isFs ? 'Windowed' : 'Fullscreen';
                
                // Update canvas size based on fullscreen state
                if (isFs) {
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight;
                } else {
                    this.canvas.width = 800;
                    this.canvas.height = 450;
                }
            },
            
            stop() {
                // Cancel any pending animation frame
                if (this.gameLoopId) {
                    cancelAnimationFrame(this.gameLoopId);
                    this.gameLoopId = null;
                }
                
                this.isActive = false;
                this.isPaused = false;
                this.pointerLocked = false;
                
                // Clear runtime resources to free memory
                this.particles = [];
                this.fluidUpdates = [];
                this.fluidUpdateTimer = 0;
                this.birdPruneTimer = 0;
                this.inWater = false;
                this.inLava = false;
                this.swimming = false;
                this.headSubmergedWater = false;
                this.headSubmergedLava = false;
                
                // Reset pest bird anger (calm down for next session)
                if (this.pestBirds) {
                    for (const pest of this.pestBirds) {
                        pest.anger = 0;
                        pest.timesShot = 0;
                        pest.state = 'circling';
                    }
                }
                
                // Reset canvas
                this.canvas.width = 800;
                this.canvas.height = 450;
                
                // Clear the canvas to free GPU memory
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Hide UI elements
                document.getElementById('minecraftGame').classList.remove('active');
                document.getElementById('pauseMenu').classList.remove('active');
                document.getElementById('clickToPlay').classList.remove('active');
                document.getElementById('inventoryScreen').classList.remove('active');
                this.inventoryOpen = false;
                this.canvas.style.filter = '';
                
                // Exit pointer lock
                if (document.pointerLockElement) {
                    document.exitPointerLock();
                }
                
                // Exit fullscreen if active
                if (document.fullscreenElement || document.webkitFullscreenElement) {
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    } else if (document.webkitExitFullscreen) {
                        document.webkitExitFullscreen();
                    }
                }
                
                // Reset key states to prevent stuck keys
                this.keys = {};
                
                // Unlock page scrolling
                document.body.style.overflow = '';
                document.documentElement.style.overflow = '';
                
                // Restore main site animations
                const petalCanvas = document.getElementById('petalCanvas');
                if (petalCanvas) petalCanvas.style.display = 'block';
                
                // Show flame particles container
                const flameParticles = document.getElementById('flameParticles');
                if (flameParticles) flameParticles.style.visibility = 'visible';
            }
        };

        // Initialize game on page load
        document.addEventListener('DOMContentLoaded', () => {
            // Lightweight init only - world generation deferred to start()
            minecraftGame.init();
            
            // Hero image click handler (subtle - no hint shown)
            document.querySelector('.hero-image-container').addEventListener('click', () => {
                minecraftGame.start();
            });
            
            // Close button
            document.getElementById('closeMinecraft').addEventListener('click', () => {
                minecraftGame.stop();
            });
            
            // Click-to-play overlay - request pointer lock
            document.getElementById('clickToPlay').addEventListener('click', () => {
                if (minecraftGame.isActive && !minecraftGame.isPaused) {
                    minecraftGame.canvas.requestPointerLock();
                }
            });
            
            // Page unload - clean up resources
            window.addEventListener('beforeunload', () => {
                if (minecraftGame.isActive) {
                    minecraftGame.stop();
                }
            });
        });


        // ========== INITIALIZE ==========
        document.addEventListener('DOMContentLoaded', () => {
            initClouds();
            animatePoetry();
            createDiagonalPetals();
            initPoetryFlipCard();
            initParallax();
            initCelestialBody();
        });
    </script>
</body>
</html>